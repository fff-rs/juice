<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `coaster` crate."><meta name="keywords" content="rust, rustlang, rust-lang, coaster"><title>coaster - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../coaster/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate coaster</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all coaster's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'coaster', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/coaster/lib.rs.html#1-217' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>coaster</a></span></h1><div class='docblock'><p>Provides a simple and unified API to run fast and highly parallel computations on different
devices such as CPUs and GPUs, accross different computation languages such as OpenCL and
CUDA and allows you to swap your backend on run-time.</p>
<p>Coaster was started at <a href="https://www.crunchbase.com/organization/autumn-ai">Autumn</a> to create an easy and performant abstraction over
different backends for the Machine Intelligence Framework <a href="https://github.com/spearow/leaf">Leaf</a>, with no hard
dependency on any driver or libraries so that it can easily be used without the need for a
long and painful build process.</p>
<h2 id="abstract" class="section-header"><a href="#abstract">Abstract</a></h2>
<p>Code often is executed on the native CPU, but could be executed on other devices such as GPUs
and Accelerators as well. These devices are accessable through frameworks like OpenCL and CUDA
but have a more complicated interfaces than your every-day native CPU
which makes the use of these devices a painful experience. Some of the pain points, when
writing such device code, are:</p>
<ul>
<li>non-portable: frameworks have different interfaces, devices support different versions and
machines might have different hardware - all this leads to code that will be executable only on
a very specific set of machines and platforms.</li>
<li>steep learning curve: executing code on a device through a framework is quite different to
running code on the native CPU and comes with a lot of hurdles. OpenCLs 1.2 specification for
example has close to 400 pages.</li>
<li>custom code: integrating support for devices into your project, requires the need for writing
a lot of custom code e.g. kernels, memory management, genereal business logic.</li>
</ul>
<p>But writing code for devices would often be a good choice as these devices can execute many
operations a lot faster than the native CPUs. GPUs for example can execute operations roughly
one to two orders of magnitudes faster, thanks to better support of parallelizing operations.
OpenCL and CUDA make parallelizing operations super easy.</p>
<p>With Coaster we eleminate the pain points of writing device code, so you can run your code
like any other Rust code, don't need to learn about kernels, events, or memory
synchronization, and can deploy your code with ease to servers, desktops or mobiles and
your code will make full use of the underlying hardware.</p>
<h2 id="architecture" class="section-header"><a href="#architecture">Architecture</a></h2>
<p>The single entry point of Coaster is a <a href="./backend/index.html">Backend</a>. A Backend is agnostic over the <a href="./device/index.html">Device</a> it
runs <a href="./operation/index.html">Operations</a> on. In order to be agnostic over the Device, such as native host CPU, GPUs,
Accelerators or other types of <a href="./hardware/index.html">Hardware</a>, the Backend needs to be agnostic over the
<a href="./framework/index.html">Framework</a> as well. A Framework is a computation language such as OpenCL, Cuda or the native programming
language. The Framework is important, as it provides us with the interface to turn Hardware into Devices and
therefore, among other things, execute Operations on the created Device. With a Framework, we get access to Hardware
as long as the Hardware supports the Framework. As different vendors of Hardware use different
Frameworks, it becomes important that the Backend is agnostic over the Framework. This allows us to
run computations on any machine such as servers, desktops and mobiles without the need to worry about what
Hardware is available on the machine. That gives us the freedom to write code once and deploy it on different
machines where it will execute on the most potent Hardware by default.</p>
<p>Operations get introduced by a <a href="./plugin/index.html">Plugin</a>. A Plugin extends your Backend with ready-to-execute Operations.
All you need to do is provide these Coaster Plugin crates alongside the Coaster crate in your Cargo
file. Your Backend will then be extended with the operations provided by the Plugin. The interface is just common
Rust e.g. to execute the dot product operation of the <a href="https://github.com/spearow/coaster-blas">Coaster-BLAS</a> Plugin,
we can simply call <code>backend.dot(...)</code>. Whether or not the dot Operation is executed on, e.g.
one or many GPUs or CPUs, depends solely on how you configured the Backend. If you did not further specify which
Framework and Hardware to use, it depends solely on the machine you execute the dot Operation on. The concept of Operations
has one more component - the <a href="./binary/index.html">Binary</a>. As opposed to executing code on the native CPU - devices need
to compile and build the Operation manually at run-time, which makes up a significant part of a Framework. We need
an initializable instance for holding the state and compiled Operations, wich the Binary is good for.</p>
<p>The last piece of Coaster is the <a href="./memory/index.html">Memory</a>. A Operation happens over data, but this data needs to be
accessable by the device on which the Operation is executed. The process is occurs often, that memory space needs
to be allocated on the device and then in a later step, synced from the host to the device or from
the device back to the host. Thanks to <a href="./tensor/index.html">Tensor</a> we do not have to care about memory management
between devices for the execution of Operations. Tensor tracks and automatically manages data and it's memory
accross devices, which is often the host and the Device. But it can also be passed around to different Backends.
Operations take Tensors as arguments and handle the synchronization and allocation for you.</p>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<p>This example requires the Coaster NN Plugin, for Neural Network related operations, to work.</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">coaster</span> <span class="kw">as</span> <span class="ident">co</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">coaster_nn</span> <span class="kw">as</span> <span class="ident">nn</span>;
<span class="kw">use</span> <span class="ident">co</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">nn</span>::<span class="kw-2">*</span>;

<span class="kw">fn</span> <span class="ident">write_to_memory</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Copy</span><span class="op">&gt;</span>(<span class="ident">mem</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">FlatBox</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">T</span>]) {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">mem_buffer</span> <span class="op">=</span> <span class="ident">mem</span>.<span class="ident">as_mut_slice</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>();
        <span class="kw">for</span> (<span class="ident">index</span>, <span class="ident">datum</span>) <span class="kw">in</span> <span class="ident">data</span>.<span class="ident">iter</span>().<span class="ident">enumerate</span>() {
            <span class="ident">mem_buffer</span>[<span class="ident">index</span>] <span class="op">=</span> <span class="kw-2">*</span><span class="ident">datum</span>;
        }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Initialize a CUDA Backend.</span>
    <span class="kw">let</span> <span class="ident">backend</span> <span class="op">=</span> <span class="ident">Backend</span>::<span class="op">&lt;</span><span class="ident">Cuda</span><span class="op">&gt;</span>::<span class="ident">default</span>().<span class="ident">unwrap</span>();
    <span class="comment">// Initialize two SharedTensors.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">SharedTensor</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>)).<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">SharedTensor</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>)).<span class="ident">unwrap</span>();
    <span class="comment">// Fill `x` with some data.</span>
    <span class="kw">let</span> <span class="ident">payload</span>: <span class="kw-2">&amp;</span>[<span class="ident">f32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>::<span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">repeat</span>(<span class="number">1f32</span>).<span class="ident">take</span>(<span class="ident">x</span>.<span class="ident">capacity</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span><span class="op">&gt;</span>();
    <span class="kw">let</span> <span class="ident">native</span> <span class="op">=</span> <span class="ident">Backend</span>::<span class="op">&lt;</span><span class="ident">Native</span><span class="op">&gt;</span>::<span class="ident">default</span>().<span class="ident">unwrap</span>();
    <span class="ident">write_to_memory</span>(<span class="ident">x</span>.<span class="ident">get_mut</span>(<span class="ident">native</span>.<span class="ident">device</span>()).<span class="ident">unwrap</span>(), <span class="ident">payload</span>); <span class="comment">// Write to native host memory.</span>
    <span class="comment">// Run the sigmoid operation, provided by the NN Plugin, on your CUDA enabled GPU.</span>
    <span class="ident">backend</span>.<span class="ident">sigmoid</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">result</span>).<span class="ident">unwrap</span>();
    <span class="comment">// See the result.</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">result</span>.<span class="ident">get</span>(<span class="ident">native</span>.<span class="ident">device</span>()).<span class="ident">unwrap</span>().<span class="ident">as_native</span>().<span class="ident">unwrap</span>().<span class="ident">as_slice</span>::<span class="op">&lt;</span><span class="ident">f32</span><span class="op">&gt;</span>());
}</pre></div>
<h2 id="development" class="section-header"><a href="#development">Development</a></h2>
<p>At the moment Coaster itself will provide Rust APIs for the important frameworks - OpenCL
and CUDA. One step we are looking out for is to seperate OpenCL and CUDA into their own crate.
Something similar to <a href="https://github.com/tomaka/glium">Glium</a>.</p>
<p>Every operation exposed via a Plugin and implemented on the backend, should take as the last argument an
<code>Option&lt;OperationConfig&gt;</code> to specify custom parallelisation behaviour and tracking the operation via events.</p>
<p>When initializing a new Backend from a BackendConfig you might not want to specify the Framework, which is currently
mandatory. Leaving it blank, the Backend would try to use the most potent Framework given the underlying hardware,
which would be probably in this order Cuda -&gt; OpenCL -&gt; Native. The setup might take longer, as every framework
needs to be checked, and devices be loaded in order to identify the best setup. But this would allow, that you
really could deploy a Coaster-backed application to almost any hardware - server, desktops, mobiles.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use crate::<a class="mod" href="../coaster/backend/index.html" title="mod coaster::backend">backend</a>::*;</code></td></tr><tr><td><code>pub use crate::device::<a class="trait" href="../coaster/device/trait.IDevice.html" title="trait coaster::device::IDevice">IDevice</a>;</code></td></tr><tr><td><code>pub use crate::device::<a class="trait" href="../coaster/device/trait.IMemory.html" title="trait coaster::device::IMemory">IMemory</a>;</code></td></tr><tr><td><code>pub use crate::hardware::<a class="trait" href="../coaster/hardware/trait.IHardware.html" title="trait coaster::hardware::IHardware">IHardware</a>;</code></td></tr><tr><td><code>pub use crate::hardware::<a class="enum" href="../coaster/hardware/enum.HardwareType.html" title="enum coaster::hardware::HardwareType">HardwareType</a>;</code></td></tr><tr><td><code>pub use crate::framework::<a class="trait" href="../coaster/framework/trait.IFramework.html" title="trait coaster::framework::IFramework">IFramework</a>;</code></td></tr><tr><td><code>pub use crate::tensor::<a class="struct" href="../coaster/tensor/struct.SharedTensor.html" title="struct coaster::tensor::SharedTensor">SharedTensor</a>;</code></td></tr><tr><td><code>pub use crate::tensor::<a class="type" href="../coaster/tensor/type.TensorDesc.html" title="type coaster::tensor::TensorDesc">TensorDesc</a>;</code></td></tr><tr><td><code>pub use crate::tensor::<a class="trait" href="../coaster/tensor/trait.ITensorDesc.html" title="trait coaster::tensor::ITensorDesc">ITensorDesc</a>;</code></td></tr><tr><td><code>pub use crate::tensor::<a class="trait" href="../coaster/tensor/trait.IntoTensorDesc.html" title="trait coaster::tensor::IntoTensorDesc">IntoTensorDesc</a>;</code></td></tr><tr><td><code>pub use crate::frameworks::<a class="struct" href="../coaster/frameworks/native/struct.Native.html" title="struct coaster::frameworks::native::Native">Native</a>;</code></td></tr><tr><td><code>pub use crate::frameworks::<a class="struct" href="../coaster/frameworks/cuda/struct.Cuda.html" title="struct coaster::frameworks::cuda::Cuda">Cuda</a>;</code></td></tr><tr><td><code>pub use crate::error::<a class="enum" href="../coaster/error/enum.Error.html" title="enum coaster::error::Error">Error</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="backend/index.html" title='coaster::backend mod'>backend</a></td><td class='docblock-short'><p>Provides the interface for running parallel computations on one ore many devices.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="binary/index.html" title='coaster::binary mod'>binary</a></td><td class='docblock-short'><p>Provides the generic functionality for a backend-specific implementation of a
[library][libraries].
[libraries]: ../libraries/index.html</p>
</td></tr><tr class='module-item'><td><a class="mod" href="device/index.html" title='coaster::device mod'>device</a></td><td class='docblock-short'><p>Provides a representation for one or many ready to use hardwares.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="error/index.html" title='coaster::error mod'>error</a></td><td class='docblock-short'><p>Defines the general set of error types in Coaster.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="framework/index.html" title='coaster::framework mod'>framework</a></td><td class='docblock-short'><p>Provides the generic functionality of a hardware supporting frameworks such as native CPU, OpenCL,
CUDA, etc..
[hardware]: ../hardware/index.html</p>
</td></tr><tr class='module-item'><td><a class="mod" href="frameworks/index.html" title='coaster::frameworks mod'>frameworks</a></td><td class='docblock-short'><p>Exposes the specific Framework implementations.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="hardware/index.html" title='coaster::hardware mod'>hardware</a></td><td class='docblock-short'><p>Provides a representation for a collection of available compute units e.g. CPUs or GPUs.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="operation/index.html" title='coaster::operation mod'>operation</a></td><td class='docblock-short'><p>Provides the generic functionality for backend-agnostic operations.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="plugin/index.html" title='coaster::plugin mod'>plugin</a></td><td class='docblock-short'><p>Provides helpers for explicit implementations of Backend [Operations][operation].
[operation]: ../operation/index.html</p>
</td></tr><tr class='module-item'><td><a class="mod" href="prelude/index.html" title='coaster::prelude mod'>prelude</a></td><td class='docblock-short'><p>A module meant to be glob imported when using Coaster.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="tensor/index.html" title='coaster::tensor mod'>tensor</a></td><td class='docblock-short'><p>Provides the functionality for memory management across devices.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "coaster";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>