<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `cudaHostRegister` fn in crate `rcudnn_sys`."><meta name="keywords" content="rust, rustlang, rust-lang, cudaHostRegister"><title>rcudnn_sys::cudaHostRegister - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc fn"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../rcudnn_sys/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class='location'><a href='index.html'>rcudnn_sys</a></p><script>window.sidebarCurrent = {name: 'cudaHostRegister', ty: 'fn', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/rcudnn_sys/generated.rs.html#9770-9774' title='goto source code'>[src]</a></span><span class='in-band'>Function <a href='index.html'>rcudnn_sys</a>::<wbr><a class="fn" href=''>cudaHostRegister</a></span></h1><pre class='rust fn'>pub unsafe extern &quot;C&quot; fn cudaHostRegister(<br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="enum" href="https://doc.rust-lang.org/nightly/core/ffi/enum.c_void.html" title="enum core::ffi::c_void">c_void</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;flags: c_uint<br>) -&gt; <a class="enum" href="../rcudnn_sys/enum.cudaError.html" title="enum rcudnn_sys::cudaError">cudaError_t</a></pre><div class='docblock'><p>\brief Registers an existing host memory range for use by CUDA</p>
<p>Page-locks the memory range specified by \p ptr and \p size and maps it
for the device(s) as specified by \p flags. This memory range also is added
to the same tracking mechanism as ::cudaHostAlloc() to automatically accelerate
calls to functions such as ::cudaMemcpy(). Since the memory can be accessed
directly by the device, it can be read or written with much higher bandwidth
than pageable memory that has not been registered.  Page-locking excessive
amounts of memory may degrade system performance, since it reduces the amount
of memory available to the system for paging. As a result, this function is
best used sparingly to register staging areas for data exchange between
host and device.</p>
<p>::cudaHostRegister is supported only on I/O coherent devices that have a non-zero
value for the device attribute ::cudaDevAttrHostRegisterSupported.</p>
<p>The \p flags parameter enables different options to be specified that
affect the allocation, as follows.</p>
<ul>
<li>
<p>::cudaHostRegisterDefault: On a system with unified virtual addressing,
the memory will be both mapped and portable.  On a system with no unified
virtual addressing, the memory will be neither mapped nor portable.</p>
</li>
<li>
<p>::cudaHostRegisterPortable: The memory returned by this call will be
considered as pinned memory by all CUDA contexts, not just the one that
performed the allocation.</p>
</li>
<li>
<p>::cudaHostRegisterMapped: Maps the allocation into the CUDA address
space. The device pointer to the memory may be obtained by calling
::cudaHostGetDevicePointer().</p>
</li>
<li>
<p>::cudaHostRegisterIoMemory: The passed memory pointer is treated as
pointing to some memory-mapped I/O space, e.g. belonging to a
third-party PCIe device, and it will marked as non cache-coherent and
contiguous.</p>
</li>
</ul>
<p>All of these flags are orthogonal to one another: a developer may page-lock
memory that is portable or mapped with no restrictions.</p>
<p>The CUDA context must have been created with the ::cudaMapHost flag in
order for the ::cudaHostRegisterMapped flag to have any effect.</p>
<p>The ::cudaHostRegisterMapped flag may be specified on CUDA contexts for
devices that do not support mapped pinned memory. The failure is deferred
to ::cudaHostGetDevicePointer() because the memory may be mapped into
other CUDA contexts via the ::cudaHostRegisterPortable flag.</p>
<p>For devices that have a non-zero value for the device attribute
::cudaDevAttrCanUseHostPointerForRegisteredMem, the memory
can also be accessed from the device using the host pointer \p ptr.
The device pointer returned by ::cudaHostGetDevicePointer() may or may not
match the original host pointer \p ptr and depends on the devices visible to the
application. If all devices visible to the application have a non-zero value for the
device attribute, the device pointer returned by ::cudaHostGetDevicePointer()
will match the original pointer \p ptr. If any device visible to the application
has a zero value for the device attribute, the device pointer returned by
::cudaHostGetDevicePointer() will not match the original host pointer \p ptr,
but it will be suitable for use on all devices provided Unified Virtual Addressing
is enabled. In such systems, it is valid to access the memory using either pointer
on devices that have a non-zero value for the device attribute. Note however that
such devices should access the memory using only of the two pointers and not both.</p>
<p>The memory page-locked by this function must be unregistered with ::cudaHostUnregister().</p>
<p>\param ptr   - Host pointer to memory to page-lock
\param size  - Size in bytes of the address range to page-lock in bytes
\param flags - Flags for allocation request</p>
<p>\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorMemoryAllocation,
::cudaErrorHostMemoryAlreadyRegistered,
::cudaErrorNotSupported
\notefnerr
\note_init_rt
\note_callback</p>
<p>\sa ::cudaHostUnregister, ::cudaHostGetFlags, ::cudaHostGetDevicePointer,
::cuMemHostRegister</p>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "rcudnn_sys";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>