/* automatically generated by rust-bindgen 0.60.1 */

//! Defines the FFI for CUDA cuDNN.
//!
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

pub const CUDNN_MAJOR: u32 = 8;
pub const CUDNN_MINOR: u32 = 7;
pub const CUDNN_PATCHLEVEL: u32 = 0;
pub const CUDNN_VERSION: u32 = 8700;
pub const CUDNN_MAX_SM_MAJOR_NUMBER: u32 = 9;
pub const CUDNN_MAX_SM_MINOR_NUMBER: u32 = 0;
pub const CUDNN_MAX_DEVICE_VERSION: u32 = 900;
pub const CUDNN_OPS_INFER_MAJOR: u32 = 8;
pub const CUDNN_OPS_INFER_MINOR: u32 = 7;
pub const CUDNN_OPS_INFER_PATCH: u32 = 0;
pub const CUDNN_DIM_MAX: u32 = 8;
pub const CUDNN_LRN_MIN_N: u32 = 1;
pub const CUDNN_LRN_MAX_N: u32 = 16;
pub const CUDNN_LRN_MIN_K: f64 = 0.00001;
pub const CUDNN_LRN_MIN_BETA: f64 = 0.01;
pub const CUDNN_BN_MIN_EPSILON: f64 = 0.0;
pub const CUDNN_OPS_TRAIN_MAJOR: u32 = 8;
pub const CUDNN_OPS_TRAIN_MINOR: u32 = 7;
pub const CUDNN_OPS_TRAIN_PATCH: u32 = 0;
pub const CUDNN_ADV_INFER_MAJOR: u32 = 8;
pub const CUDNN_ADV_INFER_MINOR: u32 = 7;
pub const CUDNN_ADV_INFER_PATCH: u32 = 0;
pub const CUDNN_RNN_PADDED_IO_DISABLED: u32 = 0;
pub const CUDNN_RNN_PADDED_IO_ENABLED: u32 = 1;
pub const CUDNN_SEQDATA_DIM_COUNT: u32 = 4;
pub const CUDNN_ATTN_QUERYMAP_ALL_TO_ONE: u32 = 0;
pub const CUDNN_ATTN_QUERYMAP_ONE_TO_ONE: u32 = 1;
pub const CUDNN_ATTN_DISABLE_PROJ_BIASES: u32 = 0;
pub const CUDNN_ATTN_ENABLE_PROJ_BIASES: u32 = 2;
pub const CUDNN_ATTN_WKIND_COUNT: u32 = 8;
pub const CUDNN_ADV_TRAIN_MAJOR: u32 = 8;
pub const CUDNN_ADV_TRAIN_MINOR: u32 = 7;
pub const CUDNN_ADV_TRAIN_PATCH: u32 = 0;
pub const CUDNN_CNN_INFER_MAJOR: u32 = 8;
pub const CUDNN_CNN_INFER_MINOR: u32 = 7;
pub const CUDNN_CNN_INFER_PATCH: u32 = 0;
pub const CUDNN_CNN_TRAIN_MAJOR: u32 = 8;
pub const CUDNN_CNN_TRAIN_MINOR: u32 = 7;
pub const CUDNN_CNN_TRAIN_PATCH: u32 = 0;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaRoundMode {
    cudaRoundNearest = 0,
    cudaRoundZero = 1,
    cudaRoundPosInf = 2,
    cudaRoundMinInf = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_dim3() {
    assert_eq!(
        ::std::mem::size_of::<dim3>(),
        12usize,
        concat!("Size of: ", stringify!(dim3))
    );
    assert_eq!(
        ::std::mem::align_of::<dim3>(),
        4usize,
        concat!("Alignment of ", stringify!(dim3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaError {
    cudaSuccess = 0,
    cudaErrorInvalidValue = 1,
    cudaErrorMemoryAllocation = 2,
    cudaErrorInitializationError = 3,
    cudaErrorCudartUnloading = 4,
    cudaErrorProfilerDisabled = 5,
    cudaErrorProfilerNotInitialized = 6,
    cudaErrorProfilerAlreadyStarted = 7,
    cudaErrorProfilerAlreadyStopped = 8,
    cudaErrorInvalidConfiguration = 9,
    cudaErrorInvalidPitchValue = 12,
    cudaErrorInvalidSymbol = 13,
    cudaErrorInvalidHostPointer = 16,
    cudaErrorInvalidDevicePointer = 17,
    cudaErrorInvalidTexture = 18,
    cudaErrorInvalidTextureBinding = 19,
    cudaErrorInvalidChannelDescriptor = 20,
    cudaErrorInvalidMemcpyDirection = 21,
    cudaErrorAddressOfConstant = 22,
    cudaErrorTextureFetchFailed = 23,
    cudaErrorTextureNotBound = 24,
    cudaErrorSynchronizationError = 25,
    cudaErrorInvalidFilterSetting = 26,
    cudaErrorInvalidNormSetting = 27,
    cudaErrorMixedDeviceExecution = 28,
    cudaErrorNotYetImplemented = 31,
    cudaErrorMemoryValueTooLarge = 32,
    cudaErrorStubLibrary = 34,
    cudaErrorInsufficientDriver = 35,
    cudaErrorCallRequiresNewerDriver = 36,
    cudaErrorInvalidSurface = 37,
    cudaErrorDuplicateVariableName = 43,
    cudaErrorDuplicateTextureName = 44,
    cudaErrorDuplicateSurfaceName = 45,
    cudaErrorDevicesUnavailable = 46,
    cudaErrorIncompatibleDriverContext = 49,
    cudaErrorMissingConfiguration = 52,
    cudaErrorPriorLaunchFailure = 53,
    cudaErrorLaunchMaxDepthExceeded = 65,
    cudaErrorLaunchFileScopedTex = 66,
    cudaErrorLaunchFileScopedSurf = 67,
    cudaErrorSyncDepthExceeded = 68,
    cudaErrorLaunchPendingCountExceeded = 69,
    cudaErrorInvalidDeviceFunction = 98,
    cudaErrorNoDevice = 100,
    cudaErrorInvalidDevice = 101,
    cudaErrorDeviceNotLicensed = 102,
    cudaErrorSoftwareValidityNotEstablished = 103,
    cudaErrorStartupFailure = 127,
    cudaErrorInvalidKernelImage = 200,
    cudaErrorDeviceUninitialized = 201,
    cudaErrorMapBufferObjectFailed = 205,
    cudaErrorUnmapBufferObjectFailed = 206,
    cudaErrorArrayIsMapped = 207,
    cudaErrorAlreadyMapped = 208,
    cudaErrorNoKernelImageForDevice = 209,
    cudaErrorAlreadyAcquired = 210,
    cudaErrorNotMapped = 211,
    cudaErrorNotMappedAsArray = 212,
    cudaErrorNotMappedAsPointer = 213,
    cudaErrorECCUncorrectable = 214,
    cudaErrorUnsupportedLimit = 215,
    cudaErrorDeviceAlreadyInUse = 216,
    cudaErrorPeerAccessUnsupported = 217,
    cudaErrorInvalidPtx = 218,
    cudaErrorInvalidGraphicsContext = 219,
    cudaErrorNvlinkUncorrectable = 220,
    cudaErrorJitCompilerNotFound = 221,
    cudaErrorUnsupportedPtxVersion = 222,
    cudaErrorJitCompilationDisabled = 223,
    cudaErrorUnsupportedExecAffinity = 224,
    cudaErrorInvalidSource = 300,
    cudaErrorFileNotFound = 301,
    cudaErrorSharedObjectSymbolNotFound = 302,
    cudaErrorSharedObjectInitFailed = 303,
    cudaErrorOperatingSystem = 304,
    cudaErrorInvalidResourceHandle = 400,
    cudaErrorIllegalState = 401,
    cudaErrorSymbolNotFound = 500,
    cudaErrorNotReady = 600,
    cudaErrorIllegalAddress = 700,
    cudaErrorLaunchOutOfResources = 701,
    cudaErrorLaunchTimeout = 702,
    cudaErrorLaunchIncompatibleTexturing = 703,
    cudaErrorPeerAccessAlreadyEnabled = 704,
    cudaErrorPeerAccessNotEnabled = 705,
    cudaErrorSetOnActiveProcess = 708,
    cudaErrorContextIsDestroyed = 709,
    cudaErrorAssert = 710,
    cudaErrorTooManyPeers = 711,
    cudaErrorHostMemoryAlreadyRegistered = 712,
    cudaErrorHostMemoryNotRegistered = 713,
    cudaErrorHardwareStackError = 714,
    cudaErrorIllegalInstruction = 715,
    cudaErrorMisalignedAddress = 716,
    cudaErrorInvalidAddressSpace = 717,
    cudaErrorInvalidPc = 718,
    cudaErrorLaunchFailure = 719,
    cudaErrorCooperativeLaunchTooLarge = 720,
    cudaErrorNotPermitted = 800,
    cudaErrorNotSupported = 801,
    cudaErrorSystemNotReady = 802,
    cudaErrorSystemDriverMismatch = 803,
    cudaErrorCompatNotSupportedOnDevice = 804,
    cudaErrorMpsConnectionFailed = 805,
    cudaErrorMpsRpcFailure = 806,
    cudaErrorMpsServerNotReady = 807,
    cudaErrorMpsMaxClientsReached = 808,
    cudaErrorMpsMaxConnectionsReached = 809,
    cudaErrorMpsClientTerminated = 810,
    cudaErrorCdpNotSupported = 811,
    cudaErrorCdpVersionMismatch = 812,
    cudaErrorStreamCaptureUnsupported = 900,
    cudaErrorStreamCaptureInvalidated = 901,
    cudaErrorStreamCaptureMerge = 902,
    cudaErrorStreamCaptureUnmatched = 903,
    cudaErrorStreamCaptureUnjoined = 904,
    cudaErrorStreamCaptureIsolation = 905,
    cudaErrorStreamCaptureImplicit = 906,
    cudaErrorCapturedEvent = 907,
    cudaErrorStreamCaptureWrongThread = 908,
    cudaErrorTimeout = 909,
    cudaErrorGraphExecUpdateFailure = 910,
    cudaErrorExternalDevice = 911,
    cudaErrorInvalidClusterSize = 912,
    cudaErrorUnknown = 999,
    cudaErrorApiFailureBase = 10000,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaChannelFormatKind {
    cudaChannelFormatKindSigned = 0,
    cudaChannelFormatKindUnsigned = 1,
    cudaChannelFormatKindFloat = 2,
    cudaChannelFormatKindNone = 3,
    cudaChannelFormatKindNV12 = 4,
    cudaChannelFormatKindUnsignedNormalized8X1 = 5,
    cudaChannelFormatKindUnsignedNormalized8X2 = 6,
    cudaChannelFormatKindUnsignedNormalized8X4 = 7,
    cudaChannelFormatKindUnsignedNormalized16X1 = 8,
    cudaChannelFormatKindUnsignedNormalized16X2 = 9,
    cudaChannelFormatKindUnsignedNormalized16X4 = 10,
    cudaChannelFormatKindSignedNormalized8X1 = 11,
    cudaChannelFormatKindSignedNormalized8X2 = 12,
    cudaChannelFormatKindSignedNormalized8X4 = 13,
    cudaChannelFormatKindSignedNormalized16X1 = 14,
    cudaChannelFormatKindSignedNormalized16X2 = 15,
    cudaChannelFormatKindSignedNormalized16X4 = 16,
    cudaChannelFormatKindUnsignedBlockCompressed1 = 17,
    cudaChannelFormatKindUnsignedBlockCompressed1SRGB = 18,
    cudaChannelFormatKindUnsignedBlockCompressed2 = 19,
    cudaChannelFormatKindUnsignedBlockCompressed2SRGB = 20,
    cudaChannelFormatKindUnsignedBlockCompressed3 = 21,
    cudaChannelFormatKindUnsignedBlockCompressed3SRGB = 22,
    cudaChannelFormatKindUnsignedBlockCompressed4 = 23,
    cudaChannelFormatKindSignedBlockCompressed4 = 24,
    cudaChannelFormatKindUnsignedBlockCompressed5 = 25,
    cudaChannelFormatKindSignedBlockCompressed5 = 26,
    cudaChannelFormatKindUnsignedBlockCompressed6H = 27,
    cudaChannelFormatKindSignedBlockCompressed6H = 28,
    cudaChannelFormatKindUnsignedBlockCompressed7 = 29,
    cudaChannelFormatKindUnsignedBlockCompressed7SRGB = 30,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaChannelFormatDesc {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
    pub f: cudaChannelFormatKind,
}
#[test]
fn bindgen_test_layout_cudaChannelFormatDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaChannelFormatDesc))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArray {
    _unused: [u8; 0],
}
pub type cudaArray_t = *mut cudaArray;
pub type cudaArray_const_t = *const cudaArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMipmappedArray {
    _unused: [u8; 0],
}
pub type cudaMipmappedArray_t = *mut cudaMipmappedArray;
pub type cudaMipmappedArray_const_t = *const cudaMipmappedArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties {
    pub tileExtent: cudaArraySparseProperties__bindgen_ty_1,
    pub miptailFirstLevel: ::libc::c_uint,
    pub miptailSize: ::libc::c_ulonglong,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties__bindgen_ty_1 {
    pub width: ::libc::c_uint,
    pub height: ::libc::c_uint,
    pub depth: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties() {
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties>(),
        48usize,
        concat!("Size of: ", stringify!(cudaArraySparseProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaArraySparseProperties))
    );
    fn test_field_tileExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tileExtent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(tileExtent)
            )
        );
    }
    test_field_tileExtent();
    fn test_field_miptailFirstLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptailFirstLevel) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(miptailFirstLevel)
            )
        );
    }
    test_field_miptailFirstLevel();
    fn test_field_miptailSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptailSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(miptailSize)
            )
        );
    }
    test_field_miptailSize();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArrayMemoryRequirements {
    pub size: usize,
    pub alignment: usize,
    pub reserved: [::libc::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_cudaArrayMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<cudaArrayMemoryRequirements>(),
        32usize,
        concat!("Size of: ", stringify!(cudaArrayMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArrayMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaArrayMemoryRequirements))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(alignment)
            )
        );
    }
    test_field_alignment();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemoryType {
    cudaMemoryTypeUnregistered = 0,
    cudaMemoryTypeHost = 1,
    cudaMemoryTypeDevice = 2,
    cudaMemoryTypeManaged = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemcpyKind {
    cudaMemcpyHostToHost = 0,
    cudaMemcpyHostToDevice = 1,
    cudaMemcpyDeviceToHost = 2,
    cudaMemcpyDeviceToDevice = 3,
    cudaMemcpyDefault = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPitchedPtr {
    pub ptr: *mut ::libc::c_void,
    pub pitch: usize,
    pub xsize: usize,
    pub ysize: usize,
}
#[test]
fn bindgen_test_layout_cudaPitchedPtr() {
    assert_eq!(
        ::std::mem::size_of::<cudaPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPitchedPtr))
    );
    fn test_field_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(ptr)
            )
        );
    }
    test_field_ptr();
    fn test_field_pitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(pitch)
            )
        );
    }
    test_field_pitch();
    fn test_field_xsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(xsize)
            )
        );
    }
    test_field_xsize();
    fn test_field_ysize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(ysize)
            )
        );
    }
    test_field_ysize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_cudaExtent() {
    assert_eq!(
        ::std::mem::size_of::<cudaExtent>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExtent))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPos {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[test]
fn bindgen_test_layout_cudaPos() {
    assert_eq!(
        ::std::mem::size_of::<cudaPos>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPos))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPos>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPos))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DParms {
    pub srcArray: cudaArray_t,
    pub srcPos: cudaPos,
    pub srcPtr: cudaPitchedPtr,
    pub dstArray: cudaArray_t,
    pub dstPos: cudaPos,
    pub dstPtr: cudaPitchedPtr,
    pub extent: cudaExtent,
    pub kind: cudaMemcpyKind,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DParms))
    );
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_srcPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcPos)
            )
        );
    }
    test_field_srcPos();
    fn test_field_srcPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcPtr)
            )
        );
    }
    test_field_srcPtr();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_dstPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstPos)
            )
        );
    }
    test_field_dstPos();
    fn test_field_dstPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstPtr)
            )
        );
    }
    test_field_dstPtr();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(kind)
            )
        );
    }
    test_field_kind();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DPeerParms {
    pub srcArray: cudaArray_t,
    pub srcPos: cudaPos,
    pub srcPtr: cudaPitchedPtr,
    pub srcDevice: ::libc::c_int,
    pub dstArray: cudaArray_t,
    pub dstPos: cudaPos,
    pub dstPtr: cudaPitchedPtr,
    pub dstDevice: ::libc::c_int,
    pub extent: cudaExtent,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DPeerParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DPeerParms>(),
        168usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DPeerParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DPeerParms))
    );
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_srcPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcPos)
            )
        );
    }
    test_field_srcPos();
    fn test_field_srcPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcPtr)
            )
        );
    }
    test_field_srcPtr();
    fn test_field_srcDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcDevice)
            )
        );
    }
    test_field_srcDevice();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_dstPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstPos)
            )
        );
    }
    test_field_dstPos();
    fn test_field_dstPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstPtr)
            )
        );
    }
    test_field_dstPtr();
    fn test_field_dstDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstDevice)
            )
        );
    }
    test_field_dstDevice();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemsetParams {
    pub dst: *mut ::libc::c_void,
    pub pitch: usize,
    pub value: ::libc::c_uint,
    pub elementSize: ::libc::c_uint,
    pub width: usize,
    pub height: usize,
}
#[test]
fn bindgen_test_layout_cudaMemsetParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemsetParams>(),
        40usize,
        concat!("Size of: ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemsetParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemsetParams))
    );
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_pitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(pitch)
            )
        );
    }
    test_field_pitch();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_elementSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(elementSize)
            )
        );
    }
    test_field_elementSize();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaAccessProperty {
    cudaAccessPropertyNormal = 0,
    cudaAccessPropertyStreaming = 1,
    cudaAccessPropertyPersisting = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaAccessPolicyWindow {
    pub base_ptr: *mut ::libc::c_void,
    pub num_bytes: usize,
    pub hitRatio: f32,
    pub hitProp: cudaAccessProperty,
    pub missProp: cudaAccessProperty,
}
#[test]
fn bindgen_test_layout_cudaAccessPolicyWindow() {
    assert_eq!(
        ::std::mem::size_of::<cudaAccessPolicyWindow>(),
        32usize,
        concat!("Size of: ", stringify!(cudaAccessPolicyWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaAccessPolicyWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaAccessPolicyWindow))
    );
    fn test_field_base_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(base_ptr)
            )
        );
    }
    test_field_base_ptr();
    fn test_field_num_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(num_bytes)
            )
        );
    }
    test_field_num_bytes();
    fn test_field_hitRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitRatio) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(hitRatio)
            )
        );
    }
    test_field_hitRatio();
    fn test_field_hitProp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitProp) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(hitProp)
            )
        );
    }
    test_field_hitProp();
    fn test_field_missProp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missProp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(missProp)
            )
        );
    }
    test_field_missProp();
}
pub type cudaHostFn_t = ::std::option::Option<unsafe extern "C" fn(userData: *mut ::libc::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaHostNodeParams {
    pub fn_: cudaHostFn_t,
    pub userData: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaHostNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaHostNodeParams>(),
        16usize,
        concat!("Size of: ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaHostNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaHostNodeParams))
    );
    fn test_field_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaHostNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaHostNodeParams),
                "::",
                stringify!(fn_)
            )
        );
    }
    test_field_fn();
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaHostNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaHostNodeParams),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaStreamCaptureStatus {
    cudaStreamCaptureStatusNone = 0,
    cudaStreamCaptureStatusActive = 1,
    cudaStreamCaptureStatusInvalidated = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaStreamCaptureMode {
    cudaStreamCaptureModeGlobal = 0,
    cudaStreamCaptureModeThreadLocal = 1,
    cudaStreamCaptureModeRelaxed = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaSynchronizationPolicy {
    cudaSyncPolicyAuto = 1,
    cudaSyncPolicySpin = 2,
    cudaSyncPolicyYield = 3,
    cudaSyncPolicyBlockingSync = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaClusterSchedulingPolicy {
    cudaClusterSchedulingPolicyDefault = 0,
    cudaClusterSchedulingPolicySpread = 1,
    cudaClusterSchedulingPolicyLoadBalancing = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaStreamUpdateCaptureDependenciesFlags {
    cudaStreamAddCaptureDependencies = 0,
    cudaStreamSetCaptureDependencies = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaUserObjectFlags {
    cudaUserObjectNoDestructorSync = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaUserObjectRetainFlags {
    cudaGraphUserObjectMove = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphicsResource {
    _unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphicsRegisterFlags {
    cudaGraphicsRegisterFlagsNone = 0,
    cudaGraphicsRegisterFlagsReadOnly = 1,
    cudaGraphicsRegisterFlagsWriteDiscard = 2,
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,
    cudaGraphicsRegisterFlagsTextureGather = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphicsMapFlags {
    cudaGraphicsMapFlagsNone = 0,
    cudaGraphicsMapFlagsReadOnly = 1,
    cudaGraphicsMapFlagsWriteDiscard = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphicsCubeFace {
    cudaGraphicsCubeFacePositiveX = 0,
    cudaGraphicsCubeFaceNegativeX = 1,
    cudaGraphicsCubeFacePositiveY = 2,
    cudaGraphicsCubeFaceNegativeY = 3,
    cudaGraphicsCubeFacePositiveZ = 4,
    cudaGraphicsCubeFaceNegativeZ = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaResourceType {
    cudaResourceTypeArray = 0,
    cudaResourceTypeMipmappedArray = 1,
    cudaResourceTypeLinear = 2,
    cudaResourceTypePitch2D = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaResourceViewFormat {
    cudaResViewFormatNone = 0,
    cudaResViewFormatUnsignedChar1 = 1,
    cudaResViewFormatUnsignedChar2 = 2,
    cudaResViewFormatUnsignedChar4 = 3,
    cudaResViewFormatSignedChar1 = 4,
    cudaResViewFormatSignedChar2 = 5,
    cudaResViewFormatSignedChar4 = 6,
    cudaResViewFormatUnsignedShort1 = 7,
    cudaResViewFormatUnsignedShort2 = 8,
    cudaResViewFormatUnsignedShort4 = 9,
    cudaResViewFormatSignedShort1 = 10,
    cudaResViewFormatSignedShort2 = 11,
    cudaResViewFormatSignedShort4 = 12,
    cudaResViewFormatUnsignedInt1 = 13,
    cudaResViewFormatUnsignedInt2 = 14,
    cudaResViewFormatUnsignedInt4 = 15,
    cudaResViewFormatSignedInt1 = 16,
    cudaResViewFormatSignedInt2 = 17,
    cudaResViewFormatSignedInt4 = 18,
    cudaResViewFormatHalf1 = 19,
    cudaResViewFormatHalf2 = 20,
    cudaResViewFormatHalf4 = 21,
    cudaResViewFormatFloat1 = 22,
    cudaResViewFormatFloat2 = 23,
    cudaResViewFormatFloat4 = 24,
    cudaResViewFormatUnsignedBlockCompressed1 = 25,
    cudaResViewFormatUnsignedBlockCompressed2 = 26,
    cudaResViewFormatUnsignedBlockCompressed3 = 27,
    cudaResViewFormatUnsignedBlockCompressed4 = 28,
    cudaResViewFormatSignedBlockCompressed4 = 29,
    cudaResViewFormatUnsignedBlockCompressed5 = 30,
    cudaResViewFormatSignedBlockCompressed5 = 31,
    cudaResViewFormatUnsignedBlockCompressed6H = 32,
    cudaResViewFormatSignedBlockCompressed6H = 33,
    cudaResViewFormatUnsignedBlockCompressed7 = 34,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaResourceDesc {
    pub resType: cudaResourceType,
    pub res: cudaResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaResourceDesc__bindgen_ty_1 {
    pub array: cudaResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: cudaResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: cudaArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: cudaMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: cudaChannelFormatDesc,
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_devPtr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(devPtr)
            )
        );
    }
    test_field_devPtr();
    fn test_field_desc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(desc)
            )
        );
    }
    test_field_desc();
    fn test_field_sizeInBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(sizeInBytes)
            )
        );
    }
    test_field_sizeInBytes();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: cudaChannelFormatDesc,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    fn test_field_devPtr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(devPtr)
            )
        );
    }
    test_field_devPtr();
    fn test_field_desc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(desc)
            )
        );
    }
    test_field_desc();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_pitchInBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(pitchInBytes)
            )
        );
    }
    test_field_pitchInBytes();
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
    fn test_field_linear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linear) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(linear)
            )
        );
    }
    test_field_linear();
    fn test_field_pitch2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(pitch2D)
            )
        );
    }
    test_field_pitch2D();
}
#[test]
fn bindgen_test_layout_cudaResourceDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc))
    );
    fn test_field_resType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc),
                "::",
                stringify!(resType)
            )
        );
    }
    test_field_resType();
    fn test_field_res() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc),
                "::",
                stringify!(res)
            )
        );
    }
    test_field_res();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceViewDesc {
    pub format: cudaResourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::libc::c_uint,
    pub lastMipmapLevel: ::libc::c_uint,
    pub firstLayer: ::libc::c_uint,
    pub lastLayer: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaResourceViewDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceViewDesc))
    );
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_firstMipmapLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(firstMipmapLevel)
            )
        );
    }
    test_field_firstMipmapLevel();
    fn test_field_lastMipmapLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(lastMipmapLevel)
            )
        );
    }
    test_field_lastMipmapLevel();
    fn test_field_firstLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(firstLayer)
            )
        );
    }
    test_field_firstLayer();
    fn test_field_lastLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(lastLayer)
            )
        );
    }
    test_field_lastLayer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPointerAttributes {
    pub type_: cudaMemoryType,
    pub device: ::libc::c_int,
    pub devicePointer: *mut ::libc::c_void,
    pub hostPointer: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaPointerAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaPointerAttributes>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPointerAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPointerAttributes))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_device() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(device)
            )
        );
    }
    test_field_device();
    fn test_field_devicePointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devicePointer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(devicePointer)
            )
        );
    }
    test_field_devicePointer();
    fn test_field_hostPointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostPointer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(hostPointer)
            )
        );
    }
    test_field_hostPointer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaFuncAttributes {
    pub sharedSizeBytes: usize,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub numRegs: ::libc::c_int,
    pub ptxVersion: ::libc::c_int,
    pub binaryVersion: ::libc::c_int,
    pub cacheModeCA: ::libc::c_int,
    pub maxDynamicSharedSizeBytes: ::libc::c_int,
    pub preferredShmemCarveout: ::libc::c_int,
    pub clusterDimMustBeSet: ::libc::c_int,
    pub requiredClusterWidth: ::libc::c_int,
    pub requiredClusterHeight: ::libc::c_int,
    pub requiredClusterDepth: ::libc::c_int,
    pub clusterSchedulingPolicyPreference: ::libc::c_int,
    pub nonPortableClusterSizeAllowed: ::libc::c_int,
    pub reserved: [::libc::c_int; 16usize],
}
#[test]
fn bindgen_test_layout_cudaFuncAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaFuncAttributes>(),
        144usize,
        concat!("Size of: ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaFuncAttributes))
    );
    fn test_field_sharedSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedSizeBytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(sharedSizeBytes)
            )
        );
    }
    test_field_sharedSizeBytes();
    fn test_field_constSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).constSizeBytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(constSizeBytes)
            )
        );
    }
    test_field_constSizeBytes();
    fn test_field_localSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localSizeBytes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(localSizeBytes)
            )
        );
    }
    test_field_localSizeBytes();
    fn test_field_maxThreadsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(maxThreadsPerBlock)
            )
        );
    }
    test_field_maxThreadsPerBlock();
    fn test_field_numRegs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numRegs) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(numRegs)
            )
        );
    }
    test_field_numRegs();
    fn test_field_ptxVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptxVersion) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(ptxVersion)
            )
        );
    }
    test_field_ptxVersion();
    fn test_field_binaryVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binaryVersion) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(binaryVersion)
            )
        );
    }
    test_field_binaryVersion();
    fn test_field_cacheModeCA() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cacheModeCA) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(cacheModeCA)
            )
        );
    }
    test_field_cacheModeCA();
    fn test_field_maxDynamicSharedSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDynamicSharedSizeBytes) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(maxDynamicSharedSizeBytes)
            )
        );
    }
    test_field_maxDynamicSharedSizeBytes();
    fn test_field_preferredShmemCarveout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preferredShmemCarveout) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(preferredShmemCarveout)
            )
        );
    }
    test_field_preferredShmemCarveout();
    fn test_field_clusterDimMustBeSet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clusterDimMustBeSet) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(clusterDimMustBeSet)
            )
        );
    }
    test_field_clusterDimMustBeSet();
    fn test_field_requiredClusterWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requiredClusterWidth) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(requiredClusterWidth)
            )
        );
    }
    test_field_requiredClusterWidth();
    fn test_field_requiredClusterHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requiredClusterHeight) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(requiredClusterHeight)
            )
        );
    }
    test_field_requiredClusterHeight();
    fn test_field_requiredClusterDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requiredClusterDepth) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(requiredClusterDepth)
            )
        );
    }
    test_field_requiredClusterDepth();
    fn test_field_clusterSchedulingPolicyPreference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clusterSchedulingPolicyPreference) as usize
                    - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(clusterSchedulingPolicyPreference)
            )
        );
    }
    test_field_clusterSchedulingPolicyPreference();
    fn test_field_nonPortableClusterSizeAllowed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nonPortableClusterSizeAllowed) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(nonPortableClusterSizeAllowed)
            )
        );
    }
    test_field_nonPortableClusterSizeAllowed();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFuncAttribute {
    cudaFuncAttributeMaxDynamicSharedMemorySize = 8,
    cudaFuncAttributePreferredSharedMemoryCarveout = 9,
    cudaFuncAttributeClusterDimMustBeSet = 10,
    cudaFuncAttributeRequiredClusterWidth = 11,
    cudaFuncAttributeRequiredClusterHeight = 12,
    cudaFuncAttributeRequiredClusterDepth = 13,
    cudaFuncAttributeNonPortableClusterSizeAllowed = 14,
    cudaFuncAttributeClusterSchedulingPolicyPreference = 15,
    cudaFuncAttributeMax = 16,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFuncCache {
    cudaFuncCachePreferNone = 0,
    cudaFuncCachePreferShared = 1,
    cudaFuncCachePreferL1 = 2,
    cudaFuncCachePreferEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaSharedMemConfig {
    cudaSharedMemBankSizeDefault = 0,
    cudaSharedMemBankSizeFourByte = 1,
    cudaSharedMemBankSizeEightByte = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaSharedCarveout {
    cudaSharedmemCarveoutDefault = -1,
    cudaSharedmemCarveoutMaxShared = 100,
    cudaSharedmemCarveoutMaxL1 = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaComputeMode {
    cudaComputeModeDefault = 0,
    cudaComputeModeExclusive = 1,
    cudaComputeModeProhibited = 2,
    cudaComputeModeExclusiveProcess = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaLimit {
    cudaLimitStackSize = 0,
    cudaLimitPrintfFifoSize = 1,
    cudaLimitMallocHeapSize = 2,
    cudaLimitDevRuntimeSyncDepth = 3,
    cudaLimitDevRuntimePendingLaunchCount = 4,
    cudaLimitMaxL2FetchGranularity = 5,
    cudaLimitPersistingL2CacheSize = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemoryAdvise {
    cudaMemAdviseSetReadMostly = 1,
    cudaMemAdviseUnsetReadMostly = 2,
    cudaMemAdviseSetPreferredLocation = 3,
    cudaMemAdviseUnsetPreferredLocation = 4,
    cudaMemAdviseSetAccessedBy = 5,
    cudaMemAdviseUnsetAccessedBy = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemRangeAttribute {
    cudaMemRangeAttributeReadMostly = 1,
    cudaMemRangeAttributePreferredLocation = 2,
    cudaMemRangeAttributeAccessedBy = 3,
    cudaMemRangeAttributeLastPrefetchLocation = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesOptions {
    cudaFlushGPUDirectRDMAWritesOptionHost = 1,
    cudaFlushGPUDirectRDMAWritesOptionMemOps = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGPUDirectRDMAWritesOrdering {
    cudaGPUDirectRDMAWritesOrderingNone = 0,
    cudaGPUDirectRDMAWritesOrderingOwner = 100,
    cudaGPUDirectRDMAWritesOrderingAllDevices = 200,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesScope {
    cudaFlushGPUDirectRDMAWritesToOwner = 100,
    cudaFlushGPUDirectRDMAWritesToAllDevices = 200,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesTarget {
    cudaFlushGPUDirectRDMAWritesTargetCurrentDevice = 0,
}
impl cudaDeviceAttr {
    pub const cudaDevAttrMaxTimelineSemaphoreInteropSupported: cudaDeviceAttr =
        cudaDeviceAttr::cudaDevAttrTimelineSemaphoreInteropSupported;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaDeviceAttr {
    cudaDevAttrMaxThreadsPerBlock = 1,
    cudaDevAttrMaxBlockDimX = 2,
    cudaDevAttrMaxBlockDimY = 3,
    cudaDevAttrMaxBlockDimZ = 4,
    cudaDevAttrMaxGridDimX = 5,
    cudaDevAttrMaxGridDimY = 6,
    cudaDevAttrMaxGridDimZ = 7,
    cudaDevAttrMaxSharedMemoryPerBlock = 8,
    cudaDevAttrTotalConstantMemory = 9,
    cudaDevAttrWarpSize = 10,
    cudaDevAttrMaxPitch = 11,
    cudaDevAttrMaxRegistersPerBlock = 12,
    cudaDevAttrClockRate = 13,
    cudaDevAttrTextureAlignment = 14,
    cudaDevAttrGpuOverlap = 15,
    cudaDevAttrMultiProcessorCount = 16,
    cudaDevAttrKernelExecTimeout = 17,
    cudaDevAttrIntegrated = 18,
    cudaDevAttrCanMapHostMemory = 19,
    cudaDevAttrComputeMode = 20,
    cudaDevAttrMaxTexture1DWidth = 21,
    cudaDevAttrMaxTexture2DWidth = 22,
    cudaDevAttrMaxTexture2DHeight = 23,
    cudaDevAttrMaxTexture3DWidth = 24,
    cudaDevAttrMaxTexture3DHeight = 25,
    cudaDevAttrMaxTexture3DDepth = 26,
    cudaDevAttrMaxTexture2DLayeredWidth = 27,
    cudaDevAttrMaxTexture2DLayeredHeight = 28,
    cudaDevAttrMaxTexture2DLayeredLayers = 29,
    cudaDevAttrSurfaceAlignment = 30,
    cudaDevAttrConcurrentKernels = 31,
    cudaDevAttrEccEnabled = 32,
    cudaDevAttrPciBusId = 33,
    cudaDevAttrPciDeviceId = 34,
    cudaDevAttrTccDriver = 35,
    cudaDevAttrMemoryClockRate = 36,
    cudaDevAttrGlobalMemoryBusWidth = 37,
    cudaDevAttrL2CacheSize = 38,
    cudaDevAttrMaxThreadsPerMultiProcessor = 39,
    cudaDevAttrAsyncEngineCount = 40,
    cudaDevAttrUnifiedAddressing = 41,
    cudaDevAttrMaxTexture1DLayeredWidth = 42,
    cudaDevAttrMaxTexture1DLayeredLayers = 43,
    cudaDevAttrMaxTexture2DGatherWidth = 45,
    cudaDevAttrMaxTexture2DGatherHeight = 46,
    cudaDevAttrMaxTexture3DWidthAlt = 47,
    cudaDevAttrMaxTexture3DHeightAlt = 48,
    cudaDevAttrMaxTexture3DDepthAlt = 49,
    cudaDevAttrPciDomainId = 50,
    cudaDevAttrTexturePitchAlignment = 51,
    cudaDevAttrMaxTextureCubemapWidth = 52,
    cudaDevAttrMaxTextureCubemapLayeredWidth = 53,
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54,
    cudaDevAttrMaxSurface1DWidth = 55,
    cudaDevAttrMaxSurface2DWidth = 56,
    cudaDevAttrMaxSurface2DHeight = 57,
    cudaDevAttrMaxSurface3DWidth = 58,
    cudaDevAttrMaxSurface3DHeight = 59,
    cudaDevAttrMaxSurface3DDepth = 60,
    cudaDevAttrMaxSurface1DLayeredWidth = 61,
    cudaDevAttrMaxSurface1DLayeredLayers = 62,
    cudaDevAttrMaxSurface2DLayeredWidth = 63,
    cudaDevAttrMaxSurface2DLayeredHeight = 64,
    cudaDevAttrMaxSurface2DLayeredLayers = 65,
    cudaDevAttrMaxSurfaceCubemapWidth = 66,
    cudaDevAttrMaxSurfaceCubemapLayeredWidth = 67,
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68,
    cudaDevAttrMaxTexture1DLinearWidth = 69,
    cudaDevAttrMaxTexture2DLinearWidth = 70,
    cudaDevAttrMaxTexture2DLinearHeight = 71,
    cudaDevAttrMaxTexture2DLinearPitch = 72,
    cudaDevAttrMaxTexture2DMipmappedWidth = 73,
    cudaDevAttrMaxTexture2DMipmappedHeight = 74,
    cudaDevAttrComputeCapabilityMajor = 75,
    cudaDevAttrComputeCapabilityMinor = 76,
    cudaDevAttrMaxTexture1DMipmappedWidth = 77,
    cudaDevAttrStreamPrioritiesSupported = 78,
    cudaDevAttrGlobalL1CacheSupported = 79,
    cudaDevAttrLocalL1CacheSupported = 80,
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81,
    cudaDevAttrMaxRegistersPerMultiprocessor = 82,
    cudaDevAttrManagedMemory = 83,
    cudaDevAttrIsMultiGpuBoard = 84,
    cudaDevAttrMultiGpuBoardGroupID = 85,
    cudaDevAttrHostNativeAtomicSupported = 86,
    cudaDevAttrSingleToDoublePrecisionPerfRatio = 87,
    cudaDevAttrPageableMemoryAccess = 88,
    cudaDevAttrConcurrentManagedAccess = 89,
    cudaDevAttrComputePreemptionSupported = 90,
    cudaDevAttrCanUseHostPointerForRegisteredMem = 91,
    cudaDevAttrReserved92 = 92,
    cudaDevAttrReserved93 = 93,
    cudaDevAttrReserved94 = 94,
    cudaDevAttrCooperativeLaunch = 95,
    cudaDevAttrCooperativeMultiDeviceLaunch = 96,
    cudaDevAttrMaxSharedMemoryPerBlockOptin = 97,
    cudaDevAttrCanFlushRemoteWrites = 98,
    cudaDevAttrHostRegisterSupported = 99,
    cudaDevAttrPageableMemoryAccessUsesHostPageTables = 100,
    cudaDevAttrDirectManagedMemAccessFromHost = 101,
    cudaDevAttrMaxBlocksPerMultiprocessor = 106,
    cudaDevAttrMaxPersistingL2CacheSize = 108,
    cudaDevAttrMaxAccessPolicyWindowSize = 109,
    cudaDevAttrReservedSharedMemoryPerBlock = 111,
    cudaDevAttrSparseCudaArraySupported = 112,
    cudaDevAttrHostRegisterReadOnlySupported = 113,
    cudaDevAttrTimelineSemaphoreInteropSupported = 114,
    cudaDevAttrMemoryPoolsSupported = 115,
    cudaDevAttrGPUDirectRDMASupported = 116,
    cudaDevAttrGPUDirectRDMAFlushWritesOptions = 117,
    cudaDevAttrGPUDirectRDMAWritesOrdering = 118,
    cudaDevAttrMemoryPoolSupportedHandleTypes = 119,
    cudaDevAttrClusterLaunch = 120,
    cudaDevAttrDeferredMappingCudaArraySupported = 121,
    cudaDevAttrReserved122 = 122,
    cudaDevAttrReserved123 = 123,
    cudaDevAttrReserved124 = 124,
    cudaDevAttrIpcEventSupport = 125,
    cudaDevAttrMemSyncDomainCount = 126,
    cudaDevAttrMax = 127,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemPoolAttr {
    cudaMemPoolReuseFollowEventDependencies = 1,
    cudaMemPoolReuseAllowOpportunistic = 2,
    cudaMemPoolReuseAllowInternalDependencies = 3,
    cudaMemPoolAttrReleaseThreshold = 4,
    cudaMemPoolAttrReservedMemCurrent = 5,
    cudaMemPoolAttrReservedMemHigh = 6,
    cudaMemPoolAttrUsedMemCurrent = 7,
    cudaMemPoolAttrUsedMemHigh = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemLocationType {
    cudaMemLocationTypeInvalid = 0,
    cudaMemLocationTypeDevice = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemLocation {
    pub type_: cudaMemLocationType,
    pub id: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaMemLocation() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemLocation>(),
        8usize,
        concat!("Size of: ", stringify!(cudaMemLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemLocation>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemLocation))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemLocation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemLocation),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemLocation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemLocation),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemAccessFlags {
    cudaMemAccessFlagsProtNone = 0,
    cudaMemAccessFlagsProtRead = 1,
    cudaMemAccessFlagsProtReadWrite = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAccessDesc {
    pub location: cudaMemLocation,
    pub flags: cudaMemAccessFlags,
}
#[test]
fn bindgen_test_layout_cudaMemAccessDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemAccessDesc>(),
        12usize,
        concat!("Size of: ", stringify!(cudaMemAccessDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAccessDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemAccessDesc))
    );
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAccessDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAccessDesc),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAccessDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAccessDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemAllocationType {
    cudaMemAllocationTypeInvalid = 0,
    cudaMemAllocationTypePinned = 1,
    cudaMemAllocationTypeMax = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemAllocationHandleType {
    cudaMemHandleTypeNone = 0,
    cudaMemHandleTypePosixFileDescriptor = 1,
    cudaMemHandleTypeWin32 = 2,
    cudaMemHandleTypeWin32Kmt = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemPoolProps {
    pub allocType: cudaMemAllocationType,
    pub handleTypes: cudaMemAllocationHandleType,
    pub location: cudaMemLocation,
    pub win32SecurityAttributes: *mut ::libc::c_void,
    pub reserved: [::libc::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolProps() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolProps>(),
        88usize,
        concat!("Size of: ", stringify!(cudaMemPoolProps))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolProps>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemPoolProps))
    );
    fn test_field_allocType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(allocType)
            )
        );
    }
    test_field_allocType();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_win32SecurityAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32SecurityAttributes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(win32SecurityAttributes)
            )
        );
    }
    test_field_win32SecurityAttributes();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemPoolPtrExportData {
    pub reserved: [::libc::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolPtrExportData() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolPtrExportData>(),
        64usize,
        concat!("Size of: ", stringify!(cudaMemPoolPtrExportData))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolPtrExportData>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaMemPoolPtrExportData))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolPtrExportData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolPtrExportData),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAllocNodeParams {
    pub poolProps: cudaMemPoolProps,
    pub accessDescs: *const cudaMemAccessDesc,
    pub accessDescCount: usize,
    pub bytesize: usize,
    pub dptr: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaMemAllocNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemAllocNodeParams>(),
        120usize,
        concat!("Size of: ", stringify!(cudaMemAllocNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAllocNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemAllocNodeParams))
    );
    fn test_field_poolProps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(poolProps)
            )
        );
    }
    test_field_poolProps();
    fn test_field_accessDescs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(accessDescs)
            )
        );
    }
    test_field_accessDescs();
    fn test_field_accessDescCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(accessDescCount)
            )
        );
    }
    test_field_accessDescCount();
    fn test_field_bytesize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(bytesize)
            )
        );
    }
    test_field_bytesize();
    fn test_field_dptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(dptr)
            )
        );
    }
    test_field_dptr();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphMemAttributeType {
    cudaGraphMemAttrUsedMemCurrent = 0,
    cudaGraphMemAttrUsedMemHigh = 1,
    cudaGraphMemAttrReservedMemCurrent = 2,
    cudaGraphMemAttrReservedMemHigh = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaDeviceP2PAttr {
    cudaDevP2PAttrPerformanceRank = 1,
    cudaDevP2PAttrAccessSupported = 2,
    cudaDevP2PAttrNativeAtomicSupported = 3,
    cudaDevP2PAttrCudaArrayAccessSupported = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    fn test_field_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUuuid_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUuuid_st),
                "::",
                stringify!(bytes)
            )
        );
    }
    test_field_bytes();
}
pub type CUuuid = CUuuid_st;
pub type cudaUUID_t = CUuuid_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaDeviceProp {
    pub name: [::libc::c_char; 256usize],
    pub uuid: cudaUUID_t,
    pub luid: [::libc::c_char; 8usize],
    pub luidDeviceNodeMask: ::libc::c_uint,
    pub totalGlobalMem: usize,
    pub sharedMemPerBlock: usize,
    pub regsPerBlock: ::libc::c_int,
    pub warpSize: ::libc::c_int,
    pub memPitch: usize,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub maxThreadsDim: [::libc::c_int; 3usize],
    pub maxGridSize: [::libc::c_int; 3usize],
    pub clockRate: ::libc::c_int,
    pub totalConstMem: usize,
    pub major: ::libc::c_int,
    pub minor: ::libc::c_int,
    pub textureAlignment: usize,
    pub texturePitchAlignment: usize,
    pub deviceOverlap: ::libc::c_int,
    pub multiProcessorCount: ::libc::c_int,
    pub kernelExecTimeoutEnabled: ::libc::c_int,
    pub integrated: ::libc::c_int,
    pub canMapHostMemory: ::libc::c_int,
    pub computeMode: ::libc::c_int,
    pub maxTexture1D: ::libc::c_int,
    pub maxTexture1DMipmap: ::libc::c_int,
    pub maxTexture1DLinear: ::libc::c_int,
    pub maxTexture2D: [::libc::c_int; 2usize],
    pub maxTexture2DMipmap: [::libc::c_int; 2usize],
    pub maxTexture2DLinear: [::libc::c_int; 3usize],
    pub maxTexture2DGather: [::libc::c_int; 2usize],
    pub maxTexture3D: [::libc::c_int; 3usize],
    pub maxTexture3DAlt: [::libc::c_int; 3usize],
    pub maxTextureCubemap: ::libc::c_int,
    pub maxTexture1DLayered: [::libc::c_int; 2usize],
    pub maxTexture2DLayered: [::libc::c_int; 3usize],
    pub maxTextureCubemapLayered: [::libc::c_int; 2usize],
    pub maxSurface1D: ::libc::c_int,
    pub maxSurface2D: [::libc::c_int; 2usize],
    pub maxSurface3D: [::libc::c_int; 3usize],
    pub maxSurface1DLayered: [::libc::c_int; 2usize],
    pub maxSurface2DLayered: [::libc::c_int; 3usize],
    pub maxSurfaceCubemap: ::libc::c_int,
    pub maxSurfaceCubemapLayered: [::libc::c_int; 2usize],
    pub surfaceAlignment: usize,
    pub concurrentKernels: ::libc::c_int,
    pub ECCEnabled: ::libc::c_int,
    pub pciBusID: ::libc::c_int,
    pub pciDeviceID: ::libc::c_int,
    pub pciDomainID: ::libc::c_int,
    pub tccDriver: ::libc::c_int,
    pub asyncEngineCount: ::libc::c_int,
    pub unifiedAddressing: ::libc::c_int,
    pub memoryClockRate: ::libc::c_int,
    pub memoryBusWidth: ::libc::c_int,
    pub l2CacheSize: ::libc::c_int,
    pub persistingL2CacheMaxSize: ::libc::c_int,
    pub maxThreadsPerMultiProcessor: ::libc::c_int,
    pub streamPrioritiesSupported: ::libc::c_int,
    pub globalL1CacheSupported: ::libc::c_int,
    pub localL1CacheSupported: ::libc::c_int,
    pub sharedMemPerMultiprocessor: usize,
    pub regsPerMultiprocessor: ::libc::c_int,
    pub managedMemory: ::libc::c_int,
    pub isMultiGpuBoard: ::libc::c_int,
    pub multiGpuBoardGroupID: ::libc::c_int,
    pub hostNativeAtomicSupported: ::libc::c_int,
    pub singleToDoublePrecisionPerfRatio: ::libc::c_int,
    pub pageableMemoryAccess: ::libc::c_int,
    pub concurrentManagedAccess: ::libc::c_int,
    pub computePreemptionSupported: ::libc::c_int,
    pub canUseHostPointerForRegisteredMem: ::libc::c_int,
    pub cooperativeLaunch: ::libc::c_int,
    pub cooperativeMultiDeviceLaunch: ::libc::c_int,
    pub sharedMemPerBlockOptin: usize,
    pub pageableMemoryAccessUsesHostPageTables: ::libc::c_int,
    pub directManagedMemAccessFromHost: ::libc::c_int,
    pub maxBlocksPerMultiProcessor: ::libc::c_int,
    pub accessPolicyMaxWindowSize: ::libc::c_int,
    pub reservedSharedMemPerBlock: usize,
    pub hostRegisterSupported: ::libc::c_int,
    pub sparseCudaArraySupported: ::libc::c_int,
    pub hostRegisterReadOnlySupported: ::libc::c_int,
    pub timelineSemaphoreInteropSupported: ::libc::c_int,
    pub memoryPoolsSupported: ::libc::c_int,
    pub gpuDirectRDMASupported: ::libc::c_int,
    pub gpuDirectRDMAFlushWritesOptions: ::libc::c_uint,
    pub gpuDirectRDMAWritesOrdering: ::libc::c_int,
    pub memoryPoolSupportedHandleTypes: ::libc::c_uint,
    pub deferredMappingCudaArraySupported: ::libc::c_int,
    pub ipcEventSupported: ::libc::c_int,
    pub clusterLaunch: ::libc::c_int,
    pub unifiedFunctionPointers: ::libc::c_int,
    pub reserved: [::libc::c_int; 63usize],
}
#[test]
fn bindgen_test_layout_cudaDeviceProp() {
    assert_eq!(
        ::std::mem::size_of::<cudaDeviceProp>(),
        1032usize,
        concat!("Size of: ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaDeviceProp>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaDeviceProp))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(uuid)
            )
        );
    }
    test_field_uuid();
    fn test_field_luid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).luid) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(luid)
            )
        );
    }
    test_field_luid();
    fn test_field_luidDeviceNodeMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).luidDeviceNodeMask) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(luidDeviceNodeMask)
            )
        );
    }
    test_field_luidDeviceNodeMask();
    fn test_field_totalGlobalMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalGlobalMem) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(totalGlobalMem)
            )
        );
    }
    test_field_totalGlobalMem();
    fn test_field_sharedMemPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerBlock) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerBlock)
            )
        );
    }
    test_field_sharedMemPerBlock();
    fn test_field_regsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regsPerBlock) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(regsPerBlock)
            )
        );
    }
    test_field_regsPerBlock();
    fn test_field_warpSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).warpSize) as usize - ptr as usize
            },
            308usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(warpSize)
            )
        );
    }
    test_field_warpSize();
    fn test_field_memPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memPitch) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memPitch)
            )
        );
    }
    test_field_memPitch();
    fn test_field_maxThreadsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsPerBlock)
            )
        );
    }
    test_field_maxThreadsPerBlock();
    fn test_field_maxThreadsDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsDim) as usize - ptr as usize
            },
            324usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsDim)
            )
        );
    }
    test_field_maxThreadsDim();
    fn test_field_maxGridSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGridSize) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxGridSize)
            )
        );
    }
    test_field_maxGridSize();
    fn test_field_clockRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clockRate) as usize - ptr as usize
            },
            348usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(clockRate)
            )
        );
    }
    test_field_clockRate();
    fn test_field_totalConstMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalConstMem) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(totalConstMem)
            )
        );
    }
    test_field_totalConstMem();
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            364usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_textureAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureAlignment) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(textureAlignment)
            )
        );
    }
    test_field_textureAlignment();
    fn test_field_texturePitchAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).texturePitchAlignment) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(texturePitchAlignment)
            )
        );
    }
    test_field_texturePitchAlignment();
    fn test_field_deviceOverlap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceOverlap) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(deviceOverlap)
            )
        );
    }
    test_field_deviceOverlap();
    fn test_field_multiProcessorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiProcessorCount) as usize - ptr as usize
            },
            388usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(multiProcessorCount)
            )
        );
    }
    test_field_multiProcessorCount();
    fn test_field_kernelExecTimeoutEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernelExecTimeoutEnabled) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(kernelExecTimeoutEnabled)
            )
        );
    }
    test_field_kernelExecTimeoutEnabled();
    fn test_field_integrated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integrated) as usize - ptr as usize
            },
            396usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(integrated)
            )
        );
    }
    test_field_integrated();
    fn test_field_canMapHostMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canMapHostMemory) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(canMapHostMemory)
            )
        );
    }
    test_field_canMapHostMemory();
    fn test_field_computeMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeMode) as usize - ptr as usize
            },
            404usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(computeMode)
            )
        );
    }
    test_field_computeMode();
    fn test_field_maxTexture1D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1D) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1D)
            )
        );
    }
    test_field_maxTexture1D();
    fn test_field_maxTexture1DMipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DMipmap) as usize - ptr as usize
            },
            412usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DMipmap)
            )
        );
    }
    test_field_maxTexture1DMipmap();
    fn test_field_maxTexture1DLinear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DLinear) as usize - ptr as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DLinear)
            )
        );
    }
    test_field_maxTexture1DLinear();
    fn test_field_maxTexture2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2D) as usize - ptr as usize
            },
            420usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2D)
            )
        );
    }
    test_field_maxTexture2D();
    fn test_field_maxTexture2DMipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DMipmap) as usize - ptr as usize
            },
            428usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DMipmap)
            )
        );
    }
    test_field_maxTexture2DMipmap();
    fn test_field_maxTexture2DLinear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DLinear) as usize - ptr as usize
            },
            436usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DLinear)
            )
        );
    }
    test_field_maxTexture2DLinear();
    fn test_field_maxTexture2DGather() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DGather) as usize - ptr as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DGather)
            )
        );
    }
    test_field_maxTexture2DGather();
    fn test_field_maxTexture3D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture3D) as usize - ptr as usize
            },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture3D)
            )
        );
    }
    test_field_maxTexture3D();
    fn test_field_maxTexture3DAlt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture3DAlt) as usize - ptr as usize
            },
            468usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture3DAlt)
            )
        );
    }
    test_field_maxTexture3DAlt();
    fn test_field_maxTextureCubemap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTextureCubemap) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTextureCubemap)
            )
        );
    }
    test_field_maxTextureCubemap();
    fn test_field_maxTexture1DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DLayered) as usize - ptr as usize
            },
            484usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DLayered)
            )
        );
    }
    test_field_maxTexture1DLayered();
    fn test_field_maxTexture2DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DLayered) as usize - ptr as usize
            },
            492usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DLayered)
            )
        );
    }
    test_field_maxTexture2DLayered();
    fn test_field_maxTextureCubemapLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTextureCubemapLayered) as usize - ptr as usize
            },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTextureCubemapLayered)
            )
        );
    }
    test_field_maxTextureCubemapLayered();
    fn test_field_maxSurface1D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface1D) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface1D)
            )
        );
    }
    test_field_maxSurface1D();
    fn test_field_maxSurface2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface2D) as usize - ptr as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface2D)
            )
        );
    }
    test_field_maxSurface2D();
    fn test_field_maxSurface3D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface3D) as usize - ptr as usize
            },
            524usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface3D)
            )
        );
    }
    test_field_maxSurface3D();
    fn test_field_maxSurface1DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface1DLayered) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface1DLayered)
            )
        );
    }
    test_field_maxSurface1DLayered();
    fn test_field_maxSurface2DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface2DLayered) as usize - ptr as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface2DLayered)
            )
        );
    }
    test_field_maxSurface2DLayered();
    fn test_field_maxSurfaceCubemap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurfaceCubemap) as usize - ptr as usize
            },
            556usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurfaceCubemap)
            )
        );
    }
    test_field_maxSurfaceCubemap();
    fn test_field_maxSurfaceCubemapLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurfaceCubemapLayered) as usize - ptr as usize
            },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurfaceCubemapLayered)
            )
        );
    }
    test_field_maxSurfaceCubemapLayered();
    fn test_field_surfaceAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surfaceAlignment) as usize - ptr as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(surfaceAlignment)
            )
        );
    }
    test_field_surfaceAlignment();
    fn test_field_concurrentKernels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).concurrentKernels) as usize - ptr as usize
            },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(concurrentKernels)
            )
        );
    }
    test_field_concurrentKernels();
    fn test_field_ECCEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ECCEnabled) as usize - ptr as usize
            },
            580usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(ECCEnabled)
            )
        );
    }
    test_field_ECCEnabled();
    fn test_field_pciBusID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciBusID) as usize - ptr as usize
            },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciBusID)
            )
        );
    }
    test_field_pciBusID();
    fn test_field_pciDeviceID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDeviceID) as usize - ptr as usize
            },
            588usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciDeviceID)
            )
        );
    }
    test_field_pciDeviceID();
    fn test_field_pciDomainID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDomainID) as usize - ptr as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciDomainID)
            )
        );
    }
    test_field_pciDomainID();
    fn test_field_tccDriver() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tccDriver) as usize - ptr as usize
            },
            596usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(tccDriver)
            )
        );
    }
    test_field_tccDriver();
    fn test_field_asyncEngineCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).asyncEngineCount) as usize - ptr as usize
            },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(asyncEngineCount)
            )
        );
    }
    test_field_asyncEngineCount();
    fn test_field_unifiedAddressing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unifiedAddressing) as usize - ptr as usize
            },
            604usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(unifiedAddressing)
            )
        );
    }
    test_field_unifiedAddressing();
    fn test_field_memoryClockRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryClockRate) as usize - ptr as usize
            },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memoryClockRate)
            )
        );
    }
    test_field_memoryClockRate();
    fn test_field_memoryBusWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryBusWidth) as usize - ptr as usize
            },
            612usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memoryBusWidth)
            )
        );
    }
    test_field_memoryBusWidth();
    fn test_field_l2CacheSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2CacheSize) as usize - ptr as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(l2CacheSize)
            )
        );
    }
    test_field_l2CacheSize();
    fn test_field_persistingL2CacheMaxSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persistingL2CacheMaxSize) as usize - ptr as usize
            },
            620usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(persistingL2CacheMaxSize)
            )
        );
    }
    test_field_persistingL2CacheMaxSize();
    fn test_field_maxThreadsPerMultiProcessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerMultiProcessor) as usize - ptr as usize
            },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsPerMultiProcessor)
            )
        );
    }
    test_field_maxThreadsPerMultiProcessor();
    fn test_field_streamPrioritiesSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).streamPrioritiesSupported) as usize - ptr as usize
            },
            628usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(streamPrioritiesSupported)
            )
        );
    }
    test_field_streamPrioritiesSupported();
    fn test_field_globalL1CacheSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globalL1CacheSupported) as usize - ptr as usize
            },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(globalL1CacheSupported)
            )
        );
    }
    test_field_globalL1CacheSupported();
    fn test_field_localL1CacheSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localL1CacheSupported) as usize - ptr as usize
            },
            636usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(localL1CacheSupported)
            )
        );
    }
    test_field_localL1CacheSupported();
    fn test_field_sharedMemPerMultiprocessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerMultiprocessor) as usize - ptr as usize
            },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerMultiprocessor)
            )
        );
    }
    test_field_sharedMemPerMultiprocessor();
    fn test_field_regsPerMultiprocessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regsPerMultiprocessor) as usize - ptr as usize
            },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(regsPerMultiprocessor)
            )
        );
    }
    test_field_regsPerMultiprocessor();
    fn test_field_managedMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).managedMemory) as usize - ptr as usize
            },
            652usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(managedMemory)
            )
        );
    }
    test_field_managedMemory();
    fn test_field_isMultiGpuBoard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isMultiGpuBoard) as usize - ptr as usize
            },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(isMultiGpuBoard)
            )
        );
    }
    test_field_isMultiGpuBoard();
    fn test_field_multiGpuBoardGroupID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiGpuBoardGroupID) as usize - ptr as usize
            },
            660usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(multiGpuBoardGroupID)
            )
        );
    }
    test_field_multiGpuBoardGroupID();
    fn test_field_hostNativeAtomicSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostNativeAtomicSupported) as usize - ptr as usize
            },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(hostNativeAtomicSupported)
            )
        );
    }
    test_field_hostNativeAtomicSupported();
    fn test_field_singleToDoublePrecisionPerfRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleToDoublePrecisionPerfRatio) as usize
                    - ptr as usize
            },
            668usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(singleToDoublePrecisionPerfRatio)
            )
        );
    }
    test_field_singleToDoublePrecisionPerfRatio();
    fn test_field_pageableMemoryAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pageableMemoryAccess) as usize - ptr as usize
            },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pageableMemoryAccess)
            )
        );
    }
    test_field_pageableMemoryAccess();
    fn test_field_concurrentManagedAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).concurrentManagedAccess) as usize - ptr as usize
            },
            676usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(concurrentManagedAccess)
            )
        );
    }
    test_field_concurrentManagedAccess();
    fn test_field_computePreemptionSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computePreemptionSupported) as usize - ptr as usize
            },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(computePreemptionSupported)
            )
        );
    }
    test_field_computePreemptionSupported();
    fn test_field_canUseHostPointerForRegisteredMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canUseHostPointerForRegisteredMem) as usize
                    - ptr as usize
            },
            684usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(canUseHostPointerForRegisteredMem)
            )
        );
    }
    test_field_canUseHostPointerForRegisteredMem();
    fn test_field_cooperativeLaunch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeLaunch) as usize - ptr as usize
            },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(cooperativeLaunch)
            )
        );
    }
    test_field_cooperativeLaunch();
    fn test_field_cooperativeMultiDeviceLaunch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceLaunch) as usize - ptr as usize
            },
            692usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(cooperativeMultiDeviceLaunch)
            )
        );
    }
    test_field_cooperativeMultiDeviceLaunch();
    fn test_field_sharedMemPerBlockOptin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerBlockOptin) as usize - ptr as usize
            },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerBlockOptin)
            )
        );
    }
    test_field_sharedMemPerBlockOptin();
    fn test_field_pageableMemoryAccessUsesHostPageTables() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pageableMemoryAccessUsesHostPageTables) as usize
                    - ptr as usize
            },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pageableMemoryAccessUsesHostPageTables)
            )
        );
    }
    test_field_pageableMemoryAccessUsesHostPageTables();
    fn test_field_directManagedMemAccessFromHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directManagedMemAccessFromHost) as usize - ptr as usize
            },
            708usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(directManagedMemAccessFromHost)
            )
        );
    }
    test_field_directManagedMemAccessFromHost();
    fn test_field_maxBlocksPerMultiProcessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxBlocksPerMultiProcessor) as usize - ptr as usize
            },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxBlocksPerMultiProcessor)
            )
        );
    }
    test_field_maxBlocksPerMultiProcessor();
    fn test_field_accessPolicyMaxWindowSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyMaxWindowSize) as usize - ptr as usize
            },
            716usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(accessPolicyMaxWindowSize)
            )
        );
    }
    test_field_accessPolicyMaxWindowSize();
    fn test_field_reservedSharedMemPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedSharedMemPerBlock) as usize - ptr as usize
            },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(reservedSharedMemPerBlock)
            )
        );
    }
    test_field_reservedSharedMemPerBlock();
    fn test_field_hostRegisterSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostRegisterSupported) as usize - ptr as usize
            },
            728usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(hostRegisterSupported)
            )
        );
    }
    test_field_hostRegisterSupported();
    fn test_field_sparseCudaArraySupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseCudaArraySupported) as usize - ptr as usize
            },
            732usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sparseCudaArraySupported)
            )
        );
    }
    test_field_sparseCudaArraySupported();
    fn test_field_hostRegisterReadOnlySupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostRegisterReadOnlySupported) as usize - ptr as usize
            },
            736usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(hostRegisterReadOnlySupported)
            )
        );
    }
    test_field_hostRegisterReadOnlySupported();
    fn test_field_timelineSemaphoreInteropSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timelineSemaphoreInteropSupported) as usize
                    - ptr as usize
            },
            740usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(timelineSemaphoreInteropSupported)
            )
        );
    }
    test_field_timelineSemaphoreInteropSupported();
    fn test_field_memoryPoolsSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryPoolsSupported) as usize - ptr as usize
            },
            744usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memoryPoolsSupported)
            )
        );
    }
    test_field_memoryPoolsSupported();
    fn test_field_gpuDirectRDMASupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuDirectRDMASupported) as usize - ptr as usize
            },
            748usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(gpuDirectRDMASupported)
            )
        );
    }
    test_field_gpuDirectRDMASupported();
    fn test_field_gpuDirectRDMAFlushWritesOptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuDirectRDMAFlushWritesOptions) as usize - ptr as usize
            },
            752usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(gpuDirectRDMAFlushWritesOptions)
            )
        );
    }
    test_field_gpuDirectRDMAFlushWritesOptions();
    fn test_field_gpuDirectRDMAWritesOrdering() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuDirectRDMAWritesOrdering) as usize - ptr as usize
            },
            756usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(gpuDirectRDMAWritesOrdering)
            )
        );
    }
    test_field_gpuDirectRDMAWritesOrdering();
    fn test_field_memoryPoolSupportedHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryPoolSupportedHandleTypes) as usize - ptr as usize
            },
            760usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memoryPoolSupportedHandleTypes)
            )
        );
    }
    test_field_memoryPoolSupportedHandleTypes();
    fn test_field_deferredMappingCudaArraySupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deferredMappingCudaArraySupported) as usize
                    - ptr as usize
            },
            764usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(deferredMappingCudaArraySupported)
            )
        );
    }
    test_field_deferredMappingCudaArraySupported();
    fn test_field_ipcEventSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipcEventSupported) as usize - ptr as usize
            },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(ipcEventSupported)
            )
        );
    }
    test_field_ipcEventSupported();
    fn test_field_clusterLaunch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clusterLaunch) as usize - ptr as usize
            },
            772usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(clusterLaunch)
            )
        );
    }
    test_field_clusterLaunch();
    fn test_field_unifiedFunctionPointers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unifiedFunctionPointers) as usize - ptr as usize
            },
            776usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(unifiedFunctionPointers)
            )
        );
    }
    test_field_unifiedFunctionPointers();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            780usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaIpcEventHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcEventHandle_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaIpcEventHandle_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaIpcEventHandle_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudaIpcEventHandle_t = cudaIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaIpcMemHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcMemHandle_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaIpcMemHandle_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaIpcMemHandle_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudaIpcMemHandle_t = cudaIpcMemHandle_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaExternalMemoryHandleType {
    cudaExternalMemoryHandleTypeOpaqueFd = 1,
    cudaExternalMemoryHandleTypeOpaqueWin32 = 2,
    cudaExternalMemoryHandleTypeOpaqueWin32Kmt = 3,
    cudaExternalMemoryHandleTypeD3D12Heap = 4,
    cudaExternalMemoryHandleTypeD3D12Resource = 5,
    cudaExternalMemoryHandleTypeD3D11Resource = 6,
    cudaExternalMemoryHandleTypeD3D11ResourceKmt = 7,
    cudaExternalMemoryHandleTypeNvSciBuf = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc {
    pub type_: cudaExternalMemoryHandleType,
    pub handle: cudaExternalMemoryHandleDesc__bindgen_ty_1,
    pub size: ::libc::c_ulonglong,
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalMemoryHandleDesc__bindgen_ty_1 {
    pub fd: ::libc::c_int,
    pub win32: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::libc::c_void,
    pub name: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_win32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(win32)
            )
        );
    }
    test_field_win32();
    fn test_field_nvSciBufObject() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciBufObject) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(nvSciBufObject)
            )
        );
    }
    test_field_nvSciBufObject();
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryHandleDesc))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryBufferDesc {
    pub offset: ::libc::c_ulonglong,
    pub size: ::libc::c_ulonglong,
    pub flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryBufferDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryBufferDesc>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryBufferDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryBufferDesc))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryMipmappedArrayDesc {
    pub offset: ::libc::c_ulonglong,
    pub formatDesc: cudaChannelFormatDesc,
    pub extent: cudaExtent,
    pub flags: ::libc::c_uint,
    pub numLevels: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryMipmappedArrayDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_formatDesc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).formatDesc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(formatDesc)
            )
        );
    }
    test_field_formatDesc();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_numLevels() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numLevels) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(numLevels)
            )
        );
    }
    test_field_numLevels();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaExternalSemaphoreHandleType {
    cudaExternalSemaphoreHandleTypeOpaqueFd = 1,
    cudaExternalSemaphoreHandleTypeOpaqueWin32 = 2,
    cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,
    cudaExternalSemaphoreHandleTypeD3D12Fence = 4,
    cudaExternalSemaphoreHandleTypeD3D11Fence = 5,
    cudaExternalSemaphoreHandleTypeNvSciSync = 6,
    cudaExternalSemaphoreHandleTypeKeyedMutex = 7,
    cudaExternalSemaphoreHandleTypeKeyedMutexKmt = 8,
    cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd = 9,
    cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = 10,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc {
    pub type_: cudaExternalSemaphoreHandleType,
    pub handle: cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
    pub fd: ::libc::c_int,
    pub win32: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSyncObj: *const ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::libc::c_void,
    pub name: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_win32() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(win32)
            )
        );
    }
    test_field_win32();
    fn test_field_nvSciSyncObj() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSyncObj) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(nvSciSyncObj)
            )
        );
    }
    test_field_nvSciSyncObj();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc>(),
        32usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1 {
    pub params: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1 {
    pub params: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
    pub timeoutMs: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_timeoutMs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(timeoutMs)
            )
        );
    }
    test_field_timeoutMs();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams {
    pub params: cudaExternalSemaphoreSignalParams__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::libc::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreSignalParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams {
    pub params: cudaExternalSemaphoreWaitParams__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::libc::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
    pub timeoutMs: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_timeoutMs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(timeoutMs)
            )
        );
    }
    test_field_timeoutMs();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub use self::cudaError as cudaError_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type cudaStream_t = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type cudaEvent_t = *mut CUevent_st;
pub type cudaGraphicsResource_t = *mut cudaGraphicsResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalMemory_st {
    _unused: [u8; 0],
}
pub type cudaExternalMemory_t = *mut CUexternalMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalSemaphore_st {
    _unused: [u8; 0],
}
pub type cudaExternalSemaphore_t = *mut CUexternalSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type cudaGraph_t = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type cudaGraphNode_t = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
pub type cudaUserObject_t = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type cudaFunction_t = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
pub type cudaMemPool_t = *mut CUmemPoolHandle_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaCGScope {
    cudaCGScopeInvalid = 0,
    cudaCGScopeGrid = 1,
    cudaCGScopeMultiGrid = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchParams {
    pub func: *mut ::libc::c_void,
    pub gridDim: dim3,
    pub blockDim: dim3,
    pub args: *mut *mut ::libc::c_void,
    pub sharedMem: usize,
    pub stream: cudaStream_t,
}
#[test]
fn bindgen_test_layout_cudaLaunchParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchParams))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_gridDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(gridDim)
            )
        );
    }
    test_field_gridDim();
    fn test_field_blockDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(blockDim)
            )
        );
    }
    test_field_blockDim();
    fn test_field_args() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(args)
            )
        );
    }
    test_field_args();
    fn test_field_sharedMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMem) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(sharedMem)
            )
        );
    }
    test_field_sharedMem();
    fn test_field_stream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(stream)
            )
        );
    }
    test_field_stream();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaKernelNodeParams {
    pub func: *mut ::libc::c_void,
    pub gridDim: dim3,
    pub blockDim: dim3,
    pub sharedMemBytes: ::libc::c_uint,
    pub kernelParams: *mut *mut ::libc::c_void,
    pub extra: *mut *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeParams))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_gridDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(gridDim)
            )
        );
    }
    test_field_gridDim();
    fn test_field_blockDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(blockDim)
            )
        );
    }
    test_field_blockDim();
    fn test_field_sharedMemBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(sharedMemBytes)
            )
        );
    }
    test_field_sharedMemBytes();
    fn test_field_kernelParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(kernelParams)
            )
        );
    }
    test_field_kernelParams();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalNodeParams {
    pub extSemArray: *mut cudaExternalSemaphore_t,
    pub paramsArray: *const cudaExternalSemaphoreSignalParams,
    pub numExtSems: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalNodeParams>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    fn test_field_extSemArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(extSemArray)
            )
        );
    }
    test_field_extSemArray();
    fn test_field_paramsArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(paramsArray)
            )
        );
    }
    test_field_paramsArray();
    fn test_field_numExtSems() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(numExtSems)
            )
        );
    }
    test_field_numExtSems();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitNodeParams {
    pub extSemArray: *mut cudaExternalSemaphore_t,
    pub paramsArray: *const cudaExternalSemaphoreWaitParams,
    pub numExtSems: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitNodeParams>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitNodeParams)
        )
    );
    fn test_field_extSemArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(extSemArray)
            )
        );
    }
    test_field_extSemArray();
    fn test_field_paramsArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(paramsArray)
            )
        );
    }
    test_field_paramsArray();
    fn test_field_numExtSems() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(numExtSems)
            )
        );
    }
    test_field_numExtSems();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphNodeType {
    cudaGraphNodeTypeKernel = 0,
    cudaGraphNodeTypeMemcpy = 1,
    cudaGraphNodeTypeMemset = 2,
    cudaGraphNodeTypeHost = 3,
    cudaGraphNodeTypeGraph = 4,
    cudaGraphNodeTypeEmpty = 5,
    cudaGraphNodeTypeWaitEvent = 6,
    cudaGraphNodeTypeEventRecord = 7,
    cudaGraphNodeTypeExtSemaphoreSignal = 8,
    cudaGraphNodeTypeExtSemaphoreWait = 9,
    cudaGraphNodeTypeMemAlloc = 10,
    cudaGraphNodeTypeMemFree = 11,
    cudaGraphNodeTypeCount = 12,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type cudaGraphExec_t = *mut CUgraphExec_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphExecUpdateResult {
    cudaGraphExecUpdateSuccess = 0,
    cudaGraphExecUpdateError = 1,
    cudaGraphExecUpdateErrorTopologyChanged = 2,
    cudaGraphExecUpdateErrorNodeTypeChanged = 3,
    cudaGraphExecUpdateErrorFunctionChanged = 4,
    cudaGraphExecUpdateErrorParametersChanged = 5,
    cudaGraphExecUpdateErrorNotSupported = 6,
    cudaGraphExecUpdateErrorUnsupportedFunctionChange = 7,
    cudaGraphExecUpdateErrorAttributesChanged = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphInstantiateResult {
    cudaGraphInstantiateSuccess = 0,
    cudaGraphInstantiateError = 1,
    cudaGraphInstantiateInvalidStructure = 2,
    cudaGraphInstantiateNodeOperationNotSupported = 3,
    cudaGraphInstantiateMultipleDevicesNotSupported = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphInstantiateParams_st {
    pub flags: ::libc::c_ulonglong,
    pub uploadStream: cudaStream_t,
    pub errNode_out: cudaGraphNode_t,
    pub result_out: cudaGraphInstantiateResult,
}
#[test]
fn bindgen_test_layout_cudaGraphInstantiateParams_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaGraphInstantiateParams_st>(),
        32usize,
        concat!("Size of: ", stringify!(cudaGraphInstantiateParams_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaGraphInstantiateParams_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaGraphInstantiateParams_st))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaGraphInstantiateParams_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaGraphInstantiateParams_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_uploadStream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaGraphInstantiateParams_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uploadStream) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaGraphInstantiateParams_st),
                "::",
                stringify!(uploadStream)
            )
        );
    }
    test_field_uploadStream();
    fn test_field_errNode_out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaGraphInstantiateParams_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errNode_out) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaGraphInstantiateParams_st),
                "::",
                stringify!(errNode_out)
            )
        );
    }
    test_field_errNode_out();
    fn test_field_result_out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaGraphInstantiateParams_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result_out) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaGraphInstantiateParams_st),
                "::",
                stringify!(result_out)
            )
        );
    }
    test_field_result_out();
}
pub type cudaGraphInstantiateParams = cudaGraphInstantiateParams_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphExecUpdateResultInfo_st {
    pub result: cudaGraphExecUpdateResult,
    pub errorNode: cudaGraphNode_t,
    pub errorFromNode: cudaGraphNode_t,
}
#[test]
fn bindgen_test_layout_cudaGraphExecUpdateResultInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaGraphExecUpdateResultInfo_st>(),
        24usize,
        concat!("Size of: ", stringify!(cudaGraphExecUpdateResultInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaGraphExecUpdateResultInfo_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaGraphExecUpdateResultInfo_st)
        )
    );
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaGraphExecUpdateResultInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaGraphExecUpdateResultInfo_st),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_errorNode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaGraphExecUpdateResultInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errorNode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaGraphExecUpdateResultInfo_st),
                "::",
                stringify!(errorNode)
            )
        );
    }
    test_field_errorNode();
    fn test_field_errorFromNode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaGraphExecUpdateResultInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errorFromNode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaGraphExecUpdateResultInfo_st),
                "::",
                stringify!(errorFromNode)
            )
        );
    }
    test_field_errorFromNode();
}
pub type cudaGraphExecUpdateResultInfo = cudaGraphExecUpdateResultInfo_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGetDriverEntryPointFlags {
    cudaEnableDefault = 0,
    cudaEnableLegacyStream = 1,
    cudaEnablePerThreadDefaultStream = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaDriverEntryPointQueryResult {
    cudaDriverEntryPointSuccess = 0,
    cudaDriverEntryPointSymbolNotFound = 1,
    cudaDriverEntryPointVersionNotSufficent = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphDebugDotFlags {
    cudaGraphDebugDotFlagsVerbose = 1,
    cudaGraphDebugDotFlagsKernelNodeParams = 4,
    cudaGraphDebugDotFlagsMemcpyNodeParams = 8,
    cudaGraphDebugDotFlagsMemsetNodeParams = 16,
    cudaGraphDebugDotFlagsHostNodeParams = 32,
    cudaGraphDebugDotFlagsEventNodeParams = 64,
    cudaGraphDebugDotFlagsExtSemasSignalNodeParams = 128,
    cudaGraphDebugDotFlagsExtSemasWaitNodeParams = 256,
    cudaGraphDebugDotFlagsKernelNodeAttributes = 512,
    cudaGraphDebugDotFlagsHandles = 1024,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphInstantiateFlags {
    cudaGraphInstantiateFlagAutoFreeOnLaunch = 1,
    cudaGraphInstantiateFlagUpload = 2,
    cudaGraphInstantiateFlagDeviceLaunch = 4,
    cudaGraphInstantiateFlagUseNodePriority = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaLaunchMemSyncDomain {
    cudaLaunchMemSyncDomainDefault = 0,
    cudaLaunchMemSyncDomainRemote = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchMemSyncDomainMap_st {
    pub default_: ::libc::c_uchar,
    pub remote: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_cudaLaunchMemSyncDomainMap_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchMemSyncDomainMap_st>(),
        2usize,
        concat!("Size of: ", stringify!(cudaLaunchMemSyncDomainMap_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchMemSyncDomainMap_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaLaunchMemSyncDomainMap_st))
    );
    fn test_field_default_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchMemSyncDomainMap_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchMemSyncDomainMap_st),
                "::",
                stringify!(default_)
            )
        );
    }
    test_field_default_();
    fn test_field_remote() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchMemSyncDomainMap_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remote) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchMemSyncDomainMap_st),
                "::",
                stringify!(remote)
            )
        );
    }
    test_field_remote();
}
pub type cudaLaunchMemSyncDomainMap = cudaLaunchMemSyncDomainMap_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaLaunchAttributeID {
    cudaLaunchAttributeIgnore = 0,
    cudaLaunchAttributeAccessPolicyWindow = 1,
    cudaLaunchAttributeCooperative = 2,
    cudaLaunchAttributeSynchronizationPolicy = 3,
    cudaLaunchAttributeClusterDimension = 4,
    cudaLaunchAttributeClusterSchedulingPolicyPreference = 5,
    cudaLaunchAttributeProgrammaticStreamSerialization = 6,
    cudaLaunchAttributeProgrammaticEvent = 7,
    cudaLaunchAttributePriority = 8,
    cudaLaunchAttributeMemSyncDomainMap = 9,
    cudaLaunchAttributeMemSyncDomain = 10,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaLaunchAttributeValue {
    pub pad: [::libc::c_char; 64usize],
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub cooperative: ::libc::c_int,
    pub syncPolicy: cudaSynchronizationPolicy,
    pub clusterDim: cudaLaunchAttributeValue__bindgen_ty_1,
    pub clusterSchedulingPolicyPreference: cudaClusterSchedulingPolicy,
    pub programmaticStreamSerializationAllowed: ::libc::c_int,
    pub programmaticEvent: cudaLaunchAttributeValue__bindgen_ty_2,
    pub priority: ::libc::c_int,
    pub memSyncDomainMap: cudaLaunchMemSyncDomainMap,
    pub memSyncDomain: cudaLaunchMemSyncDomain,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchAttributeValue__bindgen_ty_1 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaLaunchAttributeValue__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchAttributeValue__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(cudaLaunchAttributeValue__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchAttributeValue__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cudaLaunchAttributeValue__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaLaunchAttributeValue__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaLaunchAttributeValue__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaLaunchAttributeValue__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue__bindgen_ty_1),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchAttributeValue__bindgen_ty_2 {
    pub event: cudaEvent_t,
    pub flags: ::libc::c_int,
    pub triggerAtBlockStart: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaLaunchAttributeValue__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchAttributeValue__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaLaunchAttributeValue__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchAttributeValue__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaLaunchAttributeValue__bindgen_ty_2)
        )
    );
    fn test_field_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaLaunchAttributeValue__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue__bindgen_ty_2),
                "::",
                stringify!(event)
            )
        );
    }
    test_field_event();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaLaunchAttributeValue__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue__bindgen_ty_2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_triggerAtBlockStart() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaLaunchAttributeValue__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).triggerAtBlockStart) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue__bindgen_ty_2),
                "::",
                stringify!(triggerAtBlockStart)
            )
        );
    }
    test_field_triggerAtBlockStart();
}
#[test]
fn bindgen_test_layout_cudaLaunchAttributeValue() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchAttributeValue>(),
        64usize,
        concat!("Size of: ", stringify!(cudaLaunchAttributeValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchAttributeValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchAttributeValue))
    );
    fn test_field_pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(pad)
            )
        );
    }
    test_field_pad();
    fn test_field_accessPolicyWindow() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(accessPolicyWindow)
            )
        );
    }
    test_field_accessPolicyWindow();
    fn test_field_cooperative() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperative) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(cooperative)
            )
        );
    }
    test_field_cooperative();
    fn test_field_syncPolicy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncPolicy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(syncPolicy)
            )
        );
    }
    test_field_syncPolicy();
    fn test_field_clusterDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clusterDim) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(clusterDim)
            )
        );
    }
    test_field_clusterDim();
    fn test_field_clusterSchedulingPolicyPreference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clusterSchedulingPolicyPreference) as usize
                    - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(clusterSchedulingPolicyPreference)
            )
        );
    }
    test_field_clusterSchedulingPolicyPreference();
    fn test_field_programmaticStreamSerializationAllowed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).programmaticStreamSerializationAllowed) as usize
                    - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(programmaticStreamSerializationAllowed)
            )
        );
    }
    test_field_programmaticStreamSerializationAllowed();
    fn test_field_programmaticEvent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).programmaticEvent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(programmaticEvent)
            )
        );
    }
    test_field_programmaticEvent();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
    fn test_field_memSyncDomainMap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memSyncDomainMap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(memSyncDomainMap)
            )
        );
    }
    test_field_memSyncDomainMap();
    fn test_field_memSyncDomain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttributeValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memSyncDomain) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttributeValue),
                "::",
                stringify!(memSyncDomain)
            )
        );
    }
    test_field_memSyncDomain();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaLaunchAttribute_st {
    pub id: cudaLaunchAttributeID,
    pub pad: [::libc::c_char; 4usize],
    pub val: cudaLaunchAttributeValue,
}
#[test]
fn bindgen_test_layout_cudaLaunchAttribute_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchAttribute_st>(),
        72usize,
        concat!("Size of: ", stringify!(cudaLaunchAttribute_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchAttribute_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchAttribute_st))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttribute_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttribute_st),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttribute_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttribute_st),
                "::",
                stringify!(pad)
            )
        );
    }
    test_field_pad();
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchAttribute_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchAttribute_st),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
pub type cudaLaunchAttribute = cudaLaunchAttribute_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchConfig_st {
    pub gridDim: dim3,
    pub blockDim: dim3,
    pub dynamicSmemBytes: usize,
    pub stream: cudaStream_t,
    pub attrs: *mut cudaLaunchAttribute,
    pub numAttrs: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaLaunchConfig_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchConfig_st>(),
        56usize,
        concat!("Size of: ", stringify!(cudaLaunchConfig_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchConfig_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchConfig_st))
    );
    fn test_field_gridDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchConfig_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchConfig_st),
                "::",
                stringify!(gridDim)
            )
        );
    }
    test_field_gridDim();
    fn test_field_blockDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchConfig_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchConfig_st),
                "::",
                stringify!(blockDim)
            )
        );
    }
    test_field_blockDim();
    fn test_field_dynamicSmemBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchConfig_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicSmemBytes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchConfig_st),
                "::",
                stringify!(dynamicSmemBytes)
            )
        );
    }
    test_field_dynamicSmemBytes();
    fn test_field_stream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchConfig_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchConfig_st),
                "::",
                stringify!(stream)
            )
        );
    }
    test_field_stream();
    fn test_field_attrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchConfig_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchConfig_st),
                "::",
                stringify!(attrs)
            )
        );
    }
    test_field_attrs();
    fn test_field_numAttrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchConfig_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numAttrs) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchConfig_st),
                "::",
                stringify!(numAttrs)
            )
        );
    }
    test_field_numAttrs();
}
pub type cudaLaunchConfig_t = cudaLaunchConfig_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaSurfaceBoundaryMode {
    cudaBoundaryModeZero = 0,
    cudaBoundaryModeClamp = 1,
    cudaBoundaryModeTrap = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaSurfaceFormatMode {
    cudaFormatModeForced = 0,
    cudaFormatModeAuto = 1,
}
pub type cudaSurfaceObject_t = ::libc::c_ulonglong;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaTextureAddressMode {
    cudaAddressModeWrap = 0,
    cudaAddressModeClamp = 1,
    cudaAddressModeMirror = 2,
    cudaAddressModeBorder = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaTextureFilterMode {
    cudaFilterModePoint = 0,
    cudaFilterModeLinear = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaTextureReadMode {
    cudaReadModeElementType = 0,
    cudaReadModeNormalizedFloat = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaTextureDesc {
    pub addressMode: [cudaTextureAddressMode; 3usize],
    pub filterMode: cudaTextureFilterMode,
    pub readMode: cudaTextureReadMode,
    pub sRGB: ::libc::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: cudaTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub disableTrilinearOptimization: ::libc::c_int,
    pub seamlessCubemap: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaTextureDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaTextureDesc>(),
        72usize,
        concat!("Size of: ", stringify!(cudaTextureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaTextureDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaTextureDesc))
    );
    fn test_field_addressMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(addressMode)
            )
        );
    }
    test_field_addressMode();
    fn test_field_filterMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(filterMode)
            )
        );
    }
    test_field_filterMode();
    fn test_field_readMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(readMode)
            )
        );
    }
    test_field_readMode();
    fn test_field_sRGB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sRGB) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(sRGB)
            )
        );
    }
    test_field_sRGB();
    fn test_field_borderColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).borderColor) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(borderColor)
            )
        );
    }
    test_field_borderColor();
    fn test_field_normalizedCoords() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).normalizedCoords) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(normalizedCoords)
            )
        );
    }
    test_field_normalizedCoords();
    fn test_field_maxAnisotropy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(maxAnisotropy)
            )
        );
    }
    test_field_maxAnisotropy();
    fn test_field_mipmapFilterMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(mipmapFilterMode)
            )
        );
    }
    test_field_mipmapFilterMode();
    fn test_field_mipmapLevelBias() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(mipmapLevelBias)
            )
        );
    }
    test_field_mipmapLevelBias();
    fn test_field_minMipmapLevelClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(minMipmapLevelClamp)
            )
        );
    }
    test_field_minMipmapLevelClamp();
    fn test_field_maxMipmapLevelClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(maxMipmapLevelClamp)
            )
        );
    }
    test_field_maxMipmapLevelClamp();
    fn test_field_disableTrilinearOptimization() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disableTrilinearOptimization) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(disableTrilinearOptimization)
            )
        );
    }
    test_field_disableTrilinearOptimization();
    fn test_field_seamlessCubemap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seamlessCubemap) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(seamlessCubemap)
            )
        );
    }
    test_field_seamlessCubemap();
}
pub type cudaTextureObject_t = ::libc::c_ulonglong;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaDataType_t {
    CUDA_R_16F = 2,
    CUDA_C_16F = 6,
    CUDA_R_16BF = 14,
    CUDA_C_16BF = 15,
    CUDA_R_32F = 0,
    CUDA_C_32F = 4,
    CUDA_R_64F = 1,
    CUDA_C_64F = 5,
    CUDA_R_4I = 16,
    CUDA_C_4I = 17,
    CUDA_R_4U = 18,
    CUDA_C_4U = 19,
    CUDA_R_8I = 3,
    CUDA_C_8I = 7,
    CUDA_R_8U = 8,
    CUDA_C_8U = 9,
    CUDA_R_16I = 20,
    CUDA_C_16I = 21,
    CUDA_R_16U = 22,
    CUDA_C_16U = 23,
    CUDA_R_32I = 10,
    CUDA_C_32I = 11,
    CUDA_R_32U = 12,
    CUDA_C_32U = 13,
    CUDA_R_64I = 24,
    CUDA_C_64I = 25,
    CUDA_R_64U = 26,
    CUDA_C_64U = 27,
    CUDA_R_8F_E4M3 = 28,
    CUDA_R_8F_E5M2 = 29,
}
pub use self::cudaDataType_t as cudaDataType;
pub const libraryPropertyType_t_MAJOR_VERSION: libraryPropertyType_t = 0;
pub const libraryPropertyType_t_MINOR_VERSION: libraryPropertyType_t = 1;
pub const libraryPropertyType_t_PATCH_LEVEL: libraryPropertyType_t = 2;
pub type libraryPropertyType_t = ::libc::c_uint;
pub use self::libraryPropertyType_t as libraryPropertyType;
extern "C" {
    pub fn cudaDeviceReset() -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSynchronize() -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetLimit(limit: cudaLimit, value: usize) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetLimit(pValue: *mut usize, limit: cudaLimit) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetTexture1DLinearMaxWidth(
        maxWidthInElements: *mut usize,
        fmtDesc: *const cudaChannelFormatDesc,
        device: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetCacheConfig(pCacheConfig: *mut cudaFuncCache) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetStreamPriorityRange(
        leastPriority: *mut ::libc::c_int,
        greatestPriority: *mut ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetCacheConfig(cacheConfig: cudaFuncCache) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetSharedMemConfig(pConfig: *mut cudaSharedMemConfig) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetSharedMemConfig(config: cudaSharedMemConfig) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetByPCIBusId(
        device: *mut ::libc::c_int,
        pciBusId: *const ::libc::c_char,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetPCIBusId(
        pciBusId: *mut ::libc::c_char,
        len: ::libc::c_int,
        device: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcGetEventHandle(
        handle: *mut cudaIpcEventHandle_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcOpenEventHandle(
        event: *mut cudaEvent_t,
        handle: cudaIpcEventHandle_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcGetMemHandle(
        handle: *mut cudaIpcMemHandle_t,
        devPtr: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcOpenMemHandle(
        devPtr: *mut *mut ::libc::c_void,
        handle: cudaIpcMemHandle_t,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcCloseMemHandle(devPtr: *mut ::libc::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceFlushGPUDirectRDMAWrites(
        target: cudaFlushGPUDirectRDMAWritesTarget,
        scope: cudaFlushGPUDirectRDMAWritesScope,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadExit() -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadSynchronize() -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadSetLimit(limit: cudaLimit, value: usize) -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadGetLimit(pValue: *mut usize, limit: cudaLimit) -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadGetCacheConfig(pCacheConfig: *mut cudaFuncCache) -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadSetCacheConfig(cacheConfig: cudaFuncCache) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetLastError() -> cudaError_t;
}
extern "C" {
    pub fn cudaPeekAtLastError() -> cudaError_t;
}
extern "C" {
    pub fn cudaGetErrorName(error: cudaError_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn cudaGetErrorString(error: cudaError_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn cudaGetDeviceCount(count: *mut ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetDeviceProperties_v2(
        prop: *mut cudaDeviceProp,
        device: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetAttribute(
        value: *mut ::libc::c_int,
        attr: cudaDeviceAttr,
        device: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetDefaultMemPool(
        memPool: *mut cudaMemPool_t,
        device: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetMemPool(device: ::libc::c_int, memPool: cudaMemPool_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetMemPool(memPool: *mut cudaMemPool_t, device: ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetNvSciSyncAttributes(
        nvSciSyncAttrList: *mut ::libc::c_void,
        device: ::libc::c_int,
        flags: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetP2PAttribute(
        value: *mut ::libc::c_int,
        attr: cudaDeviceP2PAttr,
        srcDevice: ::libc::c_int,
        dstDevice: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaChooseDevice(device: *mut ::libc::c_int, prop: *const cudaDeviceProp)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaInitDevice(
        device: ::libc::c_int,
        deviceFlags: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetDevice(device: ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetDevice(device: *mut ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetValidDevices(device_arr: *mut ::libc::c_int, len: ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetDeviceFlags(flags: ::libc::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetDeviceFlags(flags: *mut ::libc::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamCreate(pStream: *mut cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamCreateWithFlags(
        pStream: *mut cudaStream_t,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamCreateWithPriority(
        pStream: *mut cudaStream_t,
        flags: ::libc::c_uint,
        priority: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetPriority(
        hStream: cudaStream_t,
        priority: *mut ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetFlags(hStream: cudaStream_t, flags: *mut ::libc::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetId(
        hStream: cudaStream_t,
        streamId: *mut ::libc::c_ulonglong,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaCtxResetPersistingL2Cache() -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamCopyAttributes(dst: cudaStream_t, src: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetAttribute(
        hStream: cudaStream_t,
        attr: cudaLaunchAttributeID,
        value_out: *mut cudaLaunchAttributeValue,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamSetAttribute(
        hStream: cudaStream_t,
        attr: cudaLaunchAttributeID,
        value: *const cudaLaunchAttributeValue,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamDestroy(stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamWaitEvent(
        stream: cudaStream_t,
        event: cudaEvent_t,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
pub type cudaStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(stream: cudaStream_t, status: cudaError_t, userData: *mut ::libc::c_void),
>;
extern "C" {
    pub fn cudaStreamAddCallback(
        stream: cudaStream_t,
        callback: cudaStreamCallback_t,
        userData: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamSynchronize(stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamQuery(stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamAttachMemAsync(
        stream: cudaStream_t,
        devPtr: *mut ::libc::c_void,
        length: usize,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamBeginCapture(stream: cudaStream_t, mode: cudaStreamCaptureMode)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadExchangeStreamCaptureMode(mode: *mut cudaStreamCaptureMode) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamEndCapture(stream: cudaStream_t, pGraph: *mut cudaGraph_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamIsCapturing(
        stream: cudaStream_t,
        pCaptureStatus: *mut cudaStreamCaptureStatus,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetCaptureInfo_v2(
        stream: cudaStream_t,
        captureStatus_out: *mut cudaStreamCaptureStatus,
        id_out: *mut ::libc::c_ulonglong,
        graph_out: *mut cudaGraph_t,
        dependencies_out: *mut *const cudaGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamUpdateCaptureDependencies(
        stream: cudaStream_t,
        dependencies: *mut cudaGraphNode_t,
        numDependencies: usize,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventCreate(event: *mut cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventCreateWithFlags(event: *mut cudaEvent_t, flags: ::libc::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventRecord(event: cudaEvent_t, stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventRecordWithFlags(
        event: cudaEvent_t,
        stream: cudaStream_t,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventQuery(event: cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventSynchronize(event: cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventDestroy(event: cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventElapsedTime(ms: *mut f32, start: cudaEvent_t, end: cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaImportExternalMemory(
        extMem_out: *mut cudaExternalMemory_t,
        memHandleDesc: *const cudaExternalMemoryHandleDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaExternalMemoryGetMappedBuffer(
        devPtr: *mut *mut ::libc::c_void,
        extMem: cudaExternalMemory_t,
        bufferDesc: *const cudaExternalMemoryBufferDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut cudaMipmappedArray_t,
        extMem: cudaExternalMemory_t,
        mipmapDesc: *const cudaExternalMemoryMipmappedArrayDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDestroyExternalMemory(extMem: cudaExternalMemory_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaImportExternalSemaphore(
        extSem_out: *mut cudaExternalSemaphore_t,
        semHandleDesc: *const cudaExternalSemaphoreHandleDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaSignalExternalSemaphoresAsync_v2(
        extSemArray: *const cudaExternalSemaphore_t,
        paramsArray: *const cudaExternalSemaphoreSignalParams,
        numExtSems: ::libc::c_uint,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaWaitExternalSemaphoresAsync_v2(
        extSemArray: *const cudaExternalSemaphore_t,
        paramsArray: *const cudaExternalSemaphoreWaitParams,
        numExtSems: ::libc::c_uint,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDestroyExternalSemaphore(extSem: cudaExternalSemaphore_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchKernel(
        func: *const ::libc::c_void,
        gridDim: dim3,
        blockDim: dim3,
        args: *mut *mut ::libc::c_void,
        sharedMem: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchKernelExC(
        config: *const cudaLaunchConfig_t,
        func: *const ::libc::c_void,
        args: *mut *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchCooperativeKernel(
        func: *const ::libc::c_void,
        gridDim: dim3,
        blockDim: dim3,
        args: *mut *mut ::libc::c_void,
        sharedMem: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut cudaLaunchParams,
        numDevices: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFuncSetCacheConfig(
        func: *const ::libc::c_void,
        cacheConfig: cudaFuncCache,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFuncSetSharedMemConfig(
        func: *const ::libc::c_void,
        config: cudaSharedMemConfig,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFuncGetAttributes(
        attr: *mut cudaFuncAttributes,
        func: *const ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFuncSetAttribute(
        func: *const ::libc::c_void,
        attr: cudaFuncAttribute,
        value: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetDoubleForDevice(d: *mut f64) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetDoubleForHost(d: *mut f64) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchHostFunc(
        stream: cudaStream_t,
        fn_: cudaHostFn_t,
        userData: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::libc::c_int,
        func: *const ::libc::c_void,
        blockSize: ::libc::c_int,
        dynamicSMemSize: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaOccupancyAvailableDynamicSMemPerBlock(
        dynamicSmemSize: *mut usize,
        func: *const ::libc::c_void,
        numBlocks: ::libc::c_int,
        blockSize: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::libc::c_int,
        func: *const ::libc::c_void,
        blockSize: ::libc::c_int,
        dynamicSMemSize: usize,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaOccupancyMaxPotentialClusterSize(
        clusterSize: *mut ::libc::c_int,
        func: *const ::libc::c_void,
        launchConfig: *const cudaLaunchConfig_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaOccupancyMaxActiveClusters(
        numClusters: *mut ::libc::c_int,
        func: *const ::libc::c_void,
        launchConfig: *const cudaLaunchConfig_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocManaged(
        devPtr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMalloc(devPtr: *mut *mut ::libc::c_void, size: usize) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocHost(ptr: *mut *mut ::libc::c_void, size: usize) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocPitch(
        devPtr: *mut *mut ::libc::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocArray(
        array: *mut cudaArray_t,
        desc: *const cudaChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFree(devPtr: *mut ::libc::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaFreeHost(ptr: *mut ::libc::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaFreeArray(array: cudaArray_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaFreeMipmappedArray(mipmappedArray: cudaMipmappedArray_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostAlloc(
        pHost: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostRegister(
        ptr: *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostUnregister(ptr: *mut ::libc::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostGetDevicePointer(
        pDevice: *mut *mut ::libc::c_void,
        pHost: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostGetFlags(pFlags: *mut ::libc::c_uint, pHost: *mut ::libc::c_void)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaMalloc3D(pitchedDevPtr: *mut cudaPitchedPtr, extent: cudaExtent) -> cudaError_t;
}
extern "C" {
    pub fn cudaMalloc3DArray(
        array: *mut cudaArray_t,
        desc: *const cudaChannelFormatDesc,
        extent: cudaExtent,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocMipmappedArray(
        mipmappedArray: *mut cudaMipmappedArray_t,
        desc: *const cudaChannelFormatDesc,
        extent: cudaExtent,
        numLevels: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetMipmappedArrayLevel(
        levelArray: *mut cudaArray_t,
        mipmappedArray: cudaMipmappedArray_const_t,
        level: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy3D(p: *const cudaMemcpy3DParms) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy3DPeer(p: *const cudaMemcpy3DPeerParms) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy3DAsync(p: *const cudaMemcpy3DParms, stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy3DPeerAsync(
        p: *const cudaMemcpy3DPeerParms,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemGetInfo(free: *mut usize, total: *mut usize) -> cudaError_t;
}
extern "C" {
    pub fn cudaArrayGetInfo(
        desc: *mut cudaChannelFormatDesc,
        extent: *mut cudaExtent,
        flags: *mut ::libc::c_uint,
        array: cudaArray_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaArrayGetPlane(
        pPlaneArray: *mut cudaArray_t,
        hArray: cudaArray_t,
        planeIdx: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaArrayGetMemoryRequirements(
        memoryRequirements: *mut cudaArrayMemoryRequirements,
        array: cudaArray_t,
        device: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMipmappedArrayGetMemoryRequirements(
        memoryRequirements: *mut cudaArrayMemoryRequirements,
        mipmap: cudaMipmappedArray_t,
        device: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaArrayGetSparseProperties(
        sparseProperties: *mut cudaArraySparseProperties,
        array: cudaArray_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMipmappedArrayGetSparseProperties(
        sparseProperties: *mut cudaArraySparseProperties,
        mipmap: cudaMipmappedArray_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyPeer(
        dst: *mut ::libc::c_void,
        dstDevice: ::libc::c_int,
        src: *const ::libc::c_void,
        srcDevice: ::libc::c_int,
        count: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2D(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DToArray(
        dst: cudaArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DFromArray(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: cudaArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DArrayToArray(
        dst: cudaArray_t,
        wOffsetDst: usize,
        hOffsetDst: usize,
        src: cudaArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyToSymbol(
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyFromSymbol(
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyAsync(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyPeerAsync(
        dst: *mut ::libc::c_void,
        dstDevice: ::libc::c_int,
        src: *const ::libc::c_void,
        srcDevice: ::libc::c_int,
        count: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DAsync(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DToArrayAsync(
        dst: cudaArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DFromArrayAsync(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: cudaArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyToSymbolAsync(
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyFromSymbolAsync(
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset(
        devPtr: *mut ::libc::c_void,
        value: ::libc::c_int,
        count: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset2D(
        devPtr: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset3D(
        pitchedDevPtr: cudaPitchedPtr,
        value: ::libc::c_int,
        extent: cudaExtent,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemsetAsync(
        devPtr: *mut ::libc::c_void,
        value: ::libc::c_int,
        count: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset2DAsync(
        devPtr: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset3DAsync(
        pitchedDevPtr: cudaPitchedPtr,
        value: ::libc::c_int,
        extent: cudaExtent,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetSymbolAddress(
        devPtr: *mut *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetSymbolSize(size: *mut usize, symbol: *const ::libc::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPrefetchAsync(
        devPtr: *const ::libc::c_void,
        count: usize,
        dstDevice: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemAdvise(
        devPtr: *const ::libc::c_void,
        count: usize,
        advice: cudaMemoryAdvise,
        device: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemRangeGetAttribute(
        data: *mut ::libc::c_void,
        dataSize: usize,
        attribute: cudaMemRangeAttribute,
        devPtr: *const ::libc::c_void,
        count: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemRangeGetAttributes(
        data: *mut *mut ::libc::c_void,
        dataSizes: *mut usize,
        attributes: *mut cudaMemRangeAttribute,
        numAttributes: usize,
        devPtr: *const ::libc::c_void,
        count: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyToArray(
        dst: cudaArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyFromArray(
        dst: *mut ::libc::c_void,
        src: cudaArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyArrayToArray(
        dst: cudaArray_t,
        wOffsetDst: usize,
        hOffsetDst: usize,
        src: cudaArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyToArrayAsync(
        dst: cudaArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        count: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyFromArrayAsync(
        dst: *mut ::libc::c_void,
        src: cudaArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocAsync(
        devPtr: *mut *mut ::libc::c_void,
        size: usize,
        hStream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFreeAsync(devPtr: *mut ::libc::c_void, hStream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolTrimTo(memPool: cudaMemPool_t, minBytesToKeep: usize) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolSetAttribute(
        memPool: cudaMemPool_t,
        attr: cudaMemPoolAttr,
        value: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolGetAttribute(
        memPool: cudaMemPool_t,
        attr: cudaMemPoolAttr,
        value: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolSetAccess(
        memPool: cudaMemPool_t,
        descList: *const cudaMemAccessDesc,
        count: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolGetAccess(
        flags: *mut cudaMemAccessFlags,
        memPool: cudaMemPool_t,
        location: *mut cudaMemLocation,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolCreate(
        memPool: *mut cudaMemPool_t,
        poolProps: *const cudaMemPoolProps,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolDestroy(memPool: cudaMemPool_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocFromPoolAsync(
        ptr: *mut *mut ::libc::c_void,
        size: usize,
        memPool: cudaMemPool_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolExportToShareableHandle(
        shareableHandle: *mut ::libc::c_void,
        memPool: cudaMemPool_t,
        handleType: cudaMemAllocationHandleType,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolImportFromShareableHandle(
        memPool: *mut cudaMemPool_t,
        shareableHandle: *mut ::libc::c_void,
        handleType: cudaMemAllocationHandleType,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolExportPointer(
        exportData: *mut cudaMemPoolPtrExportData,
        ptr: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolImportPointer(
        ptr: *mut *mut ::libc::c_void,
        memPool: cudaMemPool_t,
        exportData: *mut cudaMemPoolPtrExportData,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaPointerGetAttributes(
        attributes: *mut cudaPointerAttributes,
        ptr: *const ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceCanAccessPeer(
        canAccessPeer: *mut ::libc::c_int,
        device: ::libc::c_int,
        peerDevice: ::libc::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceEnablePeerAccess(
        peerDevice: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceDisablePeerAccess(peerDevice: ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsUnregisterResource(resource: cudaGraphicsResource_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsResourceSetMapFlags(
        resource: cudaGraphicsResource_t,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsMapResources(
        count: ::libc::c_int,
        resources: *mut cudaGraphicsResource_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsUnmapResources(
        count: ::libc::c_int,
        resources: *mut cudaGraphicsResource_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsResourceGetMappedPointer(
        devPtr: *mut *mut ::libc::c_void,
        size: *mut usize,
        resource: cudaGraphicsResource_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsSubResourceGetMappedArray(
        array: *mut cudaArray_t,
        resource: cudaGraphicsResource_t,
        arrayIndex: ::libc::c_uint,
        mipLevel: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsResourceGetMappedMipmappedArray(
        mipmappedArray: *mut cudaMipmappedArray_t,
        resource: cudaGraphicsResource_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetChannelDesc(
        desc: *mut cudaChannelFormatDesc,
        array: cudaArray_const_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaCreateChannelDesc(
        x: ::libc::c_int,
        y: ::libc::c_int,
        z: ::libc::c_int,
        w: ::libc::c_int,
        f: cudaChannelFormatKind,
    ) -> cudaChannelFormatDesc;
}
extern "C" {
    pub fn cudaCreateTextureObject(
        pTexObject: *mut cudaTextureObject_t,
        pResDesc: *const cudaResourceDesc,
        pTexDesc: *const cudaTextureDesc,
        pResViewDesc: *const cudaResourceViewDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDestroyTextureObject(texObject: cudaTextureObject_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetTextureObjectResourceDesc(
        pResDesc: *mut cudaResourceDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetTextureObjectTextureDesc(
        pTexDesc: *mut cudaTextureDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetTextureObjectResourceViewDesc(
        pResViewDesc: *mut cudaResourceViewDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaCreateSurfaceObject(
        pSurfObject: *mut cudaSurfaceObject_t,
        pResDesc: *const cudaResourceDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDestroySurfaceObject(surfObject: cudaSurfaceObject_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetSurfaceObjectResourceDesc(
        pResDesc: *mut cudaResourceDesc,
        surfObject: cudaSurfaceObject_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDriverGetVersion(driverVersion: *mut ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaRuntimeGetVersion(runtimeVersion: *mut ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphCreate(pGraph: *mut cudaGraph_t, flags: ::libc::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddKernelNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaKernelNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeCopyAttributes(
        hSrc: cudaGraphNode_t,
        hDst: cudaGraphNode_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeGetAttribute(
        hNode: cudaGraphNode_t,
        attr: cudaLaunchAttributeID,
        value_out: *mut cudaLaunchAttributeValue,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeSetAttribute(
        hNode: cudaGraphNode_t,
        attr: cudaLaunchAttributeID,
        value: *const cudaLaunchAttributeValue,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemcpyNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        pCopyParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemcpyNodeToSymbol(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemcpyNodeFromSymbol(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemcpyNode1D(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaMemcpy3DParms,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeSetParamsToSymbol(
        node: cudaGraphNode_t,
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeSetParamsFromSymbol(
        node: cudaGraphNode_t,
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeSetParams1D(
        node: cudaGraphNode_t,
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemsetNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        pMemsetParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemsetNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaMemsetParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemsetNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddHostNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphHostNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaHostNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphHostNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddChildGraphNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        childGraph: cudaGraph_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphChildGraphNodeGetGraph(
        node: cudaGraphNode_t,
        pGraph: *mut cudaGraph_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddEmptyNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddEventRecordNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphEventRecordNodeGetEvent(
        node: cudaGraphNode_t,
        event_out: *mut cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphEventRecordNodeSetEvent(
        node: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddEventWaitNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphEventWaitNodeGetEvent(
        node: cudaGraphNode_t,
        event_out: *mut cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphEventWaitNodeSetEvent(node: cudaGraphNode_t, event: cudaEvent_t)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddExternalSemaphoresSignalNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExternalSemaphoresSignalNodeGetParams(
        hNode: cudaGraphNode_t,
        params_out: *mut cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExternalSemaphoresSignalNodeSetParams(
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddExternalSemaphoresWaitNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExternalSemaphoresWaitNodeGetParams(
        hNode: cudaGraphNode_t,
        params_out: *mut cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExternalSemaphoresWaitNodeSetParams(
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemAllocNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        nodeParams: *mut cudaMemAllocNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemAllocNodeGetParams(
        node: cudaGraphNode_t,
        params_out: *mut cudaMemAllocNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemFreeNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: usize,
        dptr: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemFreeNodeGetParams(
        node: cudaGraphNode_t,
        dptr_out: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGraphMemTrim(device: ::libc::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetGraphMemAttribute(
        device: ::libc::c_int,
        attr: cudaGraphMemAttributeType,
        value: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetGraphMemAttribute(
        device: ::libc::c_int,
        attr: cudaGraphMemAttributeType,
        value: *mut ::libc::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphClone(pGraphClone: *mut cudaGraph_t, originalGraph: cudaGraph_t)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeFindInClone(
        pNode: *mut cudaGraphNode_t,
        originalNode: cudaGraphNode_t,
        clonedGraph: cudaGraph_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeGetType(
        node: cudaGraphNode_t,
        pType: *mut cudaGraphNodeType,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphGetNodes(
        graph: cudaGraph_t,
        nodes: *mut cudaGraphNode_t,
        numNodes: *mut usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphGetRootNodes(
        graph: cudaGraph_t,
        pRootNodes: *mut cudaGraphNode_t,
        pNumRootNodes: *mut usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphGetEdges(
        graph: cudaGraph_t,
        from: *mut cudaGraphNode_t,
        to: *mut cudaGraphNode_t,
        numEdges: *mut usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeGetDependencies(
        node: cudaGraphNode_t,
        pDependencies: *mut cudaGraphNode_t,
        pNumDependencies: *mut usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeGetDependentNodes(
        node: cudaGraphNode_t,
        pDependentNodes: *mut cudaGraphNode_t,
        pNumDependentNodes: *mut usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddDependencies(
        graph: cudaGraph_t,
        from: *const cudaGraphNode_t,
        to: *const cudaGraphNode_t,
        numDependencies: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphRemoveDependencies(
        graph: cudaGraph_t,
        from: *const cudaGraphNode_t,
        to: *const cudaGraphNode_t,
        numDependencies: usize,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphDestroyNode(node: cudaGraphNode_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphInstantiate(
        pGraphExec: *mut cudaGraphExec_t,
        graph: cudaGraph_t,
        flags: ::libc::c_ulonglong,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphInstantiateWithFlags(
        pGraphExec: *mut cudaGraphExec_t,
        graph: cudaGraph_t,
        flags: ::libc::c_ulonglong,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphInstantiateWithParams(
        pGraphExec: *mut cudaGraphExec_t,
        graph: cudaGraph_t,
        instantiateParams: *mut cudaGraphInstantiateParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecGetFlags(
        graphExec: cudaGraphExec_t,
        flags: *mut ::libc::c_ulonglong,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecKernelNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParamsToSymbol(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParamsFromSymbol(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParams1D(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemsetNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecHostNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecChildGraphNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        childGraph: cudaGraph_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecEventRecordNodeSetEvent(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecEventWaitNodeSetEvent(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeSetEnabled(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        isEnabled: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeGetEnabled(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        isEnabled: *mut ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecUpdate(
        hGraphExec: cudaGraphExec_t,
        hGraph: cudaGraph_t,
        resultInfo: *mut cudaGraphExecUpdateResultInfo,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphUpload(graphExec: cudaGraphExec_t, stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphLaunch(graphExec: cudaGraphExec_t, stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecDestroy(graphExec: cudaGraphExec_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphDestroy(graph: cudaGraph_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphDebugDotPrint(
        graph: cudaGraph_t,
        path: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaUserObjectCreate(
        object_out: *mut cudaUserObject_t,
        ptr: *mut ::libc::c_void,
        destroy: cudaHostFn_t,
        initialRefcount: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaUserObjectRetain(object: cudaUserObject_t, count: ::libc::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaUserObjectRelease(object: cudaUserObject_t, count: ::libc::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphRetainUserObject(
        graph: cudaGraph_t,
        object: cudaUserObject_t,
        count: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphReleaseUserObject(
        graph: cudaGraph_t,
        object: cudaUserObject_t,
        count: ::libc::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetDriverEntryPoint(
        symbol: *const ::libc::c_char,
        funcPtr: *mut *mut ::libc::c_void,
        flags: ::libc::c_ulonglong,
        driverStatus: *mut cudaDriverEntryPointQueryResult,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetExportTable(
        ppExportTable: *mut *const ::libc::c_void,
        pExportTableId: *const cudaUUID_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetFuncBySymbol(
        functionPtr: *mut cudaFunction_t,
        symbolPtr: *const ::libc::c_void,
    ) -> cudaError_t;
}
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnContext {
    _unused: [u8; 0],
}
pub type cudnnHandle_t = *mut cudnnContext;
extern "C" {
    pub fn cudnnGetVersion() -> usize;
}
extern "C" {
    pub fn cudnnGetMaxDeviceVersion() -> usize;
}
extern "C" {
    pub fn cudnnGetCudartVersion() -> usize;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnStatus_t {
    CUDNN_STATUS_SUCCESS = 0,
    CUDNN_STATUS_NOT_INITIALIZED = 1,
    CUDNN_STATUS_ALLOC_FAILED = 2,
    CUDNN_STATUS_BAD_PARAM = 3,
    CUDNN_STATUS_INTERNAL_ERROR = 4,
    CUDNN_STATUS_INVALID_VALUE = 5,
    CUDNN_STATUS_ARCH_MISMATCH = 6,
    CUDNN_STATUS_MAPPING_ERROR = 7,
    CUDNN_STATUS_EXECUTION_FAILED = 8,
    CUDNN_STATUS_NOT_SUPPORTED = 9,
    CUDNN_STATUS_LICENSE_ERROR = 10,
    CUDNN_STATUS_RUNTIME_PREREQUISITE_MISSING = 11,
    CUDNN_STATUS_RUNTIME_IN_PROGRESS = 12,
    CUDNN_STATUS_RUNTIME_FP_OVERFLOW = 13,
    CUDNN_STATUS_VERSION_MISMATCH = 14,
}
extern "C" {
    pub fn cudnnGetErrorString(status: cudnnStatus_t) -> *const ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnRuntimeTag_t {
    _unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnErrQueryMode_t {
    CUDNN_ERRQUERY_RAWCODE = 0,
    CUDNN_ERRQUERY_NONBLOCKING = 1,
    CUDNN_ERRQUERY_BLOCKING = 2,
}
extern "C" {
    pub fn cudnnQueryRuntimeError(
        handle: cudnnHandle_t,
        rstatus: *mut cudnnStatus_t,
        mode: cudnnErrQueryMode_t,
        tag: *mut cudnnRuntimeTag_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetProperty(type_: libraryPropertyType, value: *mut ::libc::c_int)
        -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreate(handle: *mut cudnnHandle_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroy(handle: cudnnHandle_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetStream(handle: cudnnHandle_t, streamId: cudaStream_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetStream(handle: cudnnHandle_t, streamId: *mut cudaStream_t) -> cudnnStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnTensorStruct {
    _unused: [u8; 0],
}
pub type cudnnTensorDescriptor_t = *mut cudnnTensorStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnPoolingStruct {
    _unused: [u8; 0],
}
pub type cudnnPoolingDescriptor_t = *mut cudnnPoolingStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnFilterStruct {
    _unused: [u8; 0],
}
pub type cudnnFilterDescriptor_t = *mut cudnnFilterStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnLRNStruct {
    _unused: [u8; 0],
}
pub type cudnnLRNDescriptor_t = *mut cudnnLRNStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnActivationStruct {
    _unused: [u8; 0],
}
pub type cudnnActivationDescriptor_t = *mut cudnnActivationStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnSpatialTransformerStruct {
    _unused: [u8; 0],
}
pub type cudnnSpatialTransformerDescriptor_t = *mut cudnnSpatialTransformerStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnOpTensorStruct {
    _unused: [u8; 0],
}
pub type cudnnOpTensorDescriptor_t = *mut cudnnOpTensorStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnReduceTensorStruct {
    _unused: [u8; 0],
}
pub type cudnnReduceTensorDescriptor_t = *mut cudnnReduceTensorStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnCTCLossStruct {
    _unused: [u8; 0],
}
pub type cudnnCTCLossDescriptor_t = *mut cudnnCTCLossStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnTensorTransformStruct {
    _unused: [u8; 0],
}
pub type cudnnTensorTransformDescriptor_t = *mut cudnnTensorTransformStruct;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnDataType_t {
    CUDNN_DATA_FLOAT = 0,
    CUDNN_DATA_DOUBLE = 1,
    CUDNN_DATA_HALF = 2,
    CUDNN_DATA_INT8 = 3,
    CUDNN_DATA_INT32 = 4,
    CUDNN_DATA_INT8x4 = 5,
    CUDNN_DATA_UINT8 = 6,
    CUDNN_DATA_UINT8x4 = 7,
    CUDNN_DATA_INT8x32 = 8,
    CUDNN_DATA_BFLOAT16 = 9,
    CUDNN_DATA_INT64 = 10,
    CUDNN_DATA_BOOLEAN = 11,
    CUDNN_DATA_FP8_E4M3 = 12,
    CUDNN_DATA_FP8_E5M2 = 13,
    CUDNN_DATA_FAST_FLOAT_FOR_FP8 = 14,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnMathType_t {
    CUDNN_DEFAULT_MATH = 0,
    CUDNN_TENSOR_OP_MATH = 1,
    CUDNN_TENSOR_OP_MATH_ALLOW_CONVERSION = 2,
    CUDNN_FMA_MATH = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnNanPropagation_t {
    CUDNN_NOT_PROPAGATE_NAN = 0,
    CUDNN_PROPAGATE_NAN = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnDeterminism_t {
    CUDNN_NON_DETERMINISTIC = 0,
    CUDNN_DETERMINISTIC = 1,
}
extern "C" {
    pub fn cudnnCreateTensorDescriptor(tensorDesc: *mut cudnnTensorDescriptor_t) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnTensorFormat_t {
    CUDNN_TENSOR_NCHW = 0,
    CUDNN_TENSOR_NHWC = 1,
    CUDNN_TENSOR_NCHW_VECT_C = 2,
}
extern "C" {
    pub fn cudnnSetTensor4dDescriptor(
        tensorDesc: cudnnTensorDescriptor_t,
        format: cudnnTensorFormat_t,
        dataType: cudnnDataType_t,
        n: ::libc::c_int,
        c: ::libc::c_int,
        h: ::libc::c_int,
        w: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetTensor4dDescriptorEx(
        tensorDesc: cudnnTensorDescriptor_t,
        dataType: cudnnDataType_t,
        n: ::libc::c_int,
        c: ::libc::c_int,
        h: ::libc::c_int,
        w: ::libc::c_int,
        nStride: ::libc::c_int,
        cStride: ::libc::c_int,
        hStride: ::libc::c_int,
        wStride: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetTensor4dDescriptor(
        tensorDesc: cudnnTensorDescriptor_t,
        dataType: *mut cudnnDataType_t,
        n: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int,
        nStride: *mut ::libc::c_int,
        cStride: *mut ::libc::c_int,
        hStride: *mut ::libc::c_int,
        wStride: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetTensorNdDescriptor(
        tensorDesc: cudnnTensorDescriptor_t,
        dataType: cudnnDataType_t,
        nbDims: ::libc::c_int,
        dimA: *const ::libc::c_int,
        strideA: *const ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetTensorNdDescriptorEx(
        tensorDesc: cudnnTensorDescriptor_t,
        format: cudnnTensorFormat_t,
        dataType: cudnnDataType_t,
        nbDims: ::libc::c_int,
        dimA: *const ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetTensorNdDescriptor(
        tensorDesc: cudnnTensorDescriptor_t,
        nbDimsRequested: ::libc::c_int,
        dataType: *mut cudnnDataType_t,
        nbDims: *mut ::libc::c_int,
        dimA: *mut ::libc::c_int,
        strideA: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetTensorSizeInBytes(
        tensorDesc: cudnnTensorDescriptor_t,
        size: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyTensorDescriptor(tensorDesc: cudnnTensorDescriptor_t) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnFoldingDirection_t {
    CUDNN_TRANSFORM_FOLD = 0,
    CUDNN_TRANSFORM_UNFOLD = 1,
}
extern "C" {
    pub fn cudnnInitTransformDest(
        transformDesc: cudnnTensorTransformDescriptor_t,
        srcDesc: cudnnTensorDescriptor_t,
        destDesc: cudnnTensorDescriptor_t,
        destSizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreateTensorTransformDescriptor(
        transformDesc: *mut cudnnTensorTransformDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetTensorTransformDescriptor(
        transformDesc: cudnnTensorTransformDescriptor_t,
        nbDims: u32,
        destFormat: cudnnTensorFormat_t,
        padBeforeA: *const i32,
        padAfterA: *const i32,
        foldA: *const u32,
        direction: cudnnFoldingDirection_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetTensorTransformDescriptor(
        transformDesc: cudnnTensorTransformDescriptor_t,
        nbDimsRequested: u32,
        destFormat: *mut cudnnTensorFormat_t,
        padBeforeA: *mut i32,
        padAfterA: *mut i32,
        foldA: *mut u32,
        direction: *mut cudnnFoldingDirection_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyTensorTransformDescriptor(
        transformDesc: cudnnTensorTransformDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnTransformTensor(
        handle: cudnnHandle_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnTransformTensorEx(
        handle: cudnnHandle_t,
        transDesc: cudnnTensorTransformDescriptor_t,
        alpha: *const ::libc::c_void,
        srcDesc: cudnnTensorDescriptor_t,
        srcData: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        destDesc: cudnnTensorDescriptor_t,
        destData: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnAddTensor(
        handle: cudnnHandle_t,
        alpha: *const ::libc::c_void,
        aDesc: cudnnTensorDescriptor_t,
        A: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        cDesc: cudnnTensorDescriptor_t,
        C: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnOpTensorOp_t {
    CUDNN_OP_TENSOR_ADD = 0,
    CUDNN_OP_TENSOR_MUL = 1,
    CUDNN_OP_TENSOR_MIN = 2,
    CUDNN_OP_TENSOR_MAX = 3,
    CUDNN_OP_TENSOR_SQRT = 4,
    CUDNN_OP_TENSOR_NOT = 5,
}
extern "C" {
    pub fn cudnnCreateOpTensorDescriptor(
        opTensorDesc: *mut cudnnOpTensorDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetOpTensorDescriptor(
        opTensorDesc: cudnnOpTensorDescriptor_t,
        opTensorOp: cudnnOpTensorOp_t,
        opTensorCompType: cudnnDataType_t,
        opTensorNanOpt: cudnnNanPropagation_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetOpTensorDescriptor(
        opTensorDesc: cudnnOpTensorDescriptor_t,
        opTensorOp: *mut cudnnOpTensorOp_t,
        opTensorCompType: *mut cudnnDataType_t,
        opTensorNanOpt: *mut cudnnNanPropagation_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyOpTensorDescriptor(opTensorDesc: cudnnOpTensorDescriptor_t)
        -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnOpTensor(
        handle: cudnnHandle_t,
        opTensorDesc: cudnnOpTensorDescriptor_t,
        alpha1: *const ::libc::c_void,
        aDesc: cudnnTensorDescriptor_t,
        A: *const ::libc::c_void,
        alpha2: *const ::libc::c_void,
        bDesc: cudnnTensorDescriptor_t,
        B: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        cDesc: cudnnTensorDescriptor_t,
        C: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnReduceTensorOp_t {
    CUDNN_REDUCE_TENSOR_ADD = 0,
    CUDNN_REDUCE_TENSOR_MUL = 1,
    CUDNN_REDUCE_TENSOR_MIN = 2,
    CUDNN_REDUCE_TENSOR_MAX = 3,
    CUDNN_REDUCE_TENSOR_AMAX = 4,
    CUDNN_REDUCE_TENSOR_AVG = 5,
    CUDNN_REDUCE_TENSOR_NORM1 = 6,
    CUDNN_REDUCE_TENSOR_NORM2 = 7,
    CUDNN_REDUCE_TENSOR_MUL_NO_ZEROS = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnReduceTensorIndices_t {
    CUDNN_REDUCE_TENSOR_NO_INDICES = 0,
    CUDNN_REDUCE_TENSOR_FLATTENED_INDICES = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnIndicesType_t {
    CUDNN_32BIT_INDICES = 0,
    CUDNN_64BIT_INDICES = 1,
    CUDNN_16BIT_INDICES = 2,
    CUDNN_8BIT_INDICES = 3,
}
extern "C" {
    pub fn cudnnCreateReduceTensorDescriptor(
        reduceTensorDesc: *mut cudnnReduceTensorDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetReduceTensorDescriptor(
        reduceTensorDesc: cudnnReduceTensorDescriptor_t,
        reduceTensorOp: cudnnReduceTensorOp_t,
        reduceTensorCompType: cudnnDataType_t,
        reduceTensorNanOpt: cudnnNanPropagation_t,
        reduceTensorIndices: cudnnReduceTensorIndices_t,
        reduceTensorIndicesType: cudnnIndicesType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetReduceTensorDescriptor(
        reduceTensorDesc: cudnnReduceTensorDescriptor_t,
        reduceTensorOp: *mut cudnnReduceTensorOp_t,
        reduceTensorCompType: *mut cudnnDataType_t,
        reduceTensorNanOpt: *mut cudnnNanPropagation_t,
        reduceTensorIndices: *mut cudnnReduceTensorIndices_t,
        reduceTensorIndicesType: *mut cudnnIndicesType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyReduceTensorDescriptor(
        reduceTensorDesc: cudnnReduceTensorDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetReductionIndicesSize(
        handle: cudnnHandle_t,
        reduceTensorDesc: cudnnReduceTensorDescriptor_t,
        aDesc: cudnnTensorDescriptor_t,
        cDesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetReductionWorkspaceSize(
        handle: cudnnHandle_t,
        reduceTensorDesc: cudnnReduceTensorDescriptor_t,
        aDesc: cudnnTensorDescriptor_t,
        cDesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnReduceTensor(
        handle: cudnnHandle_t,
        reduceTensorDesc: cudnnReduceTensorDescriptor_t,
        indices: *mut ::libc::c_void,
        indicesSizeInBytes: usize,
        workspace: *mut ::libc::c_void,
        workspaceSizeInBytes: usize,
        alpha: *const ::libc::c_void,
        aDesc: cudnnTensorDescriptor_t,
        A: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        cDesc: cudnnTensorDescriptor_t,
        C: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetTensor(
        handle: cudnnHandle_t,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        valuePtr: *const ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnScaleTensor(
        handle: cudnnHandle_t,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        alpha: *const ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreateFilterDescriptor(filterDesc: *mut cudnnFilterDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetFilter4dDescriptor(
        filterDesc: cudnnFilterDescriptor_t,
        dataType: cudnnDataType_t,
        format: cudnnTensorFormat_t,
        k: ::libc::c_int,
        c: ::libc::c_int,
        h: ::libc::c_int,
        w: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetFilter4dDescriptor(
        filterDesc: cudnnFilterDescriptor_t,
        dataType: *mut cudnnDataType_t,
        format: *mut cudnnTensorFormat_t,
        k: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetFilterNdDescriptor(
        filterDesc: cudnnFilterDescriptor_t,
        dataType: cudnnDataType_t,
        format: cudnnTensorFormat_t,
        nbDims: ::libc::c_int,
        filterDimA: *const ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetFilterNdDescriptor(
        filterDesc: cudnnFilterDescriptor_t,
        nbDimsRequested: ::libc::c_int,
        dataType: *mut cudnnDataType_t,
        format: *mut cudnnTensorFormat_t,
        nbDims: *mut ::libc::c_int,
        filterDimA: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetFilterSizeInBytes(
        filterDesc: cudnnFilterDescriptor_t,
        size: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnTransformFilter(
        handle: cudnnHandle_t,
        transDesc: cudnnTensorTransformDescriptor_t,
        alpha: *const ::libc::c_void,
        srcDesc: cudnnFilterDescriptor_t,
        srcData: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        destDesc: cudnnFilterDescriptor_t,
        destData: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyFilterDescriptor(filterDesc: cudnnFilterDescriptor_t) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnSoftmaxAlgorithm_t {
    CUDNN_SOFTMAX_FAST = 0,
    CUDNN_SOFTMAX_ACCURATE = 1,
    CUDNN_SOFTMAX_LOG = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnSoftmaxMode_t {
    CUDNN_SOFTMAX_MODE_INSTANCE = 0,
    CUDNN_SOFTMAX_MODE_CHANNEL = 1,
}
extern "C" {
    pub fn cudnnSoftmaxForward(
        handle: cudnnHandle_t,
        algo: cudnnSoftmaxAlgorithm_t,
        mode: cudnnSoftmaxMode_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnPoolingMode_t {
    CUDNN_POOLING_MAX = 0,
    CUDNN_POOLING_AVERAGE_COUNT_INCLUDE_PADDING = 1,
    CUDNN_POOLING_AVERAGE_COUNT_EXCLUDE_PADDING = 2,
    CUDNN_POOLING_MAX_DETERMINISTIC = 3,
}
extern "C" {
    pub fn cudnnCreatePoolingDescriptor(
        poolingDesc: *mut cudnnPoolingDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetPooling2dDescriptor(
        poolingDesc: cudnnPoolingDescriptor_t,
        mode: cudnnPoolingMode_t,
        maxpoolingNanOpt: cudnnNanPropagation_t,
        windowHeight: ::libc::c_int,
        windowWidth: ::libc::c_int,
        verticalPadding: ::libc::c_int,
        horizontalPadding: ::libc::c_int,
        verticalStride: ::libc::c_int,
        horizontalStride: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetPooling2dDescriptor(
        poolingDesc: cudnnPoolingDescriptor_t,
        mode: *mut cudnnPoolingMode_t,
        maxpoolingNanOpt: *mut cudnnNanPropagation_t,
        windowHeight: *mut ::libc::c_int,
        windowWidth: *mut ::libc::c_int,
        verticalPadding: *mut ::libc::c_int,
        horizontalPadding: *mut ::libc::c_int,
        verticalStride: *mut ::libc::c_int,
        horizontalStride: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetPoolingNdDescriptor(
        poolingDesc: cudnnPoolingDescriptor_t,
        mode: cudnnPoolingMode_t,
        maxpoolingNanOpt: cudnnNanPropagation_t,
        nbDims: ::libc::c_int,
        windowDimA: *const ::libc::c_int,
        paddingA: *const ::libc::c_int,
        strideA: *const ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetPoolingNdDescriptor(
        poolingDesc: cudnnPoolingDescriptor_t,
        nbDimsRequested: ::libc::c_int,
        mode: *mut cudnnPoolingMode_t,
        maxpoolingNanOpt: *mut cudnnNanPropagation_t,
        nbDims: *mut ::libc::c_int,
        windowDimA: *mut ::libc::c_int,
        paddingA: *mut ::libc::c_int,
        strideA: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetPoolingNdForwardOutputDim(
        poolingDesc: cudnnPoolingDescriptor_t,
        inputTensorDesc: cudnnTensorDescriptor_t,
        nbDims: ::libc::c_int,
        outputTensorDimA: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetPooling2dForwardOutputDim(
        poolingDesc: cudnnPoolingDescriptor_t,
        inputTensorDesc: cudnnTensorDescriptor_t,
        n: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyPoolingDescriptor(poolingDesc: cudnnPoolingDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnPoolingForward(
        handle: cudnnHandle_t,
        poolingDesc: cudnnPoolingDescriptor_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnActivationMode_t {
    CUDNN_ACTIVATION_SIGMOID = 0,
    CUDNN_ACTIVATION_RELU = 1,
    CUDNN_ACTIVATION_TANH = 2,
    CUDNN_ACTIVATION_CLIPPED_RELU = 3,
    CUDNN_ACTIVATION_ELU = 4,
    CUDNN_ACTIVATION_IDENTITY = 5,
    CUDNN_ACTIVATION_SWISH = 6,
}
extern "C" {
    pub fn cudnnCreateActivationDescriptor(
        activationDesc: *mut cudnnActivationDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetActivationDescriptor(
        activationDesc: cudnnActivationDescriptor_t,
        mode: cudnnActivationMode_t,
        reluNanOpt: cudnnNanPropagation_t,
        coef: f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetActivationDescriptor(
        activationDesc: cudnnActivationDescriptor_t,
        mode: *mut cudnnActivationMode_t,
        reluNanOpt: *mut cudnnNanPropagation_t,
        coef: *mut f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetActivationDescriptorSwishBeta(
        activationDesc: cudnnActivationDescriptor_t,
        swish_beta: f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetActivationDescriptorSwishBeta(
        activationDesc: cudnnActivationDescriptor_t,
        swish_beta: *mut f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyActivationDescriptor(
        activationDesc: cudnnActivationDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnActivationForward(
        handle: cudnnHandle_t,
        activationDesc: cudnnActivationDescriptor_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreateLRNDescriptor(normDesc: *mut cudnnLRNDescriptor_t) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnLRNMode_t {
    CUDNN_LRN_CROSS_CHANNEL_DIM1 = 0,
}
extern "C" {
    pub fn cudnnSetLRNDescriptor(
        normDesc: cudnnLRNDescriptor_t,
        lrnN: ::libc::c_uint,
        lrnAlpha: f64,
        lrnBeta: f64,
        lrnK: f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetLRNDescriptor(
        normDesc: cudnnLRNDescriptor_t,
        lrnN: *mut ::libc::c_uint,
        lrnAlpha: *mut f64,
        lrnBeta: *mut f64,
        lrnK: *mut f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyLRNDescriptor(lrnDesc: cudnnLRNDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnLRNCrossChannelForward(
        handle: cudnnHandle_t,
        normDesc: cudnnLRNDescriptor_t,
        lrnMode: cudnnLRNMode_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnDivNormMode_t {
    CUDNN_DIVNORM_PRECOMPUTED_MEANS = 0,
}
extern "C" {
    pub fn cudnnDivisiveNormalizationForward(
        handle: cudnnHandle_t,
        normDesc: cudnnLRNDescriptor_t,
        mode: cudnnDivNormMode_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        means: *const ::libc::c_void,
        temp: *mut ::libc::c_void,
        temp2: *mut ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBatchNormMode_t {
    CUDNN_BATCHNORM_PER_ACTIVATION = 0,
    CUDNN_BATCHNORM_SPATIAL = 1,
    CUDNN_BATCHNORM_SPATIAL_PERSISTENT = 2,
}
extern "C" {
    pub fn cudnnDeriveBNTensorDescriptor(
        derivedBnDesc: cudnnTensorDescriptor_t,
        xDesc: cudnnTensorDescriptor_t,
        mode: cudnnBatchNormMode_t,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBatchNormOps_t {
    CUDNN_BATCHNORM_OPS_BN = 0,
    CUDNN_BATCHNORM_OPS_BN_ACTIVATION = 1,
    CUDNN_BATCHNORM_OPS_BN_ADD_ACTIVATION = 2,
}
extern "C" {
    pub fn cudnnBatchNormalizationForwardInference(
        handle: cudnnHandle_t,
        mode: cudnnBatchNormMode_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        bnScaleBiasMeanVarDesc: cudnnTensorDescriptor_t,
        bnScale: *const ::libc::c_void,
        bnBias: *const ::libc::c_void,
        estimatedMean: *const ::libc::c_void,
        estimatedVariance: *const ::libc::c_void,
        epsilon: f64,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnNormMode_t {
    CUDNN_NORM_PER_ACTIVATION = 0,
    CUDNN_NORM_PER_CHANNEL = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnNormAlgo_t {
    CUDNN_NORM_ALGO_STANDARD = 0,
    CUDNN_NORM_ALGO_PERSIST = 1,
}
extern "C" {
    pub fn cudnnDeriveNormTensorDescriptor(
        derivedNormScaleBiasDesc: cudnnTensorDescriptor_t,
        derivedNormMeanVarDesc: cudnnTensorDescriptor_t,
        xDesc: cudnnTensorDescriptor_t,
        mode: cudnnNormMode_t,
        groupCnt: ::libc::c_int,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnNormOps_t {
    CUDNN_NORM_OPS_NORM = 0,
    CUDNN_NORM_OPS_NORM_ACTIVATION = 1,
    CUDNN_NORM_OPS_NORM_ADD_ACTIVATION = 2,
}
extern "C" {
    pub fn cudnnNormalizationForwardInference(
        handle: cudnnHandle_t,
        mode: cudnnNormMode_t,
        normOps: cudnnNormOps_t,
        algo: cudnnNormAlgo_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        normScaleBiasDesc: cudnnTensorDescriptor_t,
        normScale: *const ::libc::c_void,
        normBias: *const ::libc::c_void,
        normMeanVarDesc: cudnnTensorDescriptor_t,
        estimatedMean: *const ::libc::c_void,
        estimatedVariance: *const ::libc::c_void,
        zDesc: cudnnTensorDescriptor_t,
        z: *const ::libc::c_void,
        activationDesc: cudnnActivationDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        epsilon: f64,
        groupCnt: ::libc::c_int,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnSamplerType_t {
    CUDNN_SAMPLER_BILINEAR = 0,
}
extern "C" {
    pub fn cudnnCreateSpatialTransformerDescriptor(
        stDesc: *mut cudnnSpatialTransformerDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetSpatialTransformerNdDescriptor(
        stDesc: cudnnSpatialTransformerDescriptor_t,
        samplerType: cudnnSamplerType_t,
        dataType: cudnnDataType_t,
        nbDims: ::libc::c_int,
        dimA: *const ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroySpatialTransformerDescriptor(
        stDesc: cudnnSpatialTransformerDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSpatialTfGridGeneratorForward(
        handle: cudnnHandle_t,
        stDesc: cudnnSpatialTransformerDescriptor_t,
        theta: *const ::libc::c_void,
        grid: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSpatialTfSamplerForward(
        handle: cudnnHandle_t,
        stDesc: cudnnSpatialTransformerDescriptor_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        grid: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnDropoutStruct {
    _unused: [u8; 0],
}
pub type cudnnDropoutDescriptor_t = *mut cudnnDropoutStruct;
extern "C" {
    pub fn cudnnCreateDropoutDescriptor(
        dropoutDesc: *mut cudnnDropoutDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyDropoutDescriptor(dropoutDesc: cudnnDropoutDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDropoutGetStatesSize(
        handle: cudnnHandle_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDropoutGetReserveSpaceSize(
        xdesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetDropoutDescriptor(
        dropoutDesc: cudnnDropoutDescriptor_t,
        handle: cudnnHandle_t,
        dropout: f32,
        states: *mut ::libc::c_void,
        stateSizeInBytes: usize,
        seed: ::libc::c_ulonglong,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRestoreDropoutDescriptor(
        dropoutDesc: cudnnDropoutDescriptor_t,
        handle: cudnnHandle_t,
        dropout: f32,
        states: *mut ::libc::c_void,
        stateSizeInBytes: usize,
        seed: ::libc::c_ulonglong,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetDropoutDescriptor(
        dropoutDesc: cudnnDropoutDescriptor_t,
        handle: cudnnHandle_t,
        dropout: *mut f32,
        states: *mut *mut ::libc::c_void,
        seed: *mut ::libc::c_ulonglong,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDropoutForward(
        handle: cudnnHandle_t,
        dropoutDesc: cudnnDropoutDescriptor_t,
        xdesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        ydesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnAlgorithmStruct {
    _unused: [u8; 0],
}
pub type cudnnAlgorithmDescriptor_t = *mut cudnnAlgorithmStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnAlgorithmPerformanceStruct {
    _unused: [u8; 0],
}
pub type cudnnAlgorithmPerformance_t = *mut cudnnAlgorithmPerformanceStruct;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnConvolutionFwdAlgo_t {
    CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_GEMM = 0,
    CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM = 1,
    CUDNN_CONVOLUTION_FWD_ALGO_GEMM = 2,
    CUDNN_CONVOLUTION_FWD_ALGO_DIRECT = 3,
    CUDNN_CONVOLUTION_FWD_ALGO_FFT = 4,
    CUDNN_CONVOLUTION_FWD_ALGO_FFT_TILING = 5,
    CUDNN_CONVOLUTION_FWD_ALGO_WINOGRAD = 6,
    CUDNN_CONVOLUTION_FWD_ALGO_WINOGRAD_NONFUSED = 7,
    CUDNN_CONVOLUTION_FWD_ALGO_COUNT = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnConvolutionBwdFilterAlgo_t {
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_0 = 0,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_1 = 1,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_FFT = 2,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_3 = 3,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_WINOGRAD = 4,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_WINOGRAD_NONFUSED = 5,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_FFT_TILING = 6,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_COUNT = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnConvolutionBwdDataAlgo_t {
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_0 = 0,
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_1 = 1,
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_FFT = 2,
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_FFT_TILING = 3,
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_WINOGRAD = 4,
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_WINOGRAD_NONFUSED = 5,
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_COUNT = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnRNNAlgo_t {
    CUDNN_RNN_ALGO_STANDARD = 0,
    CUDNN_RNN_ALGO_PERSIST_STATIC = 1,
    CUDNN_RNN_ALGO_PERSIST_DYNAMIC = 2,
    CUDNN_RNN_ALGO_PERSIST_STATIC_SMALL_H = 3,
    CUDNN_RNN_ALGO_COUNT = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnCTCLossAlgo_t {
    CUDNN_CTC_LOSS_ALGO_DETERMINISTIC = 0,
    CUDNN_CTC_LOSS_ALGO_NON_DETERMINISTIC = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudnnAlgorithmUnionStruct {
    pub algo: cudnnAlgorithmUnionStruct_Algorithm,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudnnAlgorithmUnionStruct_Algorithm {
    pub convFwdAlgo: cudnnConvolutionFwdAlgo_t,
    pub convBwdFilterAlgo: cudnnConvolutionBwdFilterAlgo_t,
    pub convBwdDataAlgo: cudnnConvolutionBwdDataAlgo_t,
    pub RNNAlgo: cudnnRNNAlgo_t,
    pub CTCLossAlgo: cudnnCTCLossAlgo_t,
}
#[test]
fn bindgen_test_layout_cudnnAlgorithmUnionStruct_Algorithm() {
    assert_eq!(
        ::std::mem::size_of::<cudnnAlgorithmUnionStruct_Algorithm>(),
        4usize,
        concat!("Size of: ", stringify!(cudnnAlgorithmUnionStruct_Algorithm))
    );
    assert_eq!(
        ::std::mem::align_of::<cudnnAlgorithmUnionStruct_Algorithm>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cudnnAlgorithmUnionStruct_Algorithm)
        )
    );
    fn test_field_convFwdAlgo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnAlgorithmUnionStruct_Algorithm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).convFwdAlgo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnAlgorithmUnionStruct_Algorithm),
                "::",
                stringify!(convFwdAlgo)
            )
        );
    }
    test_field_convFwdAlgo();
    fn test_field_convBwdFilterAlgo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnAlgorithmUnionStruct_Algorithm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).convBwdFilterAlgo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnAlgorithmUnionStruct_Algorithm),
                "::",
                stringify!(convBwdFilterAlgo)
            )
        );
    }
    test_field_convBwdFilterAlgo();
    fn test_field_convBwdDataAlgo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnAlgorithmUnionStruct_Algorithm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).convBwdDataAlgo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnAlgorithmUnionStruct_Algorithm),
                "::",
                stringify!(convBwdDataAlgo)
            )
        );
    }
    test_field_convBwdDataAlgo();
    fn test_field_RNNAlgo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnAlgorithmUnionStruct_Algorithm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RNNAlgo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnAlgorithmUnionStruct_Algorithm),
                "::",
                stringify!(RNNAlgo)
            )
        );
    }
    test_field_RNNAlgo();
    fn test_field_CTCLossAlgo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnAlgorithmUnionStruct_Algorithm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CTCLossAlgo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnAlgorithmUnionStruct_Algorithm),
                "::",
                stringify!(CTCLossAlgo)
            )
        );
    }
    test_field_CTCLossAlgo();
}
#[test]
fn bindgen_test_layout_cudnnAlgorithmUnionStruct() {
    assert_eq!(
        ::std::mem::size_of::<cudnnAlgorithmUnionStruct>(),
        4usize,
        concat!("Size of: ", stringify!(cudnnAlgorithmUnionStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<cudnnAlgorithmUnionStruct>(),
        4usize,
        concat!("Alignment of ", stringify!(cudnnAlgorithmUnionStruct))
    );
    fn test_field_algo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnAlgorithmUnionStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).algo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnAlgorithmUnionStruct),
                "::",
                stringify!(algo)
            )
        );
    }
    test_field_algo();
}
pub type cudnnAlgorithm_t = cudnnAlgorithmUnionStruct;
extern "C" {
    pub fn cudnnCreateAlgorithmDescriptor(
        algoDesc: *mut cudnnAlgorithmDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetAlgorithmDescriptor(
        algoDesc: cudnnAlgorithmDescriptor_t,
        algorithm: cudnnAlgorithm_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetAlgorithmDescriptor(
        algoDesc: cudnnAlgorithmDescriptor_t,
        algorithm: *mut cudnnAlgorithm_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCopyAlgorithmDescriptor(
        src: cudnnAlgorithmDescriptor_t,
        dest: cudnnAlgorithmDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyAlgorithmDescriptor(algoDesc: cudnnAlgorithmDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreateAlgorithmPerformance(
        algoPerf: *mut cudnnAlgorithmPerformance_t,
        numberToCreate: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetAlgorithmPerformance(
        algoPerf: cudnnAlgorithmPerformance_t,
        algoDesc: cudnnAlgorithmDescriptor_t,
        status: cudnnStatus_t,
        time: f32,
        memory: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetAlgorithmPerformance(
        algoPerf: cudnnAlgorithmPerformance_t,
        algoDesc: *mut cudnnAlgorithmDescriptor_t,
        status: *mut cudnnStatus_t,
        time: *mut f32,
        memory: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyAlgorithmPerformance(
        algoPerf: *mut cudnnAlgorithmPerformance_t,
        numberToDestroy: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetAlgorithmSpaceSize(
        handle: cudnnHandle_t,
        algoDesc: cudnnAlgorithmDescriptor_t,
        algoSpaceSizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSaveAlgorithm(
        handle: cudnnHandle_t,
        algoDesc: cudnnAlgorithmDescriptor_t,
        algoSpace: *mut ::libc::c_void,
        algoSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRestoreAlgorithm(
        handle: cudnnHandle_t,
        algoSpace: *mut ::libc::c_void,
        algoSpaceSizeInBytes: usize,
        algoDesc: cudnnAlgorithmDescriptor_t,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnSeverity_t {
    CUDNN_SEV_FATAL = 0,
    CUDNN_SEV_ERROR = 1,
    CUDNN_SEV_WARNING = 2,
    CUDNN_SEV_INFO = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnDebugStruct {
    pub cudnn_version: ::libc::c_uint,
    pub cudnnStatus: cudnnStatus_t,
    pub time_sec: ::libc::c_uint,
    pub time_usec: ::libc::c_uint,
    pub time_delta: ::libc::c_uint,
    pub handle: cudnnHandle_t,
    pub stream: cudaStream_t,
    pub pid: ::libc::c_ulonglong,
    pub tid: ::libc::c_ulonglong,
    pub cudaDeviceId: ::libc::c_int,
    pub reserved: [::libc::c_int; 15usize],
}
#[test]
fn bindgen_test_layout_cudnnDebugStruct() {
    assert_eq!(
        ::std::mem::size_of::<cudnnDebugStruct>(),
        120usize,
        concat!("Size of: ", stringify!(cudnnDebugStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<cudnnDebugStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(cudnnDebugStruct))
    );
    fn test_field_cudnn_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cudnn_version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(cudnn_version)
            )
        );
    }
    test_field_cudnn_version();
    fn test_field_cudnnStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cudnnStatus) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(cudnnStatus)
            )
        );
    }
    test_field_cudnnStatus();
    fn test_field_time_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_sec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(time_sec)
            )
        );
    }
    test_field_time_sec();
    fn test_field_time_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_usec) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(time_usec)
            )
        );
    }
    test_field_time_usec();
    fn test_field_time_delta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_delta) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(time_delta)
            )
        );
    }
    test_field_time_delta();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_stream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(stream)
            )
        );
    }
    test_field_stream();
    fn test_field_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(pid)
            )
        );
    }
    test_field_pid();
    fn test_field_tid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tid) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(tid)
            )
        );
    }
    test_field_tid();
    fn test_field_cudaDeviceId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cudaDeviceId) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(cudaDeviceId)
            )
        );
    }
    test_field_cudaDeviceId();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnDebugStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnDebugStruct),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudnnDebug_t = cudnnDebugStruct;
pub type cudnnCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        sev: cudnnSeverity_t,
        udata: *mut ::libc::c_void,
        dbg: *const cudnnDebug_t,
        msg: *const ::libc::c_char,
    ),
>;
extern "C" {
    pub fn cudnnSetCallback(
        mask: ::libc::c_uint,
        udata: *mut ::libc::c_void,
        fptr: cudnnCallback_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetCallback(
        mask: *mut ::libc::c_uint,
        udata: *mut *mut ::libc::c_void,
        fptr: *mut cudnnCallback_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnOpsInferVersionCheck() -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSoftmaxBackward(
        handle: cudnnHandle_t,
        algo: cudnnSoftmaxAlgorithm_t,
        mode: cudnnSoftmaxMode_t,
        alpha: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnPoolingBackward(
        handle: cudnnHandle_t,
        poolingDesc: cudnnPoolingDescriptor_t,
        alpha: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnActivationBackward(
        handle: cudnnHandle_t,
        activationDesc: cudnnActivationDescriptor_t,
        alpha: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnLRNCrossChannelBackward(
        handle: cudnnHandle_t,
        normDesc: cudnnLRNDescriptor_t,
        lrnMode: cudnnLRNMode_t,
        alpha: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDivisiveNormalizationBackward(
        handle: cudnnHandle_t,
        normDesc: cudnnLRNDescriptor_t,
        mode: cudnnDivNormMode_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        means: *const ::libc::c_void,
        dy: *const ::libc::c_void,
        temp: *mut ::libc::c_void,
        temp2: *mut ::libc::c_void,
        beta: *const ::libc::c_void,
        dXdMeansDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        dMeans: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetBatchNormalizationForwardTrainingExWorkspaceSize(
        handle: cudnnHandle_t,
        mode: cudnnBatchNormMode_t,
        bnOps: cudnnBatchNormOps_t,
        xDesc: cudnnTensorDescriptor_t,
        zDesc: cudnnTensorDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        bnScaleBiasMeanVarDesc: cudnnTensorDescriptor_t,
        activationDesc: cudnnActivationDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetBatchNormalizationBackwardExWorkspaceSize(
        handle: cudnnHandle_t,
        mode: cudnnBatchNormMode_t,
        bnOps: cudnnBatchNormOps_t,
        xDesc: cudnnTensorDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        dyDesc: cudnnTensorDescriptor_t,
        dzDesc: cudnnTensorDescriptor_t,
        dxDesc: cudnnTensorDescriptor_t,
        dBnScaleBiasDesc: cudnnTensorDescriptor_t,
        activationDesc: cudnnActivationDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetBatchNormalizationTrainingExReserveSpaceSize(
        handle: cudnnHandle_t,
        mode: cudnnBatchNormMode_t,
        bnOps: cudnnBatchNormOps_t,
        activationDesc: cudnnActivationDescriptor_t,
        xDesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBatchNormalizationForwardTraining(
        handle: cudnnHandle_t,
        mode: cudnnBatchNormMode_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        bnScaleBiasMeanVarDesc: cudnnTensorDescriptor_t,
        bnScale: *const ::libc::c_void,
        bnBias: *const ::libc::c_void,
        exponentialAverageFactor: f64,
        resultRunningMean: *mut ::libc::c_void,
        resultRunningVariance: *mut ::libc::c_void,
        epsilon: f64,
        resultSaveMean: *mut ::libc::c_void,
        resultSaveInvVariance: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBatchNormalizationForwardTrainingEx(
        handle: cudnnHandle_t,
        mode: cudnnBatchNormMode_t,
        bnOps: cudnnBatchNormOps_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        xData: *const ::libc::c_void,
        zDesc: cudnnTensorDescriptor_t,
        zData: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        yData: *mut ::libc::c_void,
        bnScaleBiasMeanVarDesc: cudnnTensorDescriptor_t,
        bnScale: *const ::libc::c_void,
        bnBias: *const ::libc::c_void,
        exponentialAverageFactor: f64,
        resultRunningMean: *mut ::libc::c_void,
        resultRunningVariance: *mut ::libc::c_void,
        epsilon: f64,
        resultSaveMean: *mut ::libc::c_void,
        resultSaveInvVariance: *mut ::libc::c_void,
        activationDesc: cudnnActivationDescriptor_t,
        workspace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBatchNormalizationBackward(
        handle: cudnnHandle_t,
        mode: cudnnBatchNormMode_t,
        alphaDataDiff: *const ::libc::c_void,
        betaDataDiff: *const ::libc::c_void,
        alphaParamDiff: *const ::libc::c_void,
        betaParamDiff: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        dBnScaleBiasDesc: cudnnTensorDescriptor_t,
        bnScale: *const ::libc::c_void,
        dBnScaleResult: *mut ::libc::c_void,
        dBnBiasResult: *mut ::libc::c_void,
        epsilon: f64,
        savedMean: *const ::libc::c_void,
        savedInvVariance: *const ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBatchNormalizationBackwardEx(
        handle: cudnnHandle_t,
        mode: cudnnBatchNormMode_t,
        bnOps: cudnnBatchNormOps_t,
        alphaDataDiff: *const ::libc::c_void,
        betaDataDiff: *const ::libc::c_void,
        alphaParamDiff: *const ::libc::c_void,
        betaParamDiff: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        xData: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        yData: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dyData: *const ::libc::c_void,
        dzDesc: cudnnTensorDescriptor_t,
        dzData: *mut ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dxData: *mut ::libc::c_void,
        dBnScaleBiasDesc: cudnnTensorDescriptor_t,
        bnScaleData: *const ::libc::c_void,
        bnBiasData: *const ::libc::c_void,
        dBnScaleData: *mut ::libc::c_void,
        dBnBiasData: *mut ::libc::c_void,
        epsilon: f64,
        savedMean: *const ::libc::c_void,
        savedInvVariance: *const ::libc::c_void,
        activationDesc: cudnnActivationDescriptor_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetNormalizationForwardTrainingWorkspaceSize(
        handle: cudnnHandle_t,
        mode: cudnnNormMode_t,
        normOps: cudnnNormOps_t,
        algo: cudnnNormAlgo_t,
        xDesc: cudnnTensorDescriptor_t,
        zDesc: cudnnTensorDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        normScaleBiasDesc: cudnnTensorDescriptor_t,
        activationDesc: cudnnActivationDescriptor_t,
        normMeanVarDesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
        groupCnt: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetNormalizationBackwardWorkspaceSize(
        handle: cudnnHandle_t,
        mode: cudnnNormMode_t,
        normOps: cudnnNormOps_t,
        algo: cudnnNormAlgo_t,
        xDesc: cudnnTensorDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        dyDesc: cudnnTensorDescriptor_t,
        dzDesc: cudnnTensorDescriptor_t,
        dxDesc: cudnnTensorDescriptor_t,
        dNormScaleBiasDesc: cudnnTensorDescriptor_t,
        activationDesc: cudnnActivationDescriptor_t,
        normMeanVarDesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
        groupCnt: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetNormalizationTrainingReserveSpaceSize(
        handle: cudnnHandle_t,
        mode: cudnnNormMode_t,
        normOps: cudnnNormOps_t,
        algo: cudnnNormAlgo_t,
        activationDesc: cudnnActivationDescriptor_t,
        xDesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
        groupCnt: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnNormalizationForwardTraining(
        handle: cudnnHandle_t,
        mode: cudnnNormMode_t,
        normOps: cudnnNormOps_t,
        algo: cudnnNormAlgo_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        xData: *const ::libc::c_void,
        normScaleBiasDesc: cudnnTensorDescriptor_t,
        normScale: *const ::libc::c_void,
        normBias: *const ::libc::c_void,
        exponentialAverageFactor: f64,
        normMeanVarDesc: cudnnTensorDescriptor_t,
        resultRunningMean: *mut ::libc::c_void,
        resultRunningVariance: *mut ::libc::c_void,
        epsilon: f64,
        resultSaveMean: *mut ::libc::c_void,
        resultSaveInvVariance: *mut ::libc::c_void,
        activationDesc: cudnnActivationDescriptor_t,
        zDesc: cudnnTensorDescriptor_t,
        zData: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        yData: *mut ::libc::c_void,
        workspace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
        groupCnt: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnNormalizationBackward(
        handle: cudnnHandle_t,
        mode: cudnnNormMode_t,
        normOps: cudnnNormOps_t,
        algo: cudnnNormAlgo_t,
        alphaDataDiff: *const ::libc::c_void,
        betaDataDiff: *const ::libc::c_void,
        alphaParamDiff: *const ::libc::c_void,
        betaParamDiff: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        xData: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        yData: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dyData: *const ::libc::c_void,
        dzDesc: cudnnTensorDescriptor_t,
        dzData: *mut ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dxData: *mut ::libc::c_void,
        dNormScaleBiasDesc: cudnnTensorDescriptor_t,
        normScaleData: *const ::libc::c_void,
        normBiasData: *const ::libc::c_void,
        dNormScaleData: *mut ::libc::c_void,
        dNormBiasData: *mut ::libc::c_void,
        epsilon: f64,
        normMeanVarDesc: cudnnTensorDescriptor_t,
        savedMean: *const ::libc::c_void,
        savedInvVariance: *const ::libc::c_void,
        activationDesc: cudnnActivationDescriptor_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
        groupCnt: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSpatialTfGridGeneratorBackward(
        handle: cudnnHandle_t,
        stDesc: cudnnSpatialTransformerDescriptor_t,
        dgrid: *const ::libc::c_void,
        dtheta: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSpatialTfSamplerBackward(
        handle: cudnnHandle_t,
        stDesc: cudnnSpatialTransformerDescriptor_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        alphaDgrid: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        grid: *const ::libc::c_void,
        betaDgrid: *const ::libc::c_void,
        dgrid: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDropoutBackward(
        handle: cudnnHandle_t,
        dropoutDesc: cudnnDropoutDescriptor_t,
        dydesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        dxdesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnOpsTrainVersionCheck() -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnForwardMode_t {
    CUDNN_FWD_MODE_INFERENCE = 0,
    CUDNN_FWD_MODE_TRAINING = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnRNNMode_t {
    CUDNN_RNN_RELU = 0,
    CUDNN_RNN_TANH = 1,
    CUDNN_LSTM = 2,
    CUDNN_GRU = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnRNNBiasMode_t {
    CUDNN_RNN_NO_BIAS = 0,
    CUDNN_RNN_SINGLE_INP_BIAS = 1,
    CUDNN_RNN_DOUBLE_BIAS = 2,
    CUDNN_RNN_SINGLE_REC_BIAS = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnDirectionMode_t {
    CUDNN_UNIDIRECTIONAL = 0,
    CUDNN_BIDIRECTIONAL = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnRNNInputMode_t {
    CUDNN_LINEAR_INPUT = 0,
    CUDNN_SKIP_INPUT = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnRNNClipMode_t {
    CUDNN_RNN_CLIP_NONE = 0,
    CUDNN_RNN_CLIP_MINMAX = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnRNNDataLayout_t {
    CUDNN_RNN_DATA_LAYOUT_SEQ_MAJOR_UNPACKED = 0,
    CUDNN_RNN_DATA_LAYOUT_SEQ_MAJOR_PACKED = 1,
    CUDNN_RNN_DATA_LAYOUT_BATCH_MAJOR_UNPACKED = 2,
}
pub type cudnnRNNPaddingMode_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnRNNStruct {
    _unused: [u8; 0],
}
pub type cudnnRNNDescriptor_t = *mut cudnnRNNStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnPersistentRNNPlan {
    _unused: [u8; 0],
}
pub type cudnnPersistentRNNPlan_t = *mut cudnnPersistentRNNPlan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnRNNDataStruct {
    _unused: [u8; 0],
}
pub type cudnnRNNDataDescriptor_t = *mut cudnnRNNDataStruct;
extern "C" {
    pub fn cudnnCreateRNNDescriptor(rnnDesc: *mut cudnnRNNDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyRNNDescriptor(rnnDesc: cudnnRNNDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetRNNDescriptor_v8(
        rnnDesc: cudnnRNNDescriptor_t,
        algo: cudnnRNNAlgo_t,
        cellMode: cudnnRNNMode_t,
        biasMode: cudnnRNNBiasMode_t,
        dirMode: cudnnDirectionMode_t,
        inputMode: cudnnRNNInputMode_t,
        dataType: cudnnDataType_t,
        mathPrec: cudnnDataType_t,
        mathType: cudnnMathType_t,
        inputSize: i32,
        hiddenSize: i32,
        projSize: i32,
        numLayers: i32,
        dropoutDesc: cudnnDropoutDescriptor_t,
        auxFlags: u32,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNDescriptor_v8(
        rnnDesc: cudnnRNNDescriptor_t,
        algo: *mut cudnnRNNAlgo_t,
        cellMode: *mut cudnnRNNMode_t,
        biasMode: *mut cudnnRNNBiasMode_t,
        dirMode: *mut cudnnDirectionMode_t,
        inputMode: *mut cudnnRNNInputMode_t,
        dataType: *mut cudnnDataType_t,
        mathPrec: *mut cudnnDataType_t,
        mathType: *mut cudnnMathType_t,
        inputSize: *mut i32,
        hiddenSize: *mut i32,
        projSize: *mut i32,
        numLayers: *mut i32,
        dropoutDesc: *mut cudnnDropoutDescriptor_t,
        auxFlags: *mut u32,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetRNNDescriptor_v6(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        hiddenSize: ::libc::c_int,
        numLayers: ::libc::c_int,
        dropoutDesc: cudnnDropoutDescriptor_t,
        inputMode: cudnnRNNInputMode_t,
        direction: cudnnDirectionMode_t,
        cellMode: cudnnRNNMode_t,
        algo: cudnnRNNAlgo_t,
        mathPrec: cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNDescriptor_v6(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        hiddenSize: *mut ::libc::c_int,
        numLayers: *mut ::libc::c_int,
        dropoutDesc: *mut cudnnDropoutDescriptor_t,
        inputMode: *mut cudnnRNNInputMode_t,
        direction: *mut cudnnDirectionMode_t,
        cellMode: *mut cudnnRNNMode_t,
        algo: *mut cudnnRNNAlgo_t,
        mathPrec: *mut cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetRNNMatrixMathType(
        rnnDesc: cudnnRNNDescriptor_t,
        mType: cudnnMathType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNMatrixMathType(
        rnnDesc: cudnnRNNDescriptor_t,
        mType: *mut cudnnMathType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetRNNBiasMode(
        rnnDesc: cudnnRNNDescriptor_t,
        biasMode: cudnnRNNBiasMode_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNBiasMode(
        rnnDesc: cudnnRNNDescriptor_t,
        biasMode: *mut cudnnRNNBiasMode_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNSetClip_v8(
        rnnDesc: cudnnRNNDescriptor_t,
        clipMode: cudnnRNNClipMode_t,
        clipNanOpt: cudnnNanPropagation_t,
        lclip: f64,
        rclip: f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNGetClip_v8(
        rnnDesc: cudnnRNNDescriptor_t,
        clipMode: *mut cudnnRNNClipMode_t,
        clipNanOpt: *mut cudnnNanPropagation_t,
        lclip: *mut f64,
        rclip: *mut f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNSetClip(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        clipMode: cudnnRNNClipMode_t,
        clipNanOpt: cudnnNanPropagation_t,
        lclip: f64,
        rclip: f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNGetClip(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        clipMode: *mut cudnnRNNClipMode_t,
        clipNanOpt: *mut cudnnNanPropagation_t,
        lclip: *mut f64,
        rclip: *mut f64,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetRNNProjectionLayers(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        recProjSize: ::libc::c_int,
        outProjSize: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNProjectionLayers(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        recProjSize: *mut ::libc::c_int,
        outProjSize: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreatePersistentRNNPlan(
        rnnDesc: cudnnRNNDescriptor_t,
        minibatch: ::libc::c_int,
        dataType: cudnnDataType_t,
        plan: *mut cudnnPersistentRNNPlan_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyPersistentRNNPlan(plan: cudnnPersistentRNNPlan_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetPersistentRNNPlan(
        rnnDesc: cudnnRNNDescriptor_t,
        plan: cudnnPersistentRNNPlan_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBuildRNNDynamic(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        miniBatch: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNWorkspaceSize(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        xDesc: *const cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNTrainingReserveSize(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        xDesc: *const cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNTempSpaceSizes(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        fMode: cudnnForwardMode_t,
        xDesc: cudnnRNNDataDescriptor_t,
        workSpaceSize: *mut usize,
        reserveSpaceSize: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNParamsSize(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        xDesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
        dataType: cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNWeightSpaceSize(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        weightSpaceSize: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNLinLayerMatrixParams(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        pseudoLayer: ::libc::c_int,
        xDesc: cudnnTensorDescriptor_t,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        linLayerID: ::libc::c_int,
        linLayerMatDesc: cudnnFilterDescriptor_t,
        linLayerMat: *mut *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNLinLayerBiasParams(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        pseudoLayer: ::libc::c_int,
        xDesc: cudnnTensorDescriptor_t,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        linLayerID: ::libc::c_int,
        linLayerBiasDesc: cudnnFilterDescriptor_t,
        linLayerBias: *mut *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNWeightParams(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        pseudoLayer: i32,
        weightSpaceSize: usize,
        weightSpace: *const ::libc::c_void,
        linLayerID: i32,
        mDesc: cudnnTensorDescriptor_t,
        mAddr: *mut *mut ::libc::c_void,
        bDesc: cudnnTensorDescriptor_t,
        bAddr: *mut *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNForwardInference(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        xDesc: *const cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        yDesc: *const cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        hyDesc: cudnnTensorDescriptor_t,
        hy: *mut ::libc::c_void,
        cyDesc: cudnnTensorDescriptor_t,
        cy: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetRNNPaddingMode(
        rnnDesc: cudnnRNNDescriptor_t,
        paddingMode: ::libc::c_uint,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNPaddingMode(
        rnnDesc: cudnnRNNDescriptor_t,
        paddingMode: *mut ::libc::c_uint,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreateRNNDataDescriptor(
        rnnDataDesc: *mut cudnnRNNDataDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyRNNDataDescriptor(rnnDataDesc: cudnnRNNDataDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetRNNDataDescriptor(
        rnnDataDesc: cudnnRNNDataDescriptor_t,
        dataType: cudnnDataType_t,
        layout: cudnnRNNDataLayout_t,
        maxSeqLength: ::libc::c_int,
        batchSize: ::libc::c_int,
        vectorSize: ::libc::c_int,
        seqLengthArray: *const ::libc::c_int,
        paddingFill: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNDataDescriptor(
        rnnDataDesc: cudnnRNNDataDescriptor_t,
        dataType: *mut cudnnDataType_t,
        layout: *mut cudnnRNNDataLayout_t,
        maxSeqLength: *mut ::libc::c_int,
        batchSize: *mut ::libc::c_int,
        vectorSize: *mut ::libc::c_int,
        arrayLengthRequested: ::libc::c_int,
        seqLengthArray: *mut ::libc::c_int,
        paddingFill: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNForwardInferenceEx(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        xDesc: cudnnRNNDataDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        yDesc: cudnnRNNDataDescriptor_t,
        y: *mut ::libc::c_void,
        hyDesc: cudnnTensorDescriptor_t,
        hy: *mut ::libc::c_void,
        cyDesc: cudnnTensorDescriptor_t,
        cy: *mut ::libc::c_void,
        kDesc: cudnnRNNDataDescriptor_t,
        keys: *const ::libc::c_void,
        cDesc: cudnnRNNDataDescriptor_t,
        cAttn: *mut ::libc::c_void,
        iDesc: cudnnRNNDataDescriptor_t,
        iAttn: *mut ::libc::c_void,
        qDesc: cudnnRNNDataDescriptor_t,
        queries: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNForward(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        fwdMode: cudnnForwardMode_t,
        devSeqLengths: *const i32,
        xDesc: cudnnRNNDataDescriptor_t,
        x: *const ::libc::c_void,
        yDesc: cudnnRNNDataDescriptor_t,
        y: *mut ::libc::c_void,
        hDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        hy: *mut ::libc::c_void,
        cDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        cy: *mut ::libc::c_void,
        weightSpaceSize: usize,
        weightSpace: *const ::libc::c_void,
        workSpaceSize: usize,
        workSpace: *mut ::libc::c_void,
        reserveSpaceSize: usize,
        reserveSpace: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetRNNAlgorithmDescriptor(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        algoDesc: cudnnAlgorithmDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNForwardInferenceAlgorithmMaxCount(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        count: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindRNNForwardInferenceAlgorithmEx(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        xDesc: *const cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        yDesc: *const cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        hyDesc: cudnnTensorDescriptor_t,
        hy: *mut ::libc::c_void,
        cyDesc: cudnnTensorDescriptor_t,
        cy: *mut ::libc::c_void,
        findIntensity: f32,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnAlgorithmPerformance_t,
        workspace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnSeqDataAxis_t {
    CUDNN_SEQDATA_TIME_DIM = 0,
    CUDNN_SEQDATA_BATCH_DIM = 1,
    CUDNN_SEQDATA_BEAM_DIM = 2,
    CUDNN_SEQDATA_VECT_DIM = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnSeqDataStruct {
    _unused: [u8; 0],
}
pub type cudnnSeqDataDescriptor_t = *mut cudnnSeqDataStruct;
extern "C" {
    pub fn cudnnCreateSeqDataDescriptor(
        seqDataDesc: *mut cudnnSeqDataDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroySeqDataDescriptor(seqDataDesc: cudnnSeqDataDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetSeqDataDescriptor(
        seqDataDesc: cudnnSeqDataDescriptor_t,
        dataType: cudnnDataType_t,
        nbDims: ::libc::c_int,
        dimA: *const ::libc::c_int,
        axes: *const cudnnSeqDataAxis_t,
        seqLengthArraySize: usize,
        seqLengthArray: *const ::libc::c_int,
        paddingFill: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetSeqDataDescriptor(
        seqDataDesc: cudnnSeqDataDescriptor_t,
        dataType: *mut cudnnDataType_t,
        nbDims: *mut ::libc::c_int,
        nbDimsRequested: ::libc::c_int,
        dimA: *mut ::libc::c_int,
        axes: *mut cudnnSeqDataAxis_t,
        seqLengthArraySize: *mut usize,
        seqLengthSizeRequested: usize,
        seqLengthArray: *mut ::libc::c_int,
        paddingFill: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
pub type cudnnAttnQueryMap_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnAttnStruct {
    _unused: [u8; 0],
}
pub type cudnnAttnDescriptor_t = *mut cudnnAttnStruct;
extern "C" {
    pub fn cudnnCreateAttnDescriptor(attnDesc: *mut cudnnAttnDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyAttnDescriptor(attnDesc: cudnnAttnDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetAttnDescriptor(
        attnDesc: cudnnAttnDescriptor_t,
        attnMode: ::libc::c_uint,
        nHeads: ::libc::c_int,
        smScaler: f64,
        dataType: cudnnDataType_t,
        computePrec: cudnnDataType_t,
        mathType: cudnnMathType_t,
        attnDropoutDesc: cudnnDropoutDescriptor_t,
        postDropoutDesc: cudnnDropoutDescriptor_t,
        qSize: ::libc::c_int,
        kSize: ::libc::c_int,
        vSize: ::libc::c_int,
        qProjSize: ::libc::c_int,
        kProjSize: ::libc::c_int,
        vProjSize: ::libc::c_int,
        oProjSize: ::libc::c_int,
        qoMaxSeqLength: ::libc::c_int,
        kvMaxSeqLength: ::libc::c_int,
        maxBatchSize: ::libc::c_int,
        maxBeamSize: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetAttnDescriptor(
        attnDesc: cudnnAttnDescriptor_t,
        attnMode: *mut ::libc::c_uint,
        nHeads: *mut ::libc::c_int,
        smScaler: *mut f64,
        dataType: *mut cudnnDataType_t,
        computePrec: *mut cudnnDataType_t,
        mathType: *mut cudnnMathType_t,
        attnDropoutDesc: *mut cudnnDropoutDescriptor_t,
        postDropoutDesc: *mut cudnnDropoutDescriptor_t,
        qSize: *mut ::libc::c_int,
        kSize: *mut ::libc::c_int,
        vSize: *mut ::libc::c_int,
        qProjSize: *mut ::libc::c_int,
        kProjSize: *mut ::libc::c_int,
        vProjSize: *mut ::libc::c_int,
        oProjSize: *mut ::libc::c_int,
        qoMaxSeqLength: *mut ::libc::c_int,
        kvMaxSeqLength: *mut ::libc::c_int,
        maxBatchSize: *mut ::libc::c_int,
        maxBeamSize: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetMultiHeadAttnBuffers(
        handle: cudnnHandle_t,
        attnDesc: cudnnAttnDescriptor_t,
        weightSizeInBytes: *mut usize,
        workSpaceSizeInBytes: *mut usize,
        reserveSpaceSizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnMultiHeadAttnWeightKind_t {
    CUDNN_MH_ATTN_Q_WEIGHTS = 0,
    CUDNN_MH_ATTN_K_WEIGHTS = 1,
    CUDNN_MH_ATTN_V_WEIGHTS = 2,
    CUDNN_MH_ATTN_O_WEIGHTS = 3,
    CUDNN_MH_ATTN_Q_BIASES = 4,
    CUDNN_MH_ATTN_K_BIASES = 5,
    CUDNN_MH_ATTN_V_BIASES = 6,
    CUDNN_MH_ATTN_O_BIASES = 7,
}
extern "C" {
    pub fn cudnnGetMultiHeadAttnWeights(
        handle: cudnnHandle_t,
        attnDesc: cudnnAttnDescriptor_t,
        wKind: cudnnMultiHeadAttnWeightKind_t,
        weightSizeInBytes: usize,
        weights: *const ::libc::c_void,
        wDesc: cudnnTensorDescriptor_t,
        wAddr: *mut *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnMultiHeadAttnForward(
        handle: cudnnHandle_t,
        attnDesc: cudnnAttnDescriptor_t,
        currIdx: ::libc::c_int,
        loWinIdx: *const ::libc::c_int,
        hiWinIdx: *const ::libc::c_int,
        devSeqLengthsQO: *const ::libc::c_int,
        devSeqLengthsKV: *const ::libc::c_int,
        qDesc: cudnnSeqDataDescriptor_t,
        queries: *const ::libc::c_void,
        residuals: *const ::libc::c_void,
        kDesc: cudnnSeqDataDescriptor_t,
        keys: *const ::libc::c_void,
        vDesc: cudnnSeqDataDescriptor_t,
        values: *const ::libc::c_void,
        oDesc: cudnnSeqDataDescriptor_t,
        out: *mut ::libc::c_void,
        weightSizeInBytes: usize,
        weights: *const ::libc::c_void,
        workSpaceSizeInBytes: usize,
        workSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnAdvInferVersionCheck() -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnWgradMode_t {
    CUDNN_WGRAD_MODE_ADD = 0,
    CUDNN_WGRAD_MODE_SET = 1,
}
extern "C" {
    pub fn cudnnRNNForwardTraining(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        xDesc: *const cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        yDesc: *const cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        hyDesc: cudnnTensorDescriptor_t,
        hy: *mut ::libc::c_void,
        cyDesc: cudnnTensorDescriptor_t,
        cy: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNBackwardData(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        yDesc: *const cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: *const cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        dhyDesc: cudnnTensorDescriptor_t,
        dhy: *const ::libc::c_void,
        dcyDesc: cudnnTensorDescriptor_t,
        dcy: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        dxDesc: *const cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        dhxDesc: cudnnTensorDescriptor_t,
        dhx: *mut ::libc::c_void,
        dcxDesc: cudnnTensorDescriptor_t,
        dcx: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNBackwardData_v8(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        devSeqLengths: *const i32,
        yDesc: cudnnRNNDataDescriptor_t,
        y: *const ::libc::c_void,
        dy: *const ::libc::c_void,
        xDesc: cudnnRNNDataDescriptor_t,
        dx: *mut ::libc::c_void,
        hDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        dhy: *const ::libc::c_void,
        dhx: *mut ::libc::c_void,
        cDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        dcy: *const ::libc::c_void,
        dcx: *mut ::libc::c_void,
        weightSpaceSize: usize,
        weightSpace: *const ::libc::c_void,
        workSpaceSize: usize,
        workSpace: *mut ::libc::c_void,
        reserveSpaceSize: usize,
        reserveSpace: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNBackwardWeights(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        xDesc: *const cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        yDesc: *const cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        workSpace: *const ::libc::c_void,
        workSpaceSizeInBytes: usize,
        dwDesc: cudnnFilterDescriptor_t,
        dw: *mut ::libc::c_void,
        reserveSpace: *const ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNBackwardWeights_v8(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        addGrad: cudnnWgradMode_t,
        devSeqLengths: *const i32,
        xDesc: cudnnRNNDataDescriptor_t,
        x: *const ::libc::c_void,
        hDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        yDesc: cudnnRNNDataDescriptor_t,
        y: *const ::libc::c_void,
        weightSpaceSize: usize,
        dweightSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
        workSpace: *mut ::libc::c_void,
        reserveSpaceSize: usize,
        reserveSpace: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNForwardTrainingEx(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        xDesc: cudnnRNNDataDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        yDesc: cudnnRNNDataDescriptor_t,
        y: *mut ::libc::c_void,
        hyDesc: cudnnTensorDescriptor_t,
        hy: *mut ::libc::c_void,
        cyDesc: cudnnTensorDescriptor_t,
        cy: *mut ::libc::c_void,
        kDesc: cudnnRNNDataDescriptor_t,
        keys: *const ::libc::c_void,
        cDesc: cudnnRNNDataDescriptor_t,
        cAttn: *mut ::libc::c_void,
        iDesc: cudnnRNNDataDescriptor_t,
        iAttn: *mut ::libc::c_void,
        qDesc: cudnnRNNDataDescriptor_t,
        queries: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNBackwardDataEx(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        yDesc: cudnnRNNDataDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: cudnnRNNDataDescriptor_t,
        dy: *const ::libc::c_void,
        dcDesc: cudnnRNNDataDescriptor_t,
        dcAttn: *const ::libc::c_void,
        dhyDesc: cudnnTensorDescriptor_t,
        dhy: *const ::libc::c_void,
        dcyDesc: cudnnTensorDescriptor_t,
        dcy: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        dxDesc: cudnnRNNDataDescriptor_t,
        dx: *mut ::libc::c_void,
        dhxDesc: cudnnTensorDescriptor_t,
        dhx: *mut ::libc::c_void,
        dcxDesc: cudnnTensorDescriptor_t,
        dcx: *mut ::libc::c_void,
        dkDesc: cudnnRNNDataDescriptor_t,
        dkeys: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnRNNBackwardWeightsEx(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        xDesc: cudnnRNNDataDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        yDesc: cudnnRNNDataDescriptor_t,
        y: *const ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        dwDesc: cudnnFilterDescriptor_t,
        dw: *mut ::libc::c_void,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNForwardTrainingAlgorithmMaxCount(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        count: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindRNNForwardTrainingAlgorithmEx(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        xDesc: *const cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        yDesc: *const cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        hyDesc: cudnnTensorDescriptor_t,
        hy: *mut ::libc::c_void,
        cyDesc: cudnnTensorDescriptor_t,
        cy: *mut ::libc::c_void,
        findIntensity: f32,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnAlgorithmPerformance_t,
        workspace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNBackwardDataAlgorithmMaxCount(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        count: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindRNNBackwardDataAlgorithmEx(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        yDesc: *const cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: *const cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        dhyDesc: cudnnTensorDescriptor_t,
        dhy: *const ::libc::c_void,
        dcyDesc: cudnnTensorDescriptor_t,
        dcy: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: cudnnTensorDescriptor_t,
        cx: *const ::libc::c_void,
        dxDesc: *const cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        dhxDesc: cudnnTensorDescriptor_t,
        dhx: *mut ::libc::c_void,
        dcxDesc: cudnnTensorDescriptor_t,
        dcx: *mut ::libc::c_void,
        findIntensity: f32,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnAlgorithmPerformance_t,
        workspace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetRNNBackwardWeightsAlgorithmMaxCount(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        count: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindRNNBackwardWeightsAlgorithmEx(
        handle: cudnnHandle_t,
        rnnDesc: cudnnRNNDescriptor_t,
        seqLength: ::libc::c_int,
        xDesc: *const cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: cudnnTensorDescriptor_t,
        hx: *const ::libc::c_void,
        yDesc: *const cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        findIntensity: f32,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnAlgorithmPerformance_t,
        workspace: *const ::libc::c_void,
        workSpaceSizeInBytes: usize,
        dwDesc: cudnnFilterDescriptor_t,
        dw: *mut ::libc::c_void,
        reserveSpace: *const ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnMultiHeadAttnBackwardData(
        handle: cudnnHandle_t,
        attnDesc: cudnnAttnDescriptor_t,
        loWinIdx: *const ::libc::c_int,
        hiWinIdx: *const ::libc::c_int,
        devSeqLengthsDQDO: *const ::libc::c_int,
        devSeqLengthsDKDV: *const ::libc::c_int,
        doDesc: cudnnSeqDataDescriptor_t,
        dout: *const ::libc::c_void,
        dqDesc: cudnnSeqDataDescriptor_t,
        dqueries: *mut ::libc::c_void,
        queries: *const ::libc::c_void,
        dkDesc: cudnnSeqDataDescriptor_t,
        dkeys: *mut ::libc::c_void,
        keys: *const ::libc::c_void,
        dvDesc: cudnnSeqDataDescriptor_t,
        dvalues: *mut ::libc::c_void,
        values: *const ::libc::c_void,
        weightSizeInBytes: usize,
        weights: *const ::libc::c_void,
        workSpaceSizeInBytes: usize,
        workSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnMultiHeadAttnBackwardWeights(
        handle: cudnnHandle_t,
        attnDesc: cudnnAttnDescriptor_t,
        addGrad: cudnnWgradMode_t,
        qDesc: cudnnSeqDataDescriptor_t,
        queries: *const ::libc::c_void,
        kDesc: cudnnSeqDataDescriptor_t,
        keys: *const ::libc::c_void,
        vDesc: cudnnSeqDataDescriptor_t,
        values: *const ::libc::c_void,
        doDesc: cudnnSeqDataDescriptor_t,
        dout: *const ::libc::c_void,
        weightSizeInBytes: usize,
        weights: *const ::libc::c_void,
        dweights: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        workSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
        reserveSpace: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnLossNormalizationMode_t {
    CUDNN_LOSS_NORMALIZATION_NONE = 0,
    CUDNN_LOSS_NORMALIZATION_SOFTMAX = 1,
}
extern "C" {
    pub fn cudnnCreateCTCLossDescriptor(
        ctcLossDesc: *mut cudnnCTCLossDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetCTCLossDescriptor(
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        compType: cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetCTCLossDescriptorEx(
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        compType: cudnnDataType_t,
        normMode: cudnnLossNormalizationMode_t,
        gradMode: cudnnNanPropagation_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetCTCLossDescriptor_v8(
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        compType: cudnnDataType_t,
        normMode: cudnnLossNormalizationMode_t,
        gradMode: cudnnNanPropagation_t,
        maxLabelLength: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetCTCLossDescriptor(
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        compType: *mut cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetCTCLossDescriptorEx(
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        compType: *mut cudnnDataType_t,
        normMode: *mut cudnnLossNormalizationMode_t,
        gradMode: *mut cudnnNanPropagation_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetCTCLossDescriptor_v8(
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        compType: *mut cudnnDataType_t,
        normMode: *mut cudnnLossNormalizationMode_t,
        gradMode: *mut cudnnNanPropagation_t,
        maxLabelLength: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyCTCLossDescriptor(ctcLossDesc: cudnnCTCLossDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCTCLoss(
        handle: cudnnHandle_t,
        probsDesc: cudnnTensorDescriptor_t,
        probs: *const ::libc::c_void,
        hostLabels: *const ::libc::c_int,
        hostLabelLengths: *const ::libc::c_int,
        hostInputLengths: *const ::libc::c_int,
        costs: *mut ::libc::c_void,
        gradientsDesc: cudnnTensorDescriptor_t,
        gradients: *mut ::libc::c_void,
        algo: cudnnCTCLossAlgo_t,
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        workspace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCTCLoss_v8(
        handle: cudnnHandle_t,
        algo: cudnnCTCLossAlgo_t,
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        probsDesc: cudnnTensorDescriptor_t,
        probs: *const ::libc::c_void,
        labels: *const ::libc::c_int,
        labelLengths: *const ::libc::c_int,
        inputLengths: *const ::libc::c_int,
        costs: *mut ::libc::c_void,
        gradientsDesc: cudnnTensorDescriptor_t,
        gradients: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        workspace: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetCTCLossWorkspaceSize(
        handle: cudnnHandle_t,
        probsDesc: cudnnTensorDescriptor_t,
        gradientsDesc: cudnnTensorDescriptor_t,
        labels: *const ::libc::c_int,
        labelLengths: *const ::libc::c_int,
        inputLengths: *const ::libc::c_int,
        algo: cudnnCTCLossAlgo_t,
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetCTCLossWorkspaceSize_v8(
        handle: cudnnHandle_t,
        algo: cudnnCTCLossAlgo_t,
        ctcLossDesc: cudnnCTCLossDescriptor_t,
        probsDesc: cudnnTensorDescriptor_t,
        gradientsDesc: cudnnTensorDescriptor_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnAdvTrainVersionCheck() -> cudnnStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnConvolutionStruct {
    _unused: [u8; 0],
}
pub type cudnnConvolutionDescriptor_t = *mut cudnnConvolutionStruct;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnConvolutionMode_t {
    CUDNN_CONVOLUTION = 0,
    CUDNN_CROSS_CORRELATION = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnReorderType_t {
    CUDNN_DEFAULT_REORDER = 0,
    CUDNN_NO_REORDER = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnConvolutionFwdAlgoPerfStruct {
    pub algo: cudnnConvolutionFwdAlgo_t,
    pub status: cudnnStatus_t,
    pub time: f32,
    pub memory: usize,
    pub determinism: cudnnDeterminism_t,
    pub mathType: cudnnMathType_t,
    pub reserved: [::libc::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_cudnnConvolutionFwdAlgoPerfStruct() {
    assert_eq!(
        ::std::mem::size_of::<cudnnConvolutionFwdAlgoPerfStruct>(),
        48usize,
        concat!("Size of: ", stringify!(cudnnConvolutionFwdAlgoPerfStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<cudnnConvolutionFwdAlgoPerfStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudnnConvolutionFwdAlgoPerfStruct)
        )
    );
    fn test_field_algo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnConvolutionFwdAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).algo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionFwdAlgoPerfStruct),
                "::",
                stringify!(algo)
            )
        );
    }
    test_field_algo();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnConvolutionFwdAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionFwdAlgoPerfStruct),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnConvolutionFwdAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionFwdAlgoPerfStruct),
                "::",
                stringify!(time)
            )
        );
    }
    test_field_time();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnConvolutionFwdAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionFwdAlgoPerfStruct),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_determinism() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnConvolutionFwdAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).determinism) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionFwdAlgoPerfStruct),
                "::",
                stringify!(determinism)
            )
        );
    }
    test_field_determinism();
    fn test_field_mathType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnConvolutionFwdAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mathType) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionFwdAlgoPerfStruct),
                "::",
                stringify!(mathType)
            )
        );
    }
    test_field_mathType();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnConvolutionFwdAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionFwdAlgoPerfStruct),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudnnConvolutionFwdAlgoPerf_t = cudnnConvolutionFwdAlgoPerfStruct;
extern "C" {
    pub fn cudnnCreateConvolutionDescriptor(
        convDesc: *mut cudnnConvolutionDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyConvolutionDescriptor(
        convDesc: cudnnConvolutionDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetConvolutionMathType(
        convDesc: cudnnConvolutionDescriptor_t,
        mathType: cudnnMathType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionMathType(
        convDesc: cudnnConvolutionDescriptor_t,
        mathType: *mut cudnnMathType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetConvolutionGroupCount(
        convDesc: cudnnConvolutionDescriptor_t,
        groupCount: ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionGroupCount(
        convDesc: cudnnConvolutionDescriptor_t,
        groupCount: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetConvolutionReorderType(
        convDesc: cudnnConvolutionDescriptor_t,
        reorderType: cudnnReorderType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionReorderType(
        convDesc: cudnnConvolutionDescriptor_t,
        reorderType: *mut cudnnReorderType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetConvolution2dDescriptor(
        convDesc: cudnnConvolutionDescriptor_t,
        pad_h: ::libc::c_int,
        pad_w: ::libc::c_int,
        u: ::libc::c_int,
        v: ::libc::c_int,
        dilation_h: ::libc::c_int,
        dilation_w: ::libc::c_int,
        mode: cudnnConvolutionMode_t,
        computeType: cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolution2dDescriptor(
        convDesc: cudnnConvolutionDescriptor_t,
        pad_h: *mut ::libc::c_int,
        pad_w: *mut ::libc::c_int,
        u: *mut ::libc::c_int,
        v: *mut ::libc::c_int,
        dilation_h: *mut ::libc::c_int,
        dilation_w: *mut ::libc::c_int,
        mode: *mut cudnnConvolutionMode_t,
        computeType: *mut cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetConvolutionNdDescriptor(
        convDesc: cudnnConvolutionDescriptor_t,
        arrayLength: ::libc::c_int,
        padA: *const ::libc::c_int,
        filterStrideA: *const ::libc::c_int,
        dilationA: *const ::libc::c_int,
        mode: cudnnConvolutionMode_t,
        computeType: cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionNdDescriptor(
        convDesc: cudnnConvolutionDescriptor_t,
        arrayLengthRequested: ::libc::c_int,
        arrayLength: *mut ::libc::c_int,
        padA: *mut ::libc::c_int,
        strideA: *mut ::libc::c_int,
        dilationA: *mut ::libc::c_int,
        mode: *mut cudnnConvolutionMode_t,
        computeType: *mut cudnnDataType_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolution2dForwardOutputDim(
        convDesc: cudnnConvolutionDescriptor_t,
        inputTensorDesc: cudnnTensorDescriptor_t,
        filterDesc: cudnnFilterDescriptor_t,
        n: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionNdForwardOutputDim(
        convDesc: cudnnConvolutionDescriptor_t,
        inputTensorDesc: cudnnTensorDescriptor_t,
        filterDesc: cudnnFilterDescriptor_t,
        nbDims: ::libc::c_int,
        tensorOuputDimA: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionForwardAlgorithmMaxCount(
        handle: cudnnHandle_t,
        count: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionForwardAlgorithm_v7(
        handle: cudnnHandle_t,
        srcDesc: cudnnTensorDescriptor_t,
        filterDesc: cudnnFilterDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        destDesc: cudnnTensorDescriptor_t,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionFwdAlgoPerf_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindConvolutionForwardAlgorithm(
        handle: cudnnHandle_t,
        xDesc: cudnnTensorDescriptor_t,
        wDesc: cudnnFilterDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionFwdAlgoPerf_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindConvolutionForwardAlgorithmEx(
        handle: cudnnHandle_t,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        convDesc: cudnnConvolutionDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionFwdAlgoPerf_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnIm2Col(
        handle: cudnnHandle_t,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        colBuffer: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnReorderFilterAndBias(
        handle: cudnnHandle_t,
        filterDesc: cudnnFilterDescriptor_t,
        reorderType: cudnnReorderType_t,
        filterData: *const ::libc::c_void,
        reorderedFilterData: *mut ::libc::c_void,
        reorderBias: ::libc::c_int,
        biasData: *const ::libc::c_void,
        reorderedBiasData: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionForwardWorkspaceSize(
        handle: cudnnHandle_t,
        xDesc: cudnnTensorDescriptor_t,
        wDesc: cudnnFilterDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        algo: cudnnConvolutionFwdAlgo_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnConvolutionForward(
        handle: cudnnHandle_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        convDesc: cudnnConvolutionDescriptor_t,
        algo: cudnnConvolutionFwdAlgo_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        beta: *const ::libc::c_void,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnConvolutionBiasActivationForward(
        handle: cudnnHandle_t,
        alpha1: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        convDesc: cudnnConvolutionDescriptor_t,
        algo: cudnnConvolutionFwdAlgo_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        alpha2: *const ::libc::c_void,
        zDesc: cudnnTensorDescriptor_t,
        z: *const ::libc::c_void,
        biasDesc: cudnnTensorDescriptor_t,
        bias: *const ::libc::c_void,
        activationDesc: cudnnActivationDescriptor_t,
        yDesc: cudnnTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnConvolutionBwdDataAlgoPerfStruct {
    pub algo: cudnnConvolutionBwdDataAlgo_t,
    pub status: cudnnStatus_t,
    pub time: f32,
    pub memory: usize,
    pub determinism: cudnnDeterminism_t,
    pub mathType: cudnnMathType_t,
    pub reserved: [::libc::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_cudnnConvolutionBwdDataAlgoPerfStruct() {
    assert_eq!(
        ::std::mem::size_of::<cudnnConvolutionBwdDataAlgoPerfStruct>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(cudnnConvolutionBwdDataAlgoPerfStruct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudnnConvolutionBwdDataAlgoPerfStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudnnConvolutionBwdDataAlgoPerfStruct)
        )
    );
    fn test_field_algo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdDataAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).algo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdDataAlgoPerfStruct),
                "::",
                stringify!(algo)
            )
        );
    }
    test_field_algo();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdDataAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdDataAlgoPerfStruct),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_time() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdDataAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdDataAlgoPerfStruct),
                "::",
                stringify!(time)
            )
        );
    }
    test_field_time();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdDataAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdDataAlgoPerfStruct),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_determinism() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdDataAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).determinism) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdDataAlgoPerfStruct),
                "::",
                stringify!(determinism)
            )
        );
    }
    test_field_determinism();
    fn test_field_mathType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdDataAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mathType) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdDataAlgoPerfStruct),
                "::",
                stringify!(mathType)
            )
        );
    }
    test_field_mathType();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdDataAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdDataAlgoPerfStruct),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudnnConvolutionBwdDataAlgoPerf_t = cudnnConvolutionBwdDataAlgoPerfStruct;
extern "C" {
    pub fn cudnnGetConvolutionBackwardDataAlgorithmMaxCount(
        handle: cudnnHandle_t,
        count: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindConvolutionBackwardDataAlgorithm(
        handle: cudnnHandle_t,
        wDesc: cudnnFilterDescriptor_t,
        dyDesc: cudnnTensorDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        dxDesc: cudnnTensorDescriptor_t,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionBwdDataAlgoPerf_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindConvolutionBackwardDataAlgorithmEx(
        handle: cudnnHandle_t,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        convDesc: cudnnConvolutionDescriptor_t,
        dxDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionBwdDataAlgoPerf_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionBackwardDataAlgorithm_v7(
        handle: cudnnHandle_t,
        filterDesc: cudnnFilterDescriptor_t,
        diffDesc: cudnnTensorDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        gradDesc: cudnnTensorDescriptor_t,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionBwdDataAlgoPerf_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionBackwardDataWorkspaceSize(
        handle: cudnnHandle_t,
        wDesc: cudnnFilterDescriptor_t,
        dyDesc: cudnnTensorDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        dxDesc: cudnnTensorDescriptor_t,
        algo: cudnnConvolutionBwdDataAlgo_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnConvolutionBackwardData(
        handle: cudnnHandle_t,
        alpha: *const ::libc::c_void,
        wDesc: cudnnFilterDescriptor_t,
        w: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        convDesc: cudnnConvolutionDescriptor_t,
        algo: cudnnConvolutionBwdDataAlgo_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        beta: *const ::libc::c_void,
        dxDesc: cudnnTensorDescriptor_t,
        dx: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetFoldedConvBackwardDataDescriptors(
        handle: cudnnHandle_t,
        filterDesc: cudnnFilterDescriptor_t,
        diffDesc: cudnnTensorDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        gradDesc: cudnnTensorDescriptor_t,
        transformFormat: cudnnTensorFormat_t,
        foldedFilterDesc: cudnnFilterDescriptor_t,
        paddedDiffDesc: cudnnTensorDescriptor_t,
        foldedConvDesc: cudnnConvolutionDescriptor_t,
        foldedGradDesc: cudnnTensorDescriptor_t,
        filterFoldTransDesc: cudnnTensorTransformDescriptor_t,
        diffPadTransDesc: cudnnTensorTransformDescriptor_t,
        gradFoldTransDesc: cudnnTensorTransformDescriptor_t,
        gradUnfoldTransDesc: cudnnTensorTransformDescriptor_t,
    ) -> cudnnStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnFusedOpsConstParamStruct {
    _unused: [u8; 0],
}
pub type cudnnFusedOpsConstParamPack_t = *mut cudnnFusedOpsConstParamStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnFusedOpsVariantParamStruct {
    _unused: [u8; 0],
}
pub type cudnnFusedOpsVariantParamPack_t = *mut cudnnFusedOpsVariantParamStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnFusedOpsPlanStruct {
    _unused: [u8; 0],
}
pub type cudnnFusedOpsPlan_t = *mut cudnnFusedOpsPlanStruct;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnFusedOps_t {
    CUDNN_FUSED_SCALE_BIAS_ACTIVATION_CONV_BNSTATS = 0,
    CUDNN_FUSED_SCALE_BIAS_ACTIVATION_WGRAD = 1,
    CUDNN_FUSED_BN_FINALIZE_STATISTICS_TRAINING = 2,
    CUDNN_FUSED_BN_FINALIZE_STATISTICS_INFERENCE = 3,
    CUDNN_FUSED_CONV_SCALE_BIAS_ADD_ACTIVATION = 4,
    CUDNN_FUSED_SCALE_BIAS_ADD_ACTIVATION_GEN_BITMASK = 5,
    CUDNN_FUSED_DACTIVATION_FORK_DBATCHNORM = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnFusedOpsConstParamLabel_t {
    CUDNN_PARAM_XDESC = 0,
    CUDNN_PARAM_XDATA_PLACEHOLDER = 1,
    CUDNN_PARAM_BN_MODE = 2,
    CUDNN_PARAM_BN_EQSCALEBIAS_DESC = 3,
    CUDNN_PARAM_BN_EQSCALE_PLACEHOLDER = 4,
    CUDNN_PARAM_BN_EQBIAS_PLACEHOLDER = 5,
    CUDNN_PARAM_ACTIVATION_DESC = 6,
    CUDNN_PARAM_CONV_DESC = 7,
    CUDNN_PARAM_WDESC = 8,
    CUDNN_PARAM_WDATA_PLACEHOLDER = 9,
    CUDNN_PARAM_DWDESC = 10,
    CUDNN_PARAM_DWDATA_PLACEHOLDER = 11,
    CUDNN_PARAM_YDESC = 12,
    CUDNN_PARAM_YDATA_PLACEHOLDER = 13,
    CUDNN_PARAM_DYDESC = 14,
    CUDNN_PARAM_DYDATA_PLACEHOLDER = 15,
    CUDNN_PARAM_YSTATS_DESC = 16,
    CUDNN_PARAM_YSUM_PLACEHOLDER = 17,
    CUDNN_PARAM_YSQSUM_PLACEHOLDER = 18,
    CUDNN_PARAM_BN_SCALEBIAS_MEANVAR_DESC = 19,
    CUDNN_PARAM_BN_SCALE_PLACEHOLDER = 20,
    CUDNN_PARAM_BN_BIAS_PLACEHOLDER = 21,
    CUDNN_PARAM_BN_SAVED_MEAN_PLACEHOLDER = 22,
    CUDNN_PARAM_BN_SAVED_INVSTD_PLACEHOLDER = 23,
    CUDNN_PARAM_BN_RUNNING_MEAN_PLACEHOLDER = 24,
    CUDNN_PARAM_BN_RUNNING_VAR_PLACEHOLDER = 25,
    CUDNN_PARAM_ZDESC = 26,
    CUDNN_PARAM_ZDATA_PLACEHOLDER = 27,
    CUDNN_PARAM_BN_Z_EQSCALEBIAS_DESC = 28,
    CUDNN_PARAM_BN_Z_EQSCALE_PLACEHOLDER = 29,
    CUDNN_PARAM_BN_Z_EQBIAS_PLACEHOLDER = 30,
    CUDNN_PARAM_ACTIVATION_BITMASK_DESC = 31,
    CUDNN_PARAM_ACTIVATION_BITMASK_PLACEHOLDER = 32,
    CUDNN_PARAM_DXDESC = 33,
    CUDNN_PARAM_DXDATA_PLACEHOLDER = 34,
    CUDNN_PARAM_DZDESC = 35,
    CUDNN_PARAM_DZDATA_PLACEHOLDER = 36,
    CUDNN_PARAM_BN_DSCALE_PLACEHOLDER = 37,
    CUDNN_PARAM_BN_DBIAS_PLACEHOLDER = 38,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnFusedOpsPointerPlaceHolder_t {
    CUDNN_PTR_NULL = 0,
    CUDNN_PTR_ELEM_ALIGNED = 1,
    CUDNN_PTR_16B_ALIGNED = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnFusedOpsVariantParamLabel_t {
    CUDNN_PTR_XDATA = 0,
    CUDNN_PTR_BN_EQSCALE = 1,
    CUDNN_PTR_BN_EQBIAS = 2,
    CUDNN_PTR_WDATA = 3,
    CUDNN_PTR_DWDATA = 4,
    CUDNN_PTR_YDATA = 5,
    CUDNN_PTR_DYDATA = 6,
    CUDNN_PTR_YSUM = 7,
    CUDNN_PTR_YSQSUM = 8,
    CUDNN_PTR_WORKSPACE = 9,
    CUDNN_PTR_BN_SCALE = 10,
    CUDNN_PTR_BN_BIAS = 11,
    CUDNN_PTR_BN_SAVED_MEAN = 12,
    CUDNN_PTR_BN_SAVED_INVSTD = 13,
    CUDNN_PTR_BN_RUNNING_MEAN = 14,
    CUDNN_PTR_BN_RUNNING_VAR = 15,
    CUDNN_PTR_ZDATA = 16,
    CUDNN_PTR_BN_Z_EQSCALE = 17,
    CUDNN_PTR_BN_Z_EQBIAS = 18,
    CUDNN_PTR_ACTIVATION_BITMASK = 19,
    CUDNN_PTR_DXDATA = 20,
    CUDNN_PTR_DZDATA = 21,
    CUDNN_PTR_BN_DSCALE = 22,
    CUDNN_PTR_BN_DBIAS = 23,
    CUDNN_SCALAR_SIZE_T_WORKSPACE_SIZE_IN_BYTES = 100,
    CUDNN_SCALAR_INT64_T_BN_ACCUMULATION_COUNT = 101,
    CUDNN_SCALAR_DOUBLE_BN_EXP_AVG_FACTOR = 102,
    CUDNN_SCALAR_DOUBLE_BN_EPSILON = 103,
}
extern "C" {
    pub fn cudnnCnnInferVersionCheck() -> cudnnStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnConvolutionBwdFilterAlgoPerfStruct {
    pub algo: cudnnConvolutionBwdFilterAlgo_t,
    pub status: cudnnStatus_t,
    pub time: f32,
    pub memory: usize,
    pub determinism: cudnnDeterminism_t,
    pub mathType: cudnnMathType_t,
    pub reserved: [::libc::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_cudnnConvolutionBwdFilterAlgoPerfStruct() {
    assert_eq!(
        ::std::mem::size_of::<cudnnConvolutionBwdFilterAlgoPerfStruct>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudnnConvolutionBwdFilterAlgoPerfStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct)
        )
    );
    fn test_field_algo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdFilterAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).algo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct),
                "::",
                stringify!(algo)
            )
        );
    }
    test_field_algo();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdFilterAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_time() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdFilterAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct),
                "::",
                stringify!(time)
            )
        );
    }
    test_field_time();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdFilterAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_determinism() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdFilterAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).determinism) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct),
                "::",
                stringify!(determinism)
            )
        );
    }
    test_field_determinism();
    fn test_field_mathType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdFilterAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mathType) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct),
                "::",
                stringify!(mathType)
            )
        );
    }
    test_field_mathType();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudnnConvolutionBwdFilterAlgoPerfStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnConvolutionBwdFilterAlgoPerfStruct),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudnnConvolutionBwdFilterAlgoPerf_t = cudnnConvolutionBwdFilterAlgoPerfStruct;
extern "C" {
    pub fn cudnnGetConvolutionBackwardFilterAlgorithmMaxCount(
        handle: cudnnHandle_t,
        count: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindConvolutionBackwardFilterAlgorithm(
        handle: cudnnHandle_t,
        xDesc: cudnnTensorDescriptor_t,
        dyDesc: cudnnTensorDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        dwDesc: cudnnFilterDescriptor_t,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionBwdFilterAlgoPerf_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFindConvolutionBackwardFilterAlgorithmEx(
        handle: cudnnHandle_t,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        y: *const ::libc::c_void,
        convDesc: cudnnConvolutionDescriptor_t,
        dwDesc: cudnnFilterDescriptor_t,
        dw: *mut ::libc::c_void,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionBwdFilterAlgoPerf_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionBackwardFilterAlgorithm_v7(
        handle: cudnnHandle_t,
        srcDesc: cudnnTensorDescriptor_t,
        diffDesc: cudnnTensorDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        gradDesc: cudnnFilterDescriptor_t,
        requestedAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut cudnnConvolutionBwdFilterAlgoPerf_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetConvolutionBackwardFilterWorkspaceSize(
        handle: cudnnHandle_t,
        xDesc: cudnnTensorDescriptor_t,
        dyDesc: cudnnTensorDescriptor_t,
        convDesc: cudnnConvolutionDescriptor_t,
        gradDesc: cudnnFilterDescriptor_t,
        algo: cudnnConvolutionBwdFilterAlgo_t,
        sizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnConvolutionBackwardFilter(
        handle: cudnnHandle_t,
        alpha: *const ::libc::c_void,
        xDesc: cudnnTensorDescriptor_t,
        x: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        convDesc: cudnnConvolutionDescriptor_t,
        algo: cudnnConvolutionBwdFilterAlgo_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSizeInBytes: usize,
        beta: *const ::libc::c_void,
        dwDesc: cudnnFilterDescriptor_t,
        dw: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnConvolutionBackwardBias(
        handle: cudnnHandle_t,
        alpha: *const ::libc::c_void,
        dyDesc: cudnnTensorDescriptor_t,
        dy: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dbDesc: cudnnTensorDescriptor_t,
        db: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreateFusedOpsConstParamPack(
        constPack: *mut cudnnFusedOpsConstParamPack_t,
        ops: cudnnFusedOps_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyFusedOpsConstParamPack(
        constPack: cudnnFusedOpsConstParamPack_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetFusedOpsConstParamPackAttribute(
        constPack: cudnnFusedOpsConstParamPack_t,
        paramLabel: cudnnFusedOpsConstParamLabel_t,
        param: *const ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetFusedOpsConstParamPackAttribute(
        constPack: cudnnFusedOpsConstParamPack_t,
        paramLabel: cudnnFusedOpsConstParamLabel_t,
        param: *mut ::libc::c_void,
        isNULL: *mut ::libc::c_int,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreateFusedOpsVariantParamPack(
        varPack: *mut cudnnFusedOpsVariantParamPack_t,
        ops: cudnnFusedOps_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyFusedOpsVariantParamPack(
        varPack: cudnnFusedOpsVariantParamPack_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnSetFusedOpsVariantParamPackAttribute(
        varPack: cudnnFusedOpsVariantParamPack_t,
        paramLabel: cudnnFusedOpsVariantParamLabel_t,
        ptr: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnGetFusedOpsVariantParamPackAttribute(
        varPack: cudnnFusedOpsVariantParamPack_t,
        paramLabel: cudnnFusedOpsVariantParamLabel_t,
        ptr: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCreateFusedOpsPlan(
        plan: *mut cudnnFusedOpsPlan_t,
        ops: cudnnFusedOps_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnDestroyFusedOpsPlan(plan: cudnnFusedOpsPlan_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnMakeFusedOpsPlan(
        handle: cudnnHandle_t,
        plan: cudnnFusedOpsPlan_t,
        constPack: cudnnFusedOpsConstParamPack_t,
        workspaceSizeInBytes: *mut usize,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnFusedOpsExecute(
        handle: cudnnHandle_t,
        plan: cudnnFusedOpsPlan_t,
        varPack: cudnnFusedOpsVariantParamPack_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnCnnTrainVersionCheck() -> cudnnStatus_t;
}
pub type cudnnBackendDescriptor_t = *mut ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudnnFractionStruct {
    pub numerator: i64,
    pub denominator: i64,
}
#[test]
fn bindgen_test_layout_cudnnFractionStruct() {
    assert_eq!(
        ::std::mem::size_of::<cudnnFractionStruct>(),
        16usize,
        concat!("Size of: ", stringify!(cudnnFractionStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<cudnnFractionStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(cudnnFractionStruct))
    );
    fn test_field_numerator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnFractionStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnFractionStruct),
                "::",
                stringify!(numerator)
            )
        );
    }
    test_field_numerator();
    fn test_field_denominator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudnnFractionStruct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudnnFractionStruct),
                "::",
                stringify!(denominator)
            )
        );
    }
    test_field_denominator();
}
pub type cudnnFraction_t = cudnnFractionStruct;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnPointwiseMode_t {
    CUDNN_POINTWISE_ADD = 0,
    CUDNN_POINTWISE_ADD_SQUARE = 5,
    CUDNN_POINTWISE_DIV = 6,
    CUDNN_POINTWISE_MAX = 3,
    CUDNN_POINTWISE_MIN = 2,
    CUDNN_POINTWISE_MOD = 7,
    CUDNN_POINTWISE_MUL = 1,
    CUDNN_POINTWISE_POW = 8,
    CUDNN_POINTWISE_SUB = 9,
    CUDNN_POINTWISE_ABS = 10,
    CUDNN_POINTWISE_CEIL = 11,
    CUDNN_POINTWISE_COS = 12,
    CUDNN_POINTWISE_EXP = 13,
    CUDNN_POINTWISE_FLOOR = 14,
    CUDNN_POINTWISE_LOG = 15,
    CUDNN_POINTWISE_NEG = 16,
    CUDNN_POINTWISE_RSQRT = 17,
    CUDNN_POINTWISE_SIN = 18,
    CUDNN_POINTWISE_SQRT = 4,
    CUDNN_POINTWISE_TAN = 19,
    CUDNN_POINTWISE_ERF = 20,
    CUDNN_POINTWISE_IDENTITY = 21,
    CUDNN_POINTWISE_RELU_FWD = 100,
    CUDNN_POINTWISE_TANH_FWD = 101,
    CUDNN_POINTWISE_SIGMOID_FWD = 102,
    CUDNN_POINTWISE_ELU_FWD = 103,
    CUDNN_POINTWISE_GELU_FWD = 104,
    CUDNN_POINTWISE_SOFTPLUS_FWD = 105,
    CUDNN_POINTWISE_SWISH_FWD = 106,
    CUDNN_POINTWISE_GELU_APPROX_TANH_FWD = 107,
    CUDNN_POINTWISE_RELU_BWD = 200,
    CUDNN_POINTWISE_TANH_BWD = 201,
    CUDNN_POINTWISE_SIGMOID_BWD = 202,
    CUDNN_POINTWISE_ELU_BWD = 203,
    CUDNN_POINTWISE_GELU_BWD = 204,
    CUDNN_POINTWISE_SOFTPLUS_BWD = 205,
    CUDNN_POINTWISE_SWISH_BWD = 206,
    CUDNN_POINTWISE_GELU_APPROX_TANH_BWD = 207,
    CUDNN_POINTWISE_CMP_EQ = 300,
    CUDNN_POINTWISE_CMP_NEQ = 301,
    CUDNN_POINTWISE_CMP_GT = 302,
    CUDNN_POINTWISE_CMP_GE = 303,
    CUDNN_POINTWISE_CMP_LT = 304,
    CUDNN_POINTWISE_CMP_LE = 305,
    CUDNN_POINTWISE_LOGICAL_AND = 400,
    CUDNN_POINTWISE_LOGICAL_OR = 401,
    CUDNN_POINTWISE_LOGICAL_NOT = 402,
    CUDNN_POINTWISE_GEN_INDEX = 501,
    CUDNN_POINTWISE_BINARY_SELECT = 601,
}
impl cudnnResampleMode_t {
    pub const CUDNN_RESAMPLE_AVGPOOL_INCLUDE_PADDING: cudnnResampleMode_t =
        cudnnResampleMode_t::CUDNN_RESAMPLE_AVGPOOL;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnResampleMode_t {
    CUDNN_RESAMPLE_NEAREST = 0,
    CUDNN_RESAMPLE_BILINEAR = 1,
    CUDNN_RESAMPLE_AVGPOOL = 2,
    CUDNN_RESAMPLE_AVGPOOL_EXCLUDE_PADDING = 4,
    CUDNN_RESAMPLE_MAXPOOL = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnSignalMode_t {
    CUDNN_SIGNAL_SET = 0,
    CUDNN_SIGNAL_WAIT = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnGenStatsMode_t {
    CUDNN_GENSTATS_SUM_SQSUM = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBnFinalizeStatsMode_t {
    CUDNN_BN_FINALIZE_STATISTICS_TRAINING = 0,
    CUDNN_BN_FINALIZE_STATISTICS_INFERENCE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnRngDistribution_t {
    CUDNN_RNG_DISTRIBUTION_BERNOULLI = 0,
    CUDNN_RNG_DISTRIBUTION_UNIFORM = 1,
    CUDNN_RNG_DISTRIBUTION_NORMAL = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendAttributeName_t {
    CUDNN_ATTR_POINTWISE_MODE = 0,
    CUDNN_ATTR_POINTWISE_MATH_PREC = 1,
    CUDNN_ATTR_POINTWISE_NAN_PROPAGATION = 2,
    CUDNN_ATTR_POINTWISE_RELU_LOWER_CLIP = 3,
    CUDNN_ATTR_POINTWISE_RELU_UPPER_CLIP = 4,
    CUDNN_ATTR_POINTWISE_RELU_LOWER_CLIP_SLOPE = 5,
    CUDNN_ATTR_POINTWISE_ELU_ALPHA = 6,
    CUDNN_ATTR_POINTWISE_SOFTPLUS_BETA = 7,
    CUDNN_ATTR_POINTWISE_SWISH_BETA = 8,
    CUDNN_ATTR_POINTWISE_AXIS = 9,
    CUDNN_ATTR_CONVOLUTION_COMP_TYPE = 100,
    CUDNN_ATTR_CONVOLUTION_CONV_MODE = 101,
    CUDNN_ATTR_CONVOLUTION_DILATIONS = 102,
    CUDNN_ATTR_CONVOLUTION_FILTER_STRIDES = 103,
    CUDNN_ATTR_CONVOLUTION_POST_PADDINGS = 104,
    CUDNN_ATTR_CONVOLUTION_PRE_PADDINGS = 105,
    CUDNN_ATTR_CONVOLUTION_SPATIAL_DIMS = 106,
    CUDNN_ATTR_ENGINEHEUR_MODE = 200,
    CUDNN_ATTR_ENGINEHEUR_OPERATION_GRAPH = 201,
    CUDNN_ATTR_ENGINEHEUR_RESULTS = 202,
    CUDNN_ATTR_ENGINECFG_ENGINE = 300,
    CUDNN_ATTR_ENGINECFG_INTERMEDIATE_INFO = 301,
    CUDNN_ATTR_ENGINECFG_KNOB_CHOICES = 302,
    CUDNN_ATTR_EXECUTION_PLAN_HANDLE = 400,
    CUDNN_ATTR_EXECUTION_PLAN_ENGINE_CONFIG = 401,
    CUDNN_ATTR_EXECUTION_PLAN_WORKSPACE_SIZE = 402,
    CUDNN_ATTR_EXECUTION_PLAN_COMPUTED_INTERMEDIATE_UIDS = 403,
    CUDNN_ATTR_EXECUTION_PLAN_RUN_ONLY_INTERMEDIATE_UIDS = 404,
    CUDNN_ATTR_EXECUTION_PLAN_JSON_REPRESENTATION = 405,
    CUDNN_ATTR_INTERMEDIATE_INFO_UNIQUE_ID = 500,
    CUDNN_ATTR_INTERMEDIATE_INFO_SIZE = 501,
    CUDNN_ATTR_INTERMEDIATE_INFO_DEPENDENT_DATA_UIDS = 502,
    CUDNN_ATTR_INTERMEDIATE_INFO_DEPENDENT_ATTRIBUTES = 503,
    CUDNN_ATTR_KNOB_CHOICE_KNOB_TYPE = 600,
    CUDNN_ATTR_KNOB_CHOICE_KNOB_VALUE = 601,
    CUDNN_ATTR_OPERATION_CONVOLUTION_FORWARD_ALPHA = 700,
    CUDNN_ATTR_OPERATION_CONVOLUTION_FORWARD_BETA = 701,
    CUDNN_ATTR_OPERATION_CONVOLUTION_FORWARD_CONV_DESC = 702,
    CUDNN_ATTR_OPERATION_CONVOLUTION_FORWARD_W = 703,
    CUDNN_ATTR_OPERATION_CONVOLUTION_FORWARD_X = 704,
    CUDNN_ATTR_OPERATION_CONVOLUTION_FORWARD_Y = 705,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_DATA_ALPHA = 706,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_DATA_BETA = 707,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_DATA_CONV_DESC = 708,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_DATA_W = 709,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_DATA_DX = 710,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_DATA_DY = 711,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_FILTER_ALPHA = 712,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_FILTER_BETA = 713,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_FILTER_CONV_DESC = 714,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_FILTER_DW = 715,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_FILTER_X = 716,
    CUDNN_ATTR_OPERATION_CONVOLUTION_BWD_FILTER_DY = 717,
    CUDNN_ATTR_OPERATION_POINTWISE_PW_DESCRIPTOR = 750,
    CUDNN_ATTR_OPERATION_POINTWISE_XDESC = 751,
    CUDNN_ATTR_OPERATION_POINTWISE_BDESC = 752,
    CUDNN_ATTR_OPERATION_POINTWISE_YDESC = 753,
    CUDNN_ATTR_OPERATION_POINTWISE_ALPHA1 = 754,
    CUDNN_ATTR_OPERATION_POINTWISE_ALPHA2 = 755,
    CUDNN_ATTR_OPERATION_POINTWISE_DXDESC = 756,
    CUDNN_ATTR_OPERATION_POINTWISE_DYDESC = 757,
    CUDNN_ATTR_OPERATION_POINTWISE_TDESC = 758,
    CUDNN_ATTR_OPERATION_GENSTATS_MODE = 770,
    CUDNN_ATTR_OPERATION_GENSTATS_MATH_PREC = 771,
    CUDNN_ATTR_OPERATION_GENSTATS_XDESC = 772,
    CUDNN_ATTR_OPERATION_GENSTATS_SUMDESC = 773,
    CUDNN_ATTR_OPERATION_GENSTATS_SQSUMDESC = 774,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_STATS_MODE = 780,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_MATH_PREC = 781,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_Y_SUM_DESC = 782,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_Y_SQ_SUM_DESC = 783,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_SCALE_DESC = 784,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_BIAS_DESC = 785,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_PREV_RUNNING_MEAN_DESC = 786,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_PREV_RUNNING_VAR_DESC = 787,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_UPDATED_RUNNING_MEAN_DESC = 788,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_UPDATED_RUNNING_VAR_DESC = 789,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_SAVED_MEAN_DESC = 790,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_SAVED_INV_STD_DESC = 791,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_EQ_SCALE_DESC = 792,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_EQ_BIAS_DESC = 793,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_ACCUM_COUNT_DESC = 794,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_EPSILON_DESC = 795,
    CUDNN_ATTR_OPERATION_BN_FINALIZE_EXP_AVERATE_FACTOR_DESC = 796,
    CUDNN_ATTR_OPERATIONGRAPH_HANDLE = 800,
    CUDNN_ATTR_OPERATIONGRAPH_OPS = 801,
    CUDNN_ATTR_OPERATIONGRAPH_ENGINE_GLOBAL_COUNT = 802,
    CUDNN_ATTR_TENSOR_BYTE_ALIGNMENT = 900,
    CUDNN_ATTR_TENSOR_DATA_TYPE = 901,
    CUDNN_ATTR_TENSOR_DIMENSIONS = 902,
    CUDNN_ATTR_TENSOR_STRIDES = 903,
    CUDNN_ATTR_TENSOR_VECTOR_COUNT = 904,
    CUDNN_ATTR_TENSOR_VECTORIZED_DIMENSION = 905,
    CUDNN_ATTR_TENSOR_UNIQUE_ID = 906,
    CUDNN_ATTR_TENSOR_IS_VIRTUAL = 907,
    CUDNN_ATTR_TENSOR_IS_BY_VALUE = 908,
    CUDNN_ATTR_TENSOR_REORDERING_MODE = 909,
    CUDNN_ATTR_VARIANT_PACK_UNIQUE_IDS = 1000,
    CUDNN_ATTR_VARIANT_PACK_DATA_POINTERS = 1001,
    CUDNN_ATTR_VARIANT_PACK_INTERMEDIATES = 1002,
    CUDNN_ATTR_VARIANT_PACK_WORKSPACE = 1003,
    CUDNN_ATTR_LAYOUT_INFO_TENSOR_UID = 1100,
    CUDNN_ATTR_LAYOUT_INFO_TYPES = 1101,
    CUDNN_ATTR_KNOB_INFO_TYPE = 1200,
    CUDNN_ATTR_KNOB_INFO_MAXIMUM_VALUE = 1201,
    CUDNN_ATTR_KNOB_INFO_MINIMUM_VALUE = 1202,
    CUDNN_ATTR_KNOB_INFO_STRIDE = 1203,
    CUDNN_ATTR_ENGINE_OPERATION_GRAPH = 1300,
    CUDNN_ATTR_ENGINE_GLOBAL_INDEX = 1301,
    CUDNN_ATTR_ENGINE_KNOB_INFO = 1302,
    CUDNN_ATTR_ENGINE_NUMERICAL_NOTE = 1303,
    CUDNN_ATTR_ENGINE_LAYOUT_INFO = 1304,
    CUDNN_ATTR_ENGINE_BEHAVIOR_NOTE = 1305,
    CUDNN_ATTR_MATMUL_COMP_TYPE = 1500,
    CUDNN_ATTR_OPERATION_MATMUL_ADESC = 1520,
    CUDNN_ATTR_OPERATION_MATMUL_BDESC = 1521,
    CUDNN_ATTR_OPERATION_MATMUL_CDESC = 1522,
    CUDNN_ATTR_OPERATION_MATMUL_DESC = 1523,
    CUDNN_ATTR_OPERATION_MATMUL_IRREGULARLY_STRIDED_BATCH_COUNT = 1524,
    CUDNN_ATTR_OPERATION_MATMUL_GEMM_M_OVERRIDE_DESC = 1525,
    CUDNN_ATTR_OPERATION_MATMUL_GEMM_N_OVERRIDE_DESC = 1526,
    CUDNN_ATTR_OPERATION_MATMUL_GEMM_K_OVERRIDE_DESC = 1527,
    CUDNN_ATTR_REDUCTION_OPERATOR = 1600,
    CUDNN_ATTR_REDUCTION_COMP_TYPE = 1601,
    CUDNN_ATTR_OPERATION_REDUCTION_XDESC = 1610,
    CUDNN_ATTR_OPERATION_REDUCTION_YDESC = 1611,
    CUDNN_ATTR_OPERATION_REDUCTION_DESC = 1612,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_MATH_PREC = 1620,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_MEAN_DESC = 1621,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_INVSTD_DESC = 1622,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_BN_SCALE_DESC = 1623,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_X_DESC = 1624,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_DY_DESC = 1625,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_DBN_SCALE_DESC = 1626,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_DBN_BIAS_DESC = 1627,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_EQ_DY_SCALE_DESC = 1628,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_EQ_X_SCALE_DESC = 1629,
    CUDNN_ATTR_OPERATION_BN_BWD_WEIGHTS_EQ_BIAS = 1630,
    CUDNN_ATTR_RESAMPLE_MODE = 1700,
    CUDNN_ATTR_RESAMPLE_COMP_TYPE = 1701,
    CUDNN_ATTR_RESAMPLE_SPATIAL_DIMS = 1702,
    CUDNN_ATTR_RESAMPLE_POST_PADDINGS = 1703,
    CUDNN_ATTR_RESAMPLE_PRE_PADDINGS = 1704,
    CUDNN_ATTR_RESAMPLE_STRIDES = 1705,
    CUDNN_ATTR_RESAMPLE_WINDOW_DIMS = 1706,
    CUDNN_ATTR_RESAMPLE_NAN_PROPAGATION = 1707,
    CUDNN_ATTR_RESAMPLE_PADDING_MODE = 1708,
    CUDNN_ATTR_OPERATION_RESAMPLE_FWD_XDESC = 1710,
    CUDNN_ATTR_OPERATION_RESAMPLE_FWD_YDESC = 1711,
    CUDNN_ATTR_OPERATION_RESAMPLE_FWD_IDXDESC = 1712,
    CUDNN_ATTR_OPERATION_RESAMPLE_FWD_ALPHA = 1713,
    CUDNN_ATTR_OPERATION_RESAMPLE_FWD_BETA = 1714,
    CUDNN_ATTR_OPERATION_RESAMPLE_FWD_DESC = 1716,
    CUDNN_ATTR_OPERATION_RESAMPLE_BWD_DXDESC = 1720,
    CUDNN_ATTR_OPERATION_RESAMPLE_BWD_DYDESC = 1721,
    CUDNN_ATTR_OPERATION_RESAMPLE_BWD_IDXDESC = 1722,
    CUDNN_ATTR_OPERATION_RESAMPLE_BWD_ALPHA = 1723,
    CUDNN_ATTR_OPERATION_RESAMPLE_BWD_BETA = 1724,
    CUDNN_ATTR_OPERATION_RESAMPLE_BWD_DESC = 1725,
    CUDNN_ATTR_OPERATION_RESAMPLE_BWD_XDESC = 1726,
    CUDNN_ATTR_OPERATION_RESAMPLE_BWD_YDESC = 1727,
    CUDNN_ATTR_OPERATION_CONCAT_AXIS = 1800,
    CUDNN_ATTR_OPERATION_CONCAT_INPUT_DESCS = 1801,
    CUDNN_ATTR_OPERATION_CONCAT_INPLACE_INDEX = 1802,
    CUDNN_ATTR_OPERATION_CONCAT_OUTPUT_DESC = 1803,
    CUDNN_ATTR_OPERATION_SIGNAL_MODE = 1900,
    CUDNN_ATTR_OPERATION_SIGNAL_FLAGDESC = 1901,
    CUDNN_ATTR_OPERATION_SIGNAL_VALUE = 1902,
    CUDNN_ATTR_OPERATION_SIGNAL_XDESC = 1903,
    CUDNN_ATTR_OPERATION_SIGNAL_YDESC = 1904,
    CUDNN_ATTR_OPERATION_NORM_FWD_MODE = 2000,
    CUDNN_ATTR_OPERATION_NORM_FWD_PHASE = 2001,
    CUDNN_ATTR_OPERATION_NORM_FWD_XDESC = 2002,
    CUDNN_ATTR_OPERATION_NORM_FWD_MEAN_DESC = 2003,
    CUDNN_ATTR_OPERATION_NORM_FWD_INV_VARIANCE_DESC = 2004,
    CUDNN_ATTR_OPERATION_NORM_FWD_SCALE_DESC = 2005,
    CUDNN_ATTR_OPERATION_NORM_FWD_BIAS_DESC = 2006,
    CUDNN_ATTR_OPERATION_NORM_FWD_EPSILON_DESC = 2007,
    CUDNN_ATTR_OPERATION_NORM_FWD_EXP_AVG_FACTOR_DESC = 2008,
    CUDNN_ATTR_OPERATION_NORM_FWD_INPUT_RUNNING_MEAN_DESC = 2009,
    CUDNN_ATTR_OPERATION_NORM_FWD_INPUT_RUNNING_VAR_DESC = 2010,
    CUDNN_ATTR_OPERATION_NORM_FWD_OUTPUT_RUNNING_MEAN_DESC = 2011,
    CUDNN_ATTR_OPERATION_NORM_FWD_OUTPUT_RUNNING_VAR_DESC = 2012,
    CUDNN_ATTR_OPERATION_NORM_FWD_YDESC = 2013,
    CUDNN_ATTR_OPERATION_NORM_FWD_PEER_STAT_DESCS = 2014,
    CUDNN_ATTR_OPERATION_NORM_BWD_MODE = 2100,
    CUDNN_ATTR_OPERATION_NORM_BWD_XDESC = 2101,
    CUDNN_ATTR_OPERATION_NORM_BWD_MEAN_DESC = 2102,
    CUDNN_ATTR_OPERATION_NORM_BWD_INV_VARIANCE_DESC = 2103,
    CUDNN_ATTR_OPERATION_NORM_BWD_DYDESC = 2104,
    CUDNN_ATTR_OPERATION_NORM_BWD_SCALE_DESC = 2105,
    CUDNN_ATTR_OPERATION_NORM_BWD_EPSILON_DESC = 2106,
    CUDNN_ATTR_OPERATION_NORM_BWD_DSCALE_DESC = 2107,
    CUDNN_ATTR_OPERATION_NORM_BWD_DBIAS_DESC = 2108,
    CUDNN_ATTR_OPERATION_NORM_BWD_DXDESC = 2109,
    CUDNN_ATTR_OPERATION_NORM_BWD_PEER_STAT_DESCS = 2110,
    CUDNN_ATTR_OPERATION_RESHAPE_XDESC = 2200,
    CUDNN_ATTR_OPERATION_RESHAPE_YDESC = 2201,
    CUDNN_ATTR_RNG_DISTRIBUTION = 2300,
    CUDNN_ATTR_RNG_NORMAL_DIST_MEAN = 2301,
    CUDNN_ATTR_RNG_NORMAL_DIST_STANDARD_DEVIATION = 2302,
    CUDNN_ATTR_RNG_UNIFORM_DIST_MAXIMUM = 2303,
    CUDNN_ATTR_RNG_UNIFORM_DIST_MINIMUM = 2304,
    CUDNN_ATTR_RNG_BERNOULLI_DIST_PROBABILITY = 2305,
    CUDNN_ATTR_OPERATION_RNG_YDESC = 2310,
    CUDNN_ATTR_OPERATION_RNG_SEED = 2311,
    CUDNN_ATTR_OPERATION_RNG_DESC = 2312,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendAttributeType_t {
    CUDNN_TYPE_HANDLE = 0,
    CUDNN_TYPE_DATA_TYPE = 1,
    CUDNN_TYPE_BOOLEAN = 2,
    CUDNN_TYPE_INT64 = 3,
    CUDNN_TYPE_FLOAT = 4,
    CUDNN_TYPE_DOUBLE = 5,
    CUDNN_TYPE_VOID_PTR = 6,
    CUDNN_TYPE_CONVOLUTION_MODE = 7,
    CUDNN_TYPE_HEUR_MODE = 8,
    CUDNN_TYPE_KNOB_TYPE = 9,
    CUDNN_TYPE_NAN_PROPOGATION = 10,
    CUDNN_TYPE_NUMERICAL_NOTE = 11,
    CUDNN_TYPE_LAYOUT_TYPE = 12,
    CUDNN_TYPE_ATTRIB_NAME = 13,
    CUDNN_TYPE_POINTWISE_MODE = 14,
    CUDNN_TYPE_BACKEND_DESCRIPTOR = 15,
    CUDNN_TYPE_GENSTATS_MODE = 16,
    CUDNN_TYPE_BN_FINALIZE_STATS_MODE = 17,
    CUDNN_TYPE_REDUCTION_OPERATOR_TYPE = 18,
    CUDNN_TYPE_BEHAVIOR_NOTE = 19,
    CUDNN_TYPE_TENSOR_REORDERING_MODE = 20,
    CUDNN_TYPE_RESAMPLE_MODE = 21,
    CUDNN_TYPE_PADDING_MODE = 22,
    CUDNN_TYPE_INT32 = 23,
    CUDNN_TYPE_CHAR = 24,
    CUDNN_TYPE_SIGNAL_MODE = 25,
    CUDNN_TYPE_FRACTION = 26,
    CUDNN_TYPE_NORM_MODE = 27,
    CUDNN_TYPE_NORM_FWD_PHASE = 28,
    CUDNN_TYPE_RNG_DISTRIBUTION = 29,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendDescriptorType_t {
    CUDNN_BACKEND_POINTWISE_DESCRIPTOR = 0,
    CUDNN_BACKEND_CONVOLUTION_DESCRIPTOR = 1,
    CUDNN_BACKEND_ENGINE_DESCRIPTOR = 2,
    CUDNN_BACKEND_ENGINECFG_DESCRIPTOR = 3,
    CUDNN_BACKEND_ENGINEHEUR_DESCRIPTOR = 4,
    CUDNN_BACKEND_EXECUTION_PLAN_DESCRIPTOR = 5,
    CUDNN_BACKEND_INTERMEDIATE_INFO_DESCRIPTOR = 6,
    CUDNN_BACKEND_KNOB_CHOICE_DESCRIPTOR = 7,
    CUDNN_BACKEND_KNOB_INFO_DESCRIPTOR = 8,
    CUDNN_BACKEND_LAYOUT_INFO_DESCRIPTOR = 9,
    CUDNN_BACKEND_OPERATION_CONVOLUTION_FORWARD_DESCRIPTOR = 10,
    CUDNN_BACKEND_OPERATION_CONVOLUTION_BACKWARD_FILTER_DESCRIPTOR = 11,
    CUDNN_BACKEND_OPERATION_CONVOLUTION_BACKWARD_DATA_DESCRIPTOR = 12,
    CUDNN_BACKEND_OPERATION_POINTWISE_DESCRIPTOR = 13,
    CUDNN_BACKEND_OPERATION_GEN_STATS_DESCRIPTOR = 14,
    CUDNN_BACKEND_OPERATIONGRAPH_DESCRIPTOR = 15,
    CUDNN_BACKEND_VARIANT_PACK_DESCRIPTOR = 16,
    CUDNN_BACKEND_TENSOR_DESCRIPTOR = 17,
    CUDNN_BACKEND_MATMUL_DESCRIPTOR = 18,
    CUDNN_BACKEND_OPERATION_MATMUL_DESCRIPTOR = 19,
    CUDNN_BACKEND_OPERATION_BN_FINALIZE_STATISTICS_DESCRIPTOR = 20,
    CUDNN_BACKEND_REDUCTION_DESCRIPTOR = 21,
    CUDNN_BACKEND_OPERATION_REDUCTION_DESCRIPTOR = 22,
    CUDNN_BACKEND_OPERATION_BN_BWD_WEIGHTS_DESCRIPTOR = 23,
    CUDNN_BACKEND_RESAMPLE_DESCRIPTOR = 24,
    CUDNN_BACKEND_OPERATION_RESAMPLE_FWD_DESCRIPTOR = 25,
    CUDNN_BACKEND_OPERATION_RESAMPLE_BWD_DESCRIPTOR = 26,
    CUDNN_BACKEND_OPERATION_CONCAT_DESCRIPTOR = 27,
    CUDNN_BACKEND_OPERATION_SIGNAL_DESCRIPTOR = 28,
    CUDNN_BACKEND_OPERATION_NORM_FORWARD_DESCRIPTOR = 29,
    CUDNN_BACKEND_OPERATION_NORM_BACKWARD_DESCRIPTOR = 30,
    CUDNN_BACKEND_OPERATION_RESHAPE_DESCRIPTOR = 31,
    CUDNN_BACKEND_RNG_DESCRIPTOR = 32,
    CUDNN_BACKEND_OPERATION_RNG_DESCRIPTOR = 33,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendNumericalNote_t {
    CUDNN_NUMERICAL_NOTE_TENSOR_CORE = 0,
    CUDNN_NUMERICAL_NOTE_DOWN_CONVERT_INPUTS = 1,
    CUDNN_NUMERICAL_NOTE_REDUCED_PRECISION_REDUCTION = 2,
    CUDNN_NUMERICAL_NOTE_FFT = 3,
    CUDNN_NUMERICAL_NOTE_NONDETERMINISTIC = 4,
    CUDNN_NUMERICAL_NOTE_WINOGRAD = 5,
    CUDNN_NUMERICAL_NOTE_WINOGRAD_TILE_4x4 = 6,
    CUDNN_NUMERICAL_NOTE_WINOGRAD_TILE_6x6 = 7,
    CUDNN_NUMERICAL_NOTE_WINOGRAD_TILE_13x13 = 8,
    CUDNN_NUMERICAL_NOTE_TYPE_COUNT = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendBehaviorNote_t {
    CUDNN_BEHAVIOR_NOTE_RUNTIME_COMPILATION = 0,
    CUDNN_BEHAVIOR_NOTE_REQUIRES_FILTER_INT8x32_REORDER = 1,
    CUDNN_BEHAVIOR_NOTE_REQUIRES_BIAS_INT8x32_REORDER = 2,
    CUDNN_BEHAVIOR_NOTE_TYPE_COUNT = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendKnobType_t {
    CUDNN_KNOB_TYPE_SPLIT_K = 0,
    CUDNN_KNOB_TYPE_SWIZZLE = 1,
    CUDNN_KNOB_TYPE_TILE_SIZE = 2,
    CUDNN_KNOB_TYPE_USE_TEX = 3,
    CUDNN_KNOB_TYPE_EDGE = 4,
    CUDNN_KNOB_TYPE_KBLOCK = 5,
    CUDNN_KNOB_TYPE_LDGA = 6,
    CUDNN_KNOB_TYPE_LDGB = 7,
    CUDNN_KNOB_TYPE_CHUNK_K = 8,
    CUDNN_KNOB_TYPE_SPLIT_H = 9,
    CUDNN_KNOB_TYPE_WINO_TILE = 10,
    CUDNN_KNOB_TYPE_MULTIPLY = 11,
    CUDNN_KNOB_TYPE_SPLIT_K_BUF = 12,
    CUDNN_KNOB_TYPE_TILEK = 13,
    CUDNN_KNOB_TYPE_STAGES = 14,
    CUDNN_KNOB_TYPE_REDUCTION_MODE = 15,
    CUDNN_KNOB_TYPE_CTA_SPLIT_K_MODE = 16,
    CUDNN_KNOB_TYPE_SPLIT_K_SLC = 17,
    CUDNN_KNOB_TYPE_IDX_MODE = 18,
    CUDNN_KNOB_TYPE_SLICED = 19,
    CUDNN_KNOB_TYPE_SPLIT_RS = 20,
    CUDNN_KNOB_TYPE_SINGLEBUFFER = 21,
    CUDNN_KNOB_TYPE_LDGC = 22,
    CUDNN_KNOB_TYPE_SPECFILT = 23,
    CUDNN_KNOB_TYPE_KERNEL_CFG = 24,
    CUDNN_KNOB_TYPE_WORKSPACE = 25,
    CUDNN_KNOB_TYPE_TILE_CGA = 26,
    CUDNN_KNOB_TYPE_TILE_CGA_M = 27,
    CUDNN_KNOB_TYPE_TILE_CGA_N = 28,
    CUDNN_KNOB_TYPE_COUNTS = 29,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendLayoutType_t {
    CUDNN_LAYOUT_TYPE_PREFERRED_NCHW = 0,
    CUDNN_LAYOUT_TYPE_PREFERRED_NHWC = 1,
    CUDNN_LAYOUT_TYPE_PREFERRED_PAD4CK = 2,
    CUDNN_LAYOUT_TYPE_PREFERRED_PAD8CK = 3,
    CUDNN_LAYOUT_TYPE_COUNT = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendHeurMode_t {
    CUDNN_HEUR_MODE_INSTANT = 0,
    CUDNN_HEUR_MODE_B = 1,
    CUDNN_HEUR_MODE_FALLBACK = 2,
    CUDNN_HEUR_MODE_A = 3,
    CUDNN_HEUR_MODES_COUNT = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendTensorReordering_t {
    CUDNN_TENSOR_REORDERING_NONE = 0,
    CUDNN_TENSOR_REORDERING_INT8x32 = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnPaddingMode_t {
    CUDNN_ZERO_PAD = 0,
    CUDNN_NEG_INF_PAD = 1,
    CUDNN_EDGE_VAL_PAD = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendNormMode_t {
    CUDNN_LAYER_NORM = 0,
    CUDNN_INSTANCE_NORM = 1,
    CUDNN_BATCH_NORM = 2,
    CUDNN_GROUP_NORM = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudnnBackendNormFwdPhase_t {
    CUDNN_NORM_FWD_INFERENCE = 0,
    CUDNN_NORM_FWD_TRAINING = 1,
}
extern "C" {
    pub fn cudnnBackendCreateDescriptor(
        descriptorType: cudnnBackendDescriptorType_t,
        descriptor: *mut cudnnBackendDescriptor_t,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBackendDestroyDescriptor(descriptor: cudnnBackendDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBackendInitialize(descriptor: cudnnBackendDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBackendFinalize(descriptor: cudnnBackendDescriptor_t) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBackendSetAttribute(
        descriptor: cudnnBackendDescriptor_t,
        attributeName: cudnnBackendAttributeName_t,
        attributeType: cudnnBackendAttributeType_t,
        elementCount: i64,
        arrayOfElements: *const ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBackendGetAttribute(
        descriptor: cudnnBackendDescriptor_t,
        attributeName: cudnnBackendAttributeName_t,
        attributeType: cudnnBackendAttributeType_t,
        requestedElementCount: i64,
        elementCount: *mut i64,
        arrayOfElements: *mut ::libc::c_void,
    ) -> cudnnStatus_t;
}
extern "C" {
    pub fn cudnnBackendExecute(
        handle: cudnnHandle_t,
        executionPlan: cudnnBackendDescriptor_t,
        variantPack: cudnnBackendDescriptor_t,
    ) -> cudnnStatus_t;
}
