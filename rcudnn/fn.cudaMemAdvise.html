<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="\brief Advise about the usage of a given memory range"><meta name="keywords" content="rust, rustlang, rust-lang, cudaMemAdvise"><title>cudaMemAdvise in rcudnn - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../rcudnn/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../rcudnn/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><div class="sidebar-elems"><h2 class="location"><a href="index.html">In rcudnn</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../rcudnn/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Function <a href="index.html">rcudnn</a>::<wbr><a class="fn" href="#">cudaMemAdvise</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/rcudnn_sys/generated.rs.html#13265-13270">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust fn"><code>pub unsafe extern &quot;C&quot; fn cudaMemAdvise(<br>&nbsp;&nbsp;&nbsp;&nbsp;devPtr: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.pointer.html">*const </a><a class="enum" href="https://doc.rust-lang.org/1.63.0/core/ffi/enum.c_void.html" title="enum core::ffi::c_void">c_void</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;count: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;advice: <a class="enum" href="enum.cudaMemoryAdvise.html" title="enum rcudnn::cudaMemoryAdvise">cudaMemoryAdvise</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;device: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.i32.html">i32</a><br>) -&gt; <a class="enum" href="enum.cudaError_t.html" title="enum rcudnn::cudaError_t">cudaError</a></code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>\brief Advise about the usage of a given memory range</p>
<p>Advise the Unified Memory subsystem about the usage pattern for the memory range
starting at \p devPtr with a size of \p count bytes. The start address and end address of the memory
range will be rounded down and rounded up respectively to be aligned to CPU page size before the
advice is applied. The memory range must refer to managed memory allocated via ::cudaMallocManaged
or declared via <strong>managed</strong> variables. The memory range could also refer to system-allocated pageable
memory provided it represents a valid, host-accessible region of memory and all additional constraints
imposed by \p advice as outlined below are also satisfied. Specifying an invalid system-allocated pageable
memory range results in an error being returned.</p>
<p>The \p advice parameter can take the following values:</p>
<ul>
<li>
<p>::cudaMemAdviseSetReadMostly: This implies that the data is mostly going to be read
from and only occasionally written to. Any read accesses from any processor to this region will create a
read-only copy of at least the accessed pages in that processor’s memory. Additionally, if ::cudaMemPrefetchAsync
is called on this region, it will create a read-only copy of the data on the destination processor.
If any processor writes to this region, all copies of the corresponding page will be invalidated
except for the one where the write occurred. The \p device argument is ignored for this advice.
Note that for a page to be read-duplicated, the accessing processor must either be the CPU or a GPU
that has a non-zero value for the device attribute ::cudaDevAttrConcurrentManagedAccess.
Also, if a context is created on a device that does not have the device attribute
::cudaDevAttrConcurrentManagedAccess set, then read-duplication will not occur until
all such contexts are destroyed.
If the memory region refers to valid system-allocated pageable memory, then the accessing device must
have a non-zero value for the device attribute ::cudaDevAttrPageableMemoryAccess for a read-only
copy to be created on that device. Note however that if the accessing device also has a non-zero value for the
device attribute ::cudaDevAttrPageableMemoryAccessUsesHostPageTables, then setting this advice
will not create a read-only copy when that device accesses this memory region.</p>
</li>
<li>
<p>::cudaMemAdviceUnsetReadMostly: Undoes the effect of ::cudaMemAdviceReadMostly and also prevents the
Unified Memory driver from attempting heuristic read-duplication on the memory range. Any read-duplicated
copies of the data will be collapsed into a single copy. The location for the collapsed
copy will be the preferred location if the page has a preferred location and one of the read-duplicated
copies was resident at that location. Otherwise, the location chosen is arbitrary.</p>
</li>
<li>
<p>::cudaMemAdviseSetPreferredLocation: This advice sets the preferred location for the
data to be the memory belonging to \p device. Passing in cudaCpuDeviceId for \p device sets the
preferred location as host memory. If \p device is a GPU, then it must have a non-zero value for the
device attribute ::cudaDevAttrConcurrentManagedAccess. Setting the preferred location
does not cause data to migrate to that location immediately. Instead, it guides the migration policy
when a fault occurs on that memory region. If the data is already in its preferred location and the
faulting processor can establish a mapping without requiring the data to be migrated, then
data migration will be avoided. On the other hand, if the data is not in its preferred location
or if a direct mapping cannot be established, then it will be migrated to the processor accessing
it. It is important to note that setting the preferred location does not prevent data prefetching
done using ::cudaMemPrefetchAsync.
Having a preferred location can override the page thrash detection and resolution logic in the Unified
Memory driver. Normally, if a page is detected to be constantly thrashing between for example host and device
memory, the page may eventually be pinned to host memory by the Unified Memory driver. But
if the preferred location is set as device memory, then the page will continue to thrash indefinitely.
If ::cudaMemAdviseSetReadMostly is also set on this memory region or any subset of it, then the
policies associated with that advice will override the policies of this advice, unless read accesses from
\p device will not result in a read-only copy being created on that device as outlined in description for
the advice ::cudaMemAdviseSetReadMostly.
If the memory region refers to valid system-allocated pageable memory, then \p device must have a non-zero
value for the device attribute ::cudaDevAttrPageableMemoryAccess. Additionally, if \p device has
a non-zero value for the device attribute ::cudaDevAttrPageableMemoryAccessUsesHostPageTables,
then this call has no effect. Note however that this behavior may change in the future.</p>
</li>
<li>
<p>::cudaMemAdviseUnsetPreferredLocation: Undoes the effect of ::cudaMemAdviseSetPreferredLocation
and changes the preferred location to none.</p>
</li>
<li>
<p>::cudaMemAdviseSetAccessedBy: This advice implies that the data will be accessed by \p device.
Passing in ::cudaCpuDeviceId for \p device will set the advice for the CPU. If \p device is a GPU, then
the device attribute ::cudaDevAttrConcurrentManagedAccess must be non-zero.
This advice does not cause data migration and has no impact on the location of the data per se. Instead,
it causes the data to always be mapped in the specified processor’s page tables, as long as the
location of the data permits a mapping to be established. If the data gets migrated for any reason,
the mappings are updated accordingly.
This advice is recommended in scenarios where data locality is not important, but avoiding faults is.
Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the
data located on one GPU is occasionally accessed by peer GPUs. In such scenarios, migrating data
over to the other GPUs is not as important because the accesses are infrequent and the overhead of
migration may be too high. But preventing faults can still help improve performance, and so having
a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated
to host memory because the CPU typically cannot access device memory directly. Any GPU that had the
::cudaMemAdviceSetAccessedBy flag set for this data will now have its mapping updated to point to the
page in host memory.
If ::cudaMemAdviseSetReadMostly is also set on this memory region or any subset of it, then the
policies associated with that advice will override the policies of this advice. Additionally, if the
preferred location of this memory region or any subset of it is also \p device, then the policies
associated with ::cudaMemAdviseSetPreferredLocation will override the policies of this advice.
If the memory region refers to valid system-allocated pageable memory, then \p device must have a non-zero
value for the device attribute ::cudaDevAttrPageableMemoryAccess. Additionally, if \p device has
a non-zero value for the device attribute ::cudaDevAttrPageableMemoryAccessUsesHostPageTables,
then this call has no effect.</p>
</li>
<li>
<p>::cudaMemAdviseUnsetAccessedBy: Undoes the effect of ::cudaMemAdviseSetAccessedBy. Any mappings to
the data from \p device may be removed at any time causing accesses to result in non-fatal page faults.
If the memory region refers to valid system-allocated pageable memory, then \p device must have a non-zero
value for the device attribute ::cudaDevAttrPageableMemoryAccess. Additionally, if \p device has
a non-zero value for the device attribute ::cudaDevAttrPageableMemoryAccessUsesHostPageTables,
then this call has no effect.</p>
</li>
</ul>
<p>\param devPtr - Pointer to memory to set the advice for
\param count  - Size in bytes of the memory range
\param advice - Advice to be applied for the specified memory range
\param device - Device to apply the advice for</p>
<p>\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorInvalidDevice
\notefnerr
\note_async
\note_null_stream
\note_init_rt
\note_callback</p>
<p>\sa ::cudaMemcpy, ::cudaMemcpyPeer, ::cudaMemcpyAsync,
::cudaMemcpy3DPeerAsync, ::cudaMemPrefetchAsync,
::cuMemAdvise</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="rcudnn" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>