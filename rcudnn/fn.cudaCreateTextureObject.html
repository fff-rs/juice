<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `cudaCreateTextureObject` fn in crate `rcudnn`."><meta name="keywords" content="rust, rustlang, rust-lang, cudaCreateTextureObject"><title>rcudnn::cudaCreateTextureObject - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc fn"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../rcudnn/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class='location'><a href='index.html'>rcudnn</a></p><script>window.sidebarCurrent = {name: 'cudaCreateTextureObject', ty: 'fn', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/rcudnn_sys/generated.rs.html#13304-13309' title='goto source code'>[src]</a></span><span class='in-band'>Function <a href='index.html'>rcudnn</a>::<wbr><a class="fn" href=''>cudaCreateTextureObject</a></span></h1><pre class='rust fn'>pub unsafe extern &quot;C&quot; fn cudaCreateTextureObject(<br>&nbsp;&nbsp;&nbsp;&nbsp;pTexObject: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;pResDesc: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="struct" href="../rcudnn/struct.cudaResourceDesc.html" title="struct rcudnn::cudaResourceDesc">cudaResourceDesc</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;pTexDesc: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="struct" href="../rcudnn/struct.cudaTextureDesc.html" title="struct rcudnn::cudaTextureDesc">cudaTextureDesc</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;pResViewDesc: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="struct" href="../rcudnn/struct.cudaResourceViewDesc.html" title="struct rcudnn::cudaResourceViewDesc">cudaResourceViewDesc</a><br>) -&gt; <a class="enum" href="../rcudnn/enum.cudaError.html" title="enum rcudnn::cudaError">cudaError</a></pre><div class='docblock'><p>\brief Creates a texture object</p>
<p>Creates a texture object and returns it in \p pTexObject. \p pResDesc describes
the data to texture from. \p pTexDesc describes how the data should be sampled.
\p pResViewDesc is an optional argument that specifies an alternate format for
the data described by \p pResDesc, and also describes the subresource region
to restrict access to when texturing. \p pResViewDesc can only be specified if
the type of resource is a CUDA array or a CUDA mipmapped array.</p>
<p>Texture objects are only supported on devices of compute capability 3.0 or higher.
Additionally, a texture object is an opaque value, and, as such, should only be
accessed through CUDA API calls.</p>
<p>The ::cudaResourceDesc structure is defined as:
\code
struct cudaResourceDesc {
enum cudaResourceType resType;</p>
<p>union {
struct {
cudaArray_t array;
} array;
struct {
cudaMipmappedArray_t mipmap;
} mipmap;
struct {
void *devPtr;
struct cudaChannelFormatDesc desc;
size_t sizeInBytes;
} linear;
struct {
void *devPtr;
struct cudaChannelFormatDesc desc;
size_t width;
size_t height;
size_t pitchInBytes;
} pitch2D;
} res;
};
\endcode
where:</p>
<ul>
<li>::cudaResourceDesc::resType specifies the type of resource to texture from.
CUresourceType is defined as:
\code
enum cudaResourceType {
cudaResourceTypeArray          = 0x00,
cudaResourceTypeMipmappedArray = 0x01,
cudaResourceTypeLinear         = 0x02,
cudaResourceTypePitch2D        = 0x03
};
\endcode</li>
</ul>
<p>\par
If ::cudaResourceDesc::resType is set to ::cudaResourceTypeArray, ::cudaResourceDesc::res::array::array
must be set to a valid CUDA array handle.</p>
<p>\par
If ::cudaResourceDesc::resType is set to ::cudaResourceTypeMipmappedArray, ::cudaResourceDesc::res::mipmap::mipmap
must be set to a valid CUDA mipmapped array handle and ::cudaTextureDesc::normalizedCoords must be set to true.</p>
<p>\par
If ::cudaResourceDesc::resType is set to ::cudaResourceTypeLinear, ::cudaResourceDesc::res::linear::devPtr
must be set to a valid device pointer, that is aligned to ::cudaDeviceProp::textureAlignment.
::cudaResourceDesc::res::linear::desc describes the format and the number of components per array element. ::cudaResourceDesc::res::linear::sizeInBytes
specifies the size of the array in bytes. The total number of elements in the linear address range cannot exceed
::cudaDeviceProp::maxTexture1DLinear. The number of elements is computed as (sizeInBytes / sizeof(desc)).</p>
<p>\par
If ::cudaResourceDesc::resType is set to ::cudaResourceTypePitch2D, ::cudaResourceDesc::res::pitch2D::devPtr
must be set to a valid device pointer, that is aligned to ::cudaDeviceProp::textureAlignment.
::cudaResourceDesc::res::pitch2D::desc describes the format and the number of components per array element. ::cudaResourceDesc::res::pitch2D::width
and ::cudaResourceDesc::res::pitch2D::height specify the width and height of the array in elements, and cannot exceed
::cudaDeviceProp::maxTexture2DLinear[0] and ::cudaDeviceProp::maxTexture2DLinear[1] respectively.
::cudaResourceDesc::res::pitch2D::pitchInBytes specifies the pitch between two rows in bytes and has to be aligned to
::cudaDeviceProp::texturePitchAlignment. Pitch cannot exceed ::cudaDeviceProp::maxTexture2DLinear[2].</p>
<p>The ::cudaTextureDesc struct is defined as
\code
struct cudaTextureDesc {
enum cudaTextureAddressMode addressMode[3];
enum cudaTextureFilterMode  filterMode;
enum cudaTextureReadMode    readMode;
int                         sRGB;
float                       borderColor[4];
int                         normalizedCoords;
unsigned int                maxAnisotropy;
enum cudaTextureFilterMode  mipmapFilterMode;
float                       mipmapLevelBias;
float                       minMipmapLevelClamp;
float                       maxMipmapLevelClamp;
};
\endcode
where</p>
<ul>
<li>
<p>::cudaTextureDesc::addressMode specifies the addressing mode for each dimension of the texture data. ::cudaTextureAddressMode is defined as:
\code
enum cudaTextureAddressMode {
cudaAddressModeWrap   = 0,
cudaAddressModeClamp  = 1,
cudaAddressModeMirror = 2,
cudaAddressModeBorder = 3
};
\endcode
This is ignored if ::cudaResourceDesc::resType is ::cudaResourceTypeLinear. Also, if ::cudaTextureDesc::normalizedCoords
is set to zero, ::cudaAddressModeWrap and ::cudaAddressModeMirror won't be supported and will be switched to ::cudaAddressModeClamp.</p>
</li>
<li>
<p>::cudaTextureDesc::filterMode specifies the filtering mode to be used when fetching from the texture. ::cudaTextureFilterMode is defined as:
\code
enum cudaTextureFilterMode {
cudaFilterModePoint  = 0,
cudaFilterModeLinear = 1
};
\endcode
This is ignored if ::cudaResourceDesc::resType is ::cudaResourceTypeLinear.</p>
</li>
<li>
<p>::cudaTextureDesc::readMode specifies whether integer data should be converted to floating point or not. ::cudaTextureReadMode is defined as:
\code
enum cudaTextureReadMode {
cudaReadModeElementType     = 0,
cudaReadModeNormalizedFloat = 1
};
\endcode
Note that this applies only to 8-bit and 16-bit integer formats. 32-bit integer format would not be promoted, regardless of
whether or not this ::cudaTextureDesc::readMode is set ::cudaReadModeNormalizedFloat is specified.</p>
</li>
<li>
<p>::cudaTextureDesc::sRGB specifies whether sRGB to linear conversion should be performed during texture fetch.</p>
</li>
<li>
<p>::cudaTextureDesc::borderColor specifies the float values of color. where:
::cudaTextureDesc::borderColor[0] contains value of 'R',
::cudaTextureDesc::borderColor[1] contains value of 'G',
::cudaTextureDesc::borderColor[2] contains value of 'B',
::cudaTextureDesc::borderColor[3] contains value of 'A'
Note that application using integer border color values will need to &lt;reinterpret_cast&gt; these values to float.
The values are set only when the addressing mode specified by ::cudaTextureDesc::addressMode is cudaAddressModeBorder.</p>
</li>
<li>
<p>::cudaTextureDesc::normalizedCoords specifies whether the texture coordinates will be normalized or not.</p>
</li>
<li>
<p>::cudaTextureDesc::maxAnisotropy specifies the maximum anistropy ratio to be used when doing anisotropic filtering. This value will be
clamped to the range [1,16].</p>
</li>
<li>
<p>::cudaTextureDesc::mipmapFilterMode specifies the filter mode when the calculated mipmap level lies between two defined mipmap levels.</p>
</li>
<li>
<p>::cudaTextureDesc::mipmapLevelBias specifies the offset to be applied to the calculated mipmap level.</p>
</li>
<li>
<p>::cudaTextureDesc::minMipmapLevelClamp specifies the lower end of the mipmap level range to clamp access to.</p>
</li>
<li>
<p>::cudaTextureDesc::maxMipmapLevelClamp specifies the upper end of the mipmap level range to clamp access to.</p>
</li>
</ul>
<p>The ::cudaResourceViewDesc struct is defined as
\code
struct cudaResourceViewDesc {
enum cudaResourceViewFormat format;
size_t                      width;
size_t                      height;
size_t                      depth;
unsigned int                firstMipmapLevel;
unsigned int                lastMipmapLevel;
unsigned int                firstLayer;
unsigned int                lastLayer;
};
\endcode
where:</p>
<ul>
<li>
<p>::cudaResourceViewDesc::format specifies how the data contained in the CUDA array or CUDA mipmapped array should
be interpreted. Note that this can incur a change in size of the texture data. If the resource view format is a block
compressed format, then the underlying CUDA array or CUDA mipmapped array has to have a 32-bit unsigned integer format
with 2 or 4 channels, depending on the block compressed format. For ex., BC1 and BC4 require the underlying CUDA array to have
a 32-bit unsigned int with 2 channels. The other BC formats require the underlying resource to have the same 32-bit unsigned int
format but with 4 channels.</p>
</li>
<li>
<p>::cudaResourceViewDesc::width specifies the new width of the texture data. If the resource view format is a block
compressed format, this value has to be 4 times the original width of the resource. For non block compressed formats,
this value has to be equal to that of the original resource.</p>
</li>
<li>
<p>::cudaResourceViewDesc::height specifies the new height of the texture data. If the resource view format is a block
compressed format, this value has to be 4 times the original height of the resource. For non block compressed formats,
this value has to be equal to that of the original resource.</p>
</li>
<li>
<p>::cudaResourceViewDesc::depth specifies the new depth of the texture data. This value has to be equal to that of the
original resource.</p>
</li>
<li>
<p>::cudaResourceViewDesc::firstMipmapLevel specifies the most detailed mipmap level. This will be the new mipmap level zero.
For non-mipmapped resources, this value has to be zero.::cudaTextureDesc::minMipmapLevelClamp and ::cudaTextureDesc::maxMipmapLevelClamp
will be relative to this value. For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp of 1.2 is specified,
then the actual minimum mipmap level clamp will be 3.2.</p>
</li>
<li>
<p>::cudaResourceViewDesc::lastMipmapLevel specifies the least detailed mipmap level. For non-mipmapped resources, this value
has to be zero.</p>
</li>
<li>
<p>::cudaResourceViewDesc::firstLayer specifies the first layer index for layered textures. This will be the new layer zero.
For non-layered resources, this value has to be zero.</p>
</li>
<li>
<p>::cudaResourceViewDesc::lastLayer specifies the last layer index for layered textures. For non-layered resources,
this value has to be zero.</p>
</li>
</ul>
<p>\param pTexObject   - Texture object to create
\param pResDesc     - Resource descriptor
\param pTexDesc     - Texture descriptor
\param pResViewDesc - Resource view descriptor</p>
<p>\return
::cudaSuccess,
::cudaErrorInvalidValue
\note_init_rt
\note_callback</p>
<p>\sa
::cudaDestroyTextureObject,
::cuTexObjectCreate</p>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "rcudnn";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>