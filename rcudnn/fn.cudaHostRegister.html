<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="\brief Registers an existing host memory range for use by CUDA"><meta name="keywords" content="rust, rustlang, rust-lang, cudaHostRegister"><title>cudaHostRegister in rcudnn - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../rcudnn/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../rcudnn/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><div class="sidebar-elems"><h2 class="location"><a href="index.html">In rcudnn</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../rcudnn/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Function <a href="index.html">rcudnn</a>::<wbr><a class="fn" href="#">cudaHostRegister</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/rcudnn_sys/generated.rs.html#11088-11092">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust fn"><code>pub unsafe extern &quot;C&quot; fn cudaHostRegister(<br>&nbsp;&nbsp;&nbsp;&nbsp;ptr: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.pointer.html">*mut </a><a class="enum" href="https://doc.rust-lang.org/1.63.0/core/ffi/enum.c_void.html" title="enum core::ffi::c_void">c_void</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;flags: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.u32.html">u32</a><br>) -&gt; <a class="enum" href="enum.cudaError_t.html" title="enum rcudnn::cudaError_t">cudaError</a></code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>\brief Registers an existing host memory range for use by CUDA</p>
<p>Page-locks the memory range specified by \p ptr and \p size and maps it
for the device(s) as specified by \p flags. This memory range also is added
to the same tracking mechanism as ::cudaHostAlloc() to automatically accelerate
calls to functions such as ::cudaMemcpy(). Since the memory can be accessed
directly by the device, it can be read or written with much higher bandwidth
than pageable memory that has not been registered.  Page-locking excessive
amounts of memory may degrade system performance, since it reduces the amount
of memory available to the system for paging. As a result, this function is
best used sparingly to register staging areas for data exchange between
host and device.</p>
<p>::cudaHostRegister is supported only on I/O coherent devices that have a non-zero
value for the device attribute ::cudaDevAttrHostRegisterSupported.</p>
<p>The \p flags parameter enables different options to be specified that
affect the allocation, as follows.</p>
<ul>
<li>
<p>::cudaHostRegisterDefault: On a system with unified virtual addressing,
the memory will be both mapped and portable.  On a system with no unified
virtual addressing, the memory will be neither mapped nor portable.</p>
</li>
<li>
<p>::cudaHostRegisterPortable: The memory returned by this call will be
considered as pinned memory by all CUDA contexts, not just the one that
performed the allocation.</p>
</li>
<li>
<p>::cudaHostRegisterMapped: Maps the allocation into the CUDA address
space. The device pointer to the memory may be obtained by calling
::cudaHostGetDevicePointer().</p>
</li>
<li>
<p>::cudaHostRegisterIoMemory: The passed memory pointer is treated as
pointing to some memory-mapped I/O space, e.g. belonging to a
third-party PCIe device, and it will marked as non cache-coherent and
contiguous.</p>
</li>
<li>
<p>::cudaHostRegisterReadOnly: The passed memory pointer is treated as
pointing to memory that is considered read-only by the device.  On
platforms without ::cudaDevAttrPageableMemoryAccessUsesHostPageTables, this
flag is required in order to register memory mapped to the CPU as
read-only.  Support for the use of this flag can be queried from the device
attribute cudaDeviceAttrReadOnlyHostRegisterSupported.  Using this flag with
a current context associated with a device that does not have this attribute
set will cause ::cudaHostRegister to error with cudaErrorNotSupported.</p>
</li>
</ul>
<p>All of these flags are orthogonal to one another: a developer may page-lock
memory that is portable or mapped with no restrictions.</p>
<p>The CUDA context must have been created with the ::cudaMapHost flag in
order for the ::cudaHostRegisterMapped flag to have any effect.</p>
<p>The ::cudaHostRegisterMapped flag may be specified on CUDA contexts for
devices that do not support mapped pinned memory. The failure is deferred
to ::cudaHostGetDevicePointer() because the memory may be mapped into
other CUDA contexts via the ::cudaHostRegisterPortable flag.</p>
<p>For devices that have a non-zero value for the device attribute
::cudaDevAttrCanUseHostPointerForRegisteredMem, the memory
can also be accessed from the device using the host pointer \p ptr.
The device pointer returned by ::cudaHostGetDevicePointer() may or may not
match the original host pointer \p ptr and depends on the devices visible to the
application. If all devices visible to the application have a non-zero value for the
device attribute, the device pointer returned by ::cudaHostGetDevicePointer()
will match the original pointer \p ptr. If any device visible to the application
has a zero value for the device attribute, the device pointer returned by
::cudaHostGetDevicePointer() will not match the original host pointer \p ptr,
but it will be suitable for use on all devices provided Unified Virtual Addressing
is enabled. In such systems, it is valid to access the memory using either pointer
on devices that have a non-zero value for the device attribute. Note however that
such devices should access the memory using only of the two pointers and not both.</p>
<p>The memory page-locked by this function must be unregistered with ::cudaHostUnregister().</p>
<p>\param ptr   - Host pointer to memory to page-lock
\param size  - Size in bytes of the address range to page-lock in bytes
\param flags - Flags for allocation request</p>
<p>\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorMemoryAllocation,
::cudaErrorHostMemoryAlreadyRegistered,
::cudaErrorNotSupported
\notefnerr
\note_init_rt
\note_callback</p>
<p>\sa ::cudaHostUnregister, ::cudaHostGetFlags, ::cudaHostGetDevicePointer,
::cuMemHostRegister</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="rcudnn" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>