<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `cudaMallocMipmappedArray` fn in crate `rcudnn`."><meta name="keywords" content="rust, rustlang, rust-lang, cudaMallocMipmappedArray"><title>rcudnn::cudaMallocMipmappedArray - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc fn"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../rcudnn/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class='location'><a href='index.html'>rcudnn</a></p><script>window.sidebarCurrent = {name: 'cudaMallocMipmappedArray', ty: 'fn', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/rcudnn_sys/generated.rs.html#10185-10191' title='goto source code'>[src]</a></span><span class='in-band'>Function <a href='index.html'>rcudnn</a>::<wbr><a class="fn" href=''>cudaMallocMipmappedArray</a></span></h1><pre class='rust fn'>pub unsafe extern &quot;C&quot; fn cudaMallocMipmappedArray(<br>&nbsp;&nbsp;&nbsp;&nbsp;mipmappedArray: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="struct" href="../rcudnn/struct.cudaMipmappedArray.html" title="struct rcudnn::cudaMipmappedArray">cudaMipmappedArray</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;desc: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="struct" href="../rcudnn/struct.cudaChannelFormatDesc.html" title="struct rcudnn::cudaChannelFormatDesc">cudaChannelFormatDesc</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;extent: <a class="struct" href="../rcudnn/struct.cudaExtent.html" title="struct rcudnn::cudaExtent">cudaExtent</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;numLevels: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;flags: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a><br>) -&gt; <a class="enum" href="../rcudnn/enum.cudaError_t.html" title="enum rcudnn::cudaError_t">cudaError</a></pre><div class='docblock'><p>\brief Allocate a mipmapped array on the device</p>
<p>Allocates a CUDA mipmapped array according to the ::cudaChannelFormatDesc structure
\p desc and returns a handle to the new CUDA mipmapped array in \p *mipmappedArray.
\p numLevels specifies the number of mipmap levels to be allocated. This value is
clamped to the range [1, 1 + floor(log2(max(width, height, depth)))].</p>
<p>The ::cudaChannelFormatDesc is defined as:
\code
struct cudaChannelFormatDesc {
int x, y, z, w;
enum cudaChannelFormatKind f;
};
\endcode
where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,
::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.</p>
<p>::cudaMallocMipmappedArray() can allocate the following:</p>
<ul>
<li>A 1D mipmapped array is allocated if the height and depth extents are both zero.</li>
<li>A 2D mipmapped array is allocated if only the depth extent is zero.</li>
<li>A 3D mipmapped array is allocated if all three extents are non-zero.</li>
<li>A 1D layered CUDA mipmapped array is allocated if only the height extent is zero and
the cudaArrayLayered flag is set. Each layer is a 1D mipmapped array. The number of layers is
determined by the depth extent.</li>
<li>A 2D layered CUDA mipmapped array is allocated if all three extents are non-zero and
the cudaArrayLayered flag is set. Each layer is a 2D mipmapped array. The number of layers is
determined by the depth extent.</li>
<li>A cubemap CUDA mipmapped array is allocated if all three extents are non-zero and the
cudaArrayCubemap flag is set. Width must be equal to height, and depth must be six.
The order of the six layers in memory is the same as that listed in ::cudaGraphicsCubeFace.</li>
<li>A cubemap layered CUDA mipmapped array is allocated if all three extents are non-zero, and both,
cudaArrayCubemap and cudaArrayLayered flags are set. Width must be equal to height, and depth must be
a multiple of six. A cubemap layered CUDA mipmapped array is a special type of 2D layered CUDA mipmapped
array that consists of a collection of cubemap mipmapped arrays. The first six layers represent the
first cubemap mipmapped array, the next six layers form the second cubemap mipmapped array, and so on.</li>
</ul>
<p>The \p flags parameter enables different options to be specified that affect
the allocation, as follows.</p>
<ul>
<li>::cudaArrayDefault: This flag's value is defined to be 0 and provides default mipmapped array allocation</li>
<li>::cudaArrayLayered: Allocates a layered CUDA mipmapped array, with the depth extent indicating the number of layers</li>
<li>::cudaArrayCubemap: Allocates a cubemap CUDA mipmapped array. Width must be equal to height, and depth must be six.
If the cudaArrayLayered flag is also set, depth must be a multiple of six.</li>
<li>::cudaArraySurfaceLoadStore: This flag indicates that individual mipmap levels of the CUDA mipmapped array
will be read from or written to using a surface reference.</li>
<li>::cudaArrayTextureGather: This flag indicates that texture gather operations will be performed on the CUDA
array. Texture gather can only be performed on 2D CUDA mipmapped arrays, and the gather operations are
performed only on the most detailed mipmap level.</li>
</ul>
<p>The width, height and depth extents must meet certain size requirements as listed in the following table.
All values are specified in elements.</p>
<p>\xmlonly</p>
<table outputclass="xmlonly">
 <tgroup cols="3" colsep="1" rowsep="1">
 <colspec colname="c1" colwidth="1.0*"/>
 <colspec colname="c2" colwidth="3.0*"/>
 <colspec colname="c3" colwidth="3.0*"/>
 <thead>
 <row>
 <entry>CUDA array type</entry>
 <entry>Valid extents that must always be met {(width range in elements),
 (height range), (depth range)}</entry>
 <entry>Valid extents with cudaArraySurfaceLoadStore set {(width range in
 elements), (height range), (depth range)}</entry>
 </row>
 </thead>
 <tbody>
 <row>
 <entry>1D</entry>
 <entry>{ (1,maxTexture1DMipmap), 0, 0 }</entry>
 <entry>{ (1,maxSurface1D), 0, 0 }</entry>
 </row>
 <row>
 <entry>2D</entry>
 <entry>{ (1,maxTexture2DMipmap[0]), (1,maxTexture2DMipmap[1]), 0 }</entry>
 <entry>{ (1,maxSurface2D[0]), (1,maxSurface2D[1]), 0 }</entry>
 </row>
 <row>
 <entry>3D</entry>
 <entry>{ (1,maxTexture3D[0]), (1,maxTexture3D[1]), (1,maxTexture3D[2]) }
 OR { (1,maxTexture3DAlt[0]), (1,maxTexture3DAlt[1]),
 (1,maxTexture3DAlt[2]) }</entry>
 <entry>{ (1,maxSurface3D[0]), (1,maxSurface3D[1]), (1,maxSurface3D[2]) }</entry>
 </row>
 <row>
 <entry>1D Layered</entry>
 <entry>{ (1,maxTexture1DLayered[0]), 0, (1,maxTexture1DLayered[1]) }</entry>
 <entry>{ (1,maxSurface1DLayered[0]), 0, (1,maxSurface1DLayered[1]) }</entry>
 </row>
 <row>
 <entry>2D Layered</entry>
 <entry>{ (1,maxTexture2DLayered[0]), (1,maxTexture2DLayered[1]),
 (1,maxTexture2DLayered[2]) }</entry>
 <entry>{ (1,maxSurface2DLayered[0]), (1,maxSurface2DLayered[1]),
 (1,maxSurface2DLayered[2]) }</entry>
 </row>
 <row>
 <entry>Cubemap</entry>
 <entry>{ (1,maxTextureCubemap), (1,maxTextureCubemap), 6 }</entry>
 <entry>{ (1,maxSurfaceCubemap), (1,maxSurfaceCubemap), 6 }</entry>
 </row>
 <row>
 <entry>Cubemap Layered</entry>
 <entry>{ (1,maxTextureCubemapLayered[0]), (1,maxTextureCubemapLayered[0]),
 (1,maxTextureCubemapLayered[1]) }</entry>
 <entry>{ (1,maxSurfaceCubemapLayered[0]), (1,maxSurfaceCubemapLayered[0]),
 (1,maxSurfaceCubemapLayered[1]) }</entry>
 </row>
 </tbody>
 </tgroup>
 </table>
 \endxmlonly
<p>\param mipmappedArray  - Pointer to allocated mipmapped array in device memory
\param desc            - Requested channel format
\param extent          - Requested allocation size (\p width field in elements)
\param numLevels       - Number of mipmap levels to allocate
\param flags           - Flags for extensions</p>
<p>\return
::cudaSuccess,
::cudaErrorInvalidValue,
::cudaErrorMemoryAllocation
\notefnerr
\note_init_rt
\note_callback</p>
<p>\sa ::cudaMalloc3D, ::cudaMalloc, ::cudaMallocPitch, ::cudaFree,
::cudaFreeArray,
\ref ::cudaMallocHost(void**, size_t) &quot;cudaMallocHost (C API)&quot;,
::cudaFreeHost, ::cudaHostAlloc,
::make_cudaExtent,
::cuMipmappedArrayCreate</p>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "rcudnn";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>