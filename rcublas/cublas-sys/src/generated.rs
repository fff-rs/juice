/* automatically generated by rust-bindgen 0.58.1 */


//! Defines the FFI for CUDA cuBLAS.
//!
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]


pub const CUBLAS_VER_MAJOR: u32 = 11;
pub const CUBLAS_VER_MINOR: u32 = 5;
pub const CUBLAS_VER_PATCH: u32 = 2;
pub const CUBLAS_VER_BUILD: u32 = 43;
pub const CUBLAS_VERSION: u32 = 11502;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_float2() {
    assert_eq!(
        ::std::mem::size_of::<float2>(),
        8usize,
        concat!("Size of: ", stringify!(float2))
    );
    assert_eq!(
        ::std::mem::align_of::<float2>(),
        8usize,
        concat!("Alignment of ", stringify!(float2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(y))
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_double2() {
    assert_eq!(
        ::std::mem::size_of::<double2>(),
        16usize,
        concat!("Size of: ", stringify!(double2))
    );
    assert_eq!(
        ::std::mem::align_of::<double2>(),
        16usize,
        concat!("Alignment of ", stringify!(double2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double2>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "                                                                              *"]
#[doc = "                                                                              *"]
#[doc = "                                                                              *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_dim3() {
    assert_eq!(
        ::std::mem::size_of::<dim3>(),
        12usize,
        concat!("Size of: ", stringify!(dim3))
    );
    assert_eq!(
        ::std::mem::align_of::<dim3>(),
        4usize,
        concat!("Alignment of ", stringify!(dim3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(z))
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA error types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaError {
    #[doc = " The API call returned with no errors. In the case of query calls, this"]
    #[doc = " also means that the operation being queried is complete (see"]
    #[doc = " ::cudaEventQuery() and ::cudaStreamQuery())."]
    cudaSuccess = 0,
    #[doc = " This indicates that one or more of the parameters passed to the API call"]
    #[doc = " is not within an acceptable range of values."]
    cudaErrorInvalidValue = 1,
    #[doc = " The API call failed because it was unable to allocate enough memory to"]
    #[doc = " perform the requested operation."]
    cudaErrorMemoryAllocation = 2,
    #[doc = " The API call failed because the CUDA driver and runtime could not be"]
    #[doc = " initialized."]
    cudaErrorInitializationError = 3,
    #[doc = " This indicates that a CUDA Runtime API call cannot be executed because"]
    #[doc = " it is being called during process shut down, at a point in time after"]
    #[doc = " CUDA driver has been unloaded."]
    cudaErrorCudartUnloading = 4,
    #[doc = " This indicates profiler is not initialized for this run. This can"]
    #[doc = " happen when the application is running with external profiling tools"]
    #[doc = " like visual profiler."]
    cudaErrorProfilerDisabled = 5,
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 5.0. It is no longer an error"]
    #[doc = " to attempt to enable/disable the profiling via ::cudaProfilerStart or"]
    #[doc = " ::cudaProfilerStop without initialization."]
    cudaErrorProfilerNotInitialized = 6,
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 5.0. It is no longer an error"]
    #[doc = " to call cudaProfilerStart() when profiling is already enabled."]
    cudaErrorProfilerAlreadyStarted = 7,
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 5.0. It is no longer an error"]
    #[doc = " to call cudaProfilerStop() when profiling is already disabled."]
    cudaErrorProfilerAlreadyStopped = 8,
    #[doc = " This indicates that a kernel launch is requesting resources that can"]
    #[doc = " never be satisfied by the current device. Requesting more shared memory"]
    #[doc = " per block than the device supports will trigger this error, as will"]
    #[doc = " requesting too many threads or blocks. See ::cudaDeviceProp for more"]
    #[doc = " device limitations."]
    cudaErrorInvalidConfiguration = 9,
    #[doc = " This indicates that one or more of the pitch-related parameters passed"]
    #[doc = " to the API call is not within the acceptable range for pitch."]
    cudaErrorInvalidPitchValue = 12,
    #[doc = " This indicates that the symbol name/identifier passed to the API call"]
    #[doc = " is not a valid name or identifier."]
    cudaErrorInvalidSymbol = 13,
    #[doc = " This indicates that at least one host pointer passed to the API call is"]
    #[doc = " not a valid host pointer."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 10.1."]
    cudaErrorInvalidHostPointer = 16,
    #[doc = " This indicates that at least one device pointer passed to the API call is"]
    #[doc = " not a valid device pointer."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 10.1."]
    cudaErrorInvalidDevicePointer = 17,
    #[doc = " This indicates that the texture passed to the API call is not a valid"]
    #[doc = " texture."]
    cudaErrorInvalidTexture = 18,
    #[doc = " This indicates that the texture binding is not valid. This occurs if you"]
    #[doc = " call ::cudaGetTextureAlignmentOffset() with an unbound texture."]
    cudaErrorInvalidTextureBinding = 19,
    #[doc = " This indicates that the channel descriptor passed to the API call is not"]
    #[doc = " valid. This occurs if the format is not one of the formats specified by"]
    #[doc = " ::cudaChannelFormatKind, or if one of the dimensions is invalid."]
    cudaErrorInvalidChannelDescriptor = 20,
    #[doc = " This indicates that the direction of the memcpy passed to the API call is"]
    #[doc = " not one of the types specified by ::cudaMemcpyKind."]
    cudaErrorInvalidMemcpyDirection = 21,
    #[doc = " This indicated that the user has taken the address of a constant variable,"]
    #[doc = " which was forbidden up until the CUDA 3.1 release."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 3.1. Variables in constant"]
    #[doc = " memory may now have their address taken by the runtime via"]
    #[doc = " ::cudaGetSymbolAddress()."]
    cudaErrorAddressOfConstant = 22,
    #[doc = " This indicated that a texture fetch was not able to be performed."]
    #[doc = " This was previously used for device emulation of texture operations."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 3.1. Device emulation mode was"]
    #[doc = " removed with the CUDA 3.1 release."]
    cudaErrorTextureFetchFailed = 23,
    #[doc = " This indicated that a texture was not bound for access."]
    #[doc = " This was previously used for device emulation of texture operations."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 3.1. Device emulation mode was"]
    #[doc = " removed with the CUDA 3.1 release."]
    cudaErrorTextureNotBound = 24,
    #[doc = " This indicated that a synchronization operation had failed."]
    #[doc = " This was previously used for some device emulation functions."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 3.1. Device emulation mode was"]
    #[doc = " removed with the CUDA 3.1 release."]
    cudaErrorSynchronizationError = 25,
    #[doc = " This indicates that a non-float texture was being accessed with linear"]
    #[doc = " filtering. This is not supported by CUDA."]
    cudaErrorInvalidFilterSetting = 26,
    #[doc = " This indicates that an attempt was made to read a non-float texture as a"]
    #[doc = " normalized float. This is not supported by CUDA."]
    cudaErrorInvalidNormSetting = 27,
    #[doc = " Mixing of device and device emulation code was not allowed."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 3.1. Device emulation mode was"]
    #[doc = " removed with the CUDA 3.1 release."]
    cudaErrorMixedDeviceExecution = 28,
    #[doc = " This indicates that the API call is not yet implemented. Production"]
    #[doc = " releases of CUDA will never return this error."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 4.1."]
    cudaErrorNotYetImplemented = 31,
    #[doc = " This indicated that an emulated device pointer exceeded the 32-bit address"]
    #[doc = " range."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 3.1. Device emulation mode was"]
    #[doc = " removed with the CUDA 3.1 release."]
    cudaErrorMemoryValueTooLarge = 32,
    #[doc = " This indicates that the CUDA driver that the application has loaded is a"]
    #[doc = " stub library. Applications that run with the stub rather than a real"]
    #[doc = " driver loaded will result in CUDA API returning this error."]
    cudaErrorStubLibrary = 34,
    #[doc = " This indicates that the installed NVIDIA CUDA driver is older than the"]
    #[doc = " CUDA runtime library. This is not a supported configuration. Users should"]
    #[doc = " install an updated NVIDIA display driver to allow the application to run."]
    cudaErrorInsufficientDriver = 35,
    #[doc = " This indicates that the API call requires a newer CUDA driver than the one"]
    #[doc = " currently installed. Users should install an updated NVIDIA CUDA driver"]
    #[doc = " to allow the API call to succeed."]
    cudaErrorCallRequiresNewerDriver = 36,
    #[doc = " This indicates that the surface passed to the API call is not a valid"]
    #[doc = " surface."]
    cudaErrorInvalidSurface = 37,
    #[doc = " This indicates that multiple global or constant variables (across separate"]
    #[doc = " CUDA source files in the application) share the same string name."]
    cudaErrorDuplicateVariableName = 43,
    #[doc = " This indicates that multiple textures (across separate CUDA source"]
    #[doc = " files in the application) share the same string name."]
    cudaErrorDuplicateTextureName = 44,
    #[doc = " This indicates that multiple surfaces (across separate CUDA source"]
    #[doc = " files in the application) share the same string name."]
    cudaErrorDuplicateSurfaceName = 45,
    #[doc = " This indicates that all CUDA devices are busy or unavailable at the current"]
    #[doc = " time. Devices are often busy/unavailable due to use of"]
    #[doc = " ::cudaComputeModeExclusive, ::cudaComputeModeProhibited or when long"]
    #[doc = " running CUDA kernels have filled up the GPU and are blocking new work"]
    #[doc = " from starting. They can also be unavailable due to memory constraints"]
    #[doc = " on a device that already has active CUDA work being performed."]
    cudaErrorDevicesUnavailable = 46,
    #[doc = " This indicates that the current context is not compatible with this"]
    #[doc = " the CUDA Runtime. This can only occur if you are using CUDA"]
    #[doc = " Runtime/Driver interoperability and have created an existing Driver"]
    #[doc = " context using the driver API. The Driver context may be incompatible"]
    #[doc = " either because the Driver context was created using an older version"]
    #[doc = " of the API, because the Runtime API call expects a primary driver"]
    #[doc = " context and the Driver context is not primary, or because the Driver"]
    #[doc = " context has been destroyed. Please see \\ref CUDART_DRIVER \"Interactions"]
    #[doc = " with the CUDA Driver API\" for more information."]
    cudaErrorIncompatibleDriverContext = 49,
    #[doc = " The device function being invoked (usually via ::cudaLaunchKernel()) was not"]
    #[doc = " previously configured via the ::cudaConfigureCall() function."]
    cudaErrorMissingConfiguration = 52,
    #[doc = " This indicated that a previous kernel launch failed. This was previously"]
    #[doc = " used for device emulation of kernel launches."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 3.1. Device emulation mode was"]
    #[doc = " removed with the CUDA 3.1 release."]
    cudaErrorPriorLaunchFailure = 53,
    #[doc = " This error indicates that a device runtime grid launch did not occur"]
    #[doc = " because the depth of the child grid would exceed the maximum supported"]
    #[doc = " number of nested grid launches."]
    cudaErrorLaunchMaxDepthExceeded = 65,
    #[doc = " This error indicates that a grid launch did not occur because the kernel"]
    #[doc = " uses file-scoped textures which are unsupported by the device runtime."]
    #[doc = " Kernels launched via the device runtime only support textures created with"]
    #[doc = " the Texture Object API's."]
    cudaErrorLaunchFileScopedTex = 66,
    #[doc = " This error indicates that a grid launch did not occur because the kernel"]
    #[doc = " uses file-scoped surfaces which are unsupported by the device runtime."]
    #[doc = " Kernels launched via the device runtime only support surfaces created with"]
    #[doc = " the Surface Object API's."]
    cudaErrorLaunchFileScopedSurf = 67,
    #[doc = " This error indicates that a call to ::cudaDeviceSynchronize made from"]
    #[doc = " the device runtime failed because the call was made at grid depth greater"]
    #[doc = " than than either the default (2 levels of grids) or user specified device"]
    #[doc = " limit ::cudaLimitDevRuntimeSyncDepth. To be able to synchronize on"]
    #[doc = " launched grids at a greater depth successfully, the maximum nested"]
    #[doc = " depth at which ::cudaDeviceSynchronize will be called must be specified"]
    #[doc = " with the ::cudaLimitDevRuntimeSyncDepth limit to the ::cudaDeviceSetLimit"]
    #[doc = " api before the host-side launch of a kernel using the device runtime."]
    #[doc = " Keep in mind that additional levels of sync depth require the runtime"]
    #[doc = " to reserve large amounts of device memory that cannot be used for"]
    #[doc = " user allocations."]
    cudaErrorSyncDepthExceeded = 68,
    #[doc = " This error indicates that a device runtime grid launch failed because"]
    #[doc = " the launch would exceed the limit ::cudaLimitDevRuntimePendingLaunchCount."]
    #[doc = " For this launch to proceed successfully, ::cudaDeviceSetLimit must be"]
    #[doc = " called to set the ::cudaLimitDevRuntimePendingLaunchCount to be higher"]
    #[doc = " than the upper bound of outstanding launches that can be issued to the"]
    #[doc = " device runtime. Keep in mind that raising the limit of pending device"]
    #[doc = " runtime launches will require the runtime to reserve device memory that"]
    #[doc = " cannot be used for user allocations."]
    cudaErrorLaunchPendingCountExceeded = 69,
    #[doc = " The requested device function does not exist or is not compiled for the"]
    #[doc = " proper device architecture."]
    cudaErrorInvalidDeviceFunction = 98,
    #[doc = " This indicates that no CUDA-capable devices were detected by the installed"]
    #[doc = " CUDA driver."]
    cudaErrorNoDevice = 100,
    #[doc = " This indicates that the device ordinal supplied by the user does not"]
    #[doc = " correspond to a valid CUDA device or that the action requested is"]
    #[doc = " invalid for the specified device."]
    cudaErrorInvalidDevice = 101,
    #[doc = " This indicates that the device doesn't have a valid Grid License."]
    cudaErrorDeviceNotLicensed = 102,
    #[doc = " By default, the CUDA runtime may perform a minimal set of self-tests,"]
    #[doc = " as well as CUDA driver tests, to establish the validity of both."]
    #[doc = " Introduced in CUDA 11.2, this error return indicates that at least one"]
    #[doc = " of these tests has failed and the validity of either the runtime"]
    #[doc = " or the driver could not be established."]
    cudaErrorSoftwareValidityNotEstablished = 103,
    #[doc = " This indicates an internal startup failure in the CUDA runtime."]
    cudaErrorStartupFailure = 127,
    #[doc = " This indicates that the device kernel image is invalid."]
    cudaErrorInvalidKernelImage = 200,
    #[doc = " This most frequently indicates that there is no context bound to the"]
    #[doc = " current thread. This can also be returned if the context passed to an"]
    #[doc = " API call is not a valid handle (such as a context that has had"]
    #[doc = " ::cuCtxDestroy() invoked on it). This can also be returned if a user"]
    #[doc = " mixes different API versions (i.e. 3010 context with 3020 API calls)."]
    #[doc = " See ::cuCtxGetApiVersion() for more details."]
    cudaErrorDeviceUninitialized = 201,
    #[doc = " This indicates that the buffer object could not be mapped."]
    cudaErrorMapBufferObjectFailed = 205,
    #[doc = " This indicates that the buffer object could not be unmapped."]
    cudaErrorUnmapBufferObjectFailed = 206,
    #[doc = " This indicates that the specified array is currently mapped and thus"]
    #[doc = " cannot be destroyed."]
    cudaErrorArrayIsMapped = 207,
    #[doc = " This indicates that the resource is already mapped."]
    cudaErrorAlreadyMapped = 208,
    #[doc = " This indicates that there is no kernel image available that is suitable"]
    #[doc = " for the device. This can occur when a user specifies code generation"]
    #[doc = " options for a particular CUDA source file that do not include the"]
    #[doc = " corresponding device configuration."]
    cudaErrorNoKernelImageForDevice = 209,
    #[doc = " This indicates that a resource has already been acquired."]
    cudaErrorAlreadyAcquired = 210,
    #[doc = " This indicates that a resource is not mapped."]
    cudaErrorNotMapped = 211,
    #[doc = " This indicates that a mapped resource is not available for access as an"]
    #[doc = " array."]
    cudaErrorNotMappedAsArray = 212,
    #[doc = " This indicates that a mapped resource is not available for access as a"]
    #[doc = " pointer."]
    cudaErrorNotMappedAsPointer = 213,
    #[doc = " This indicates that an uncorrectable ECC error was detected during"]
    #[doc = " execution."]
    cudaErrorECCUncorrectable = 214,
    #[doc = " This indicates that the ::cudaLimit passed to the API call is not"]
    #[doc = " supported by the active device."]
    cudaErrorUnsupportedLimit = 215,
    #[doc = " This indicates that a call tried to access an exclusive-thread device that"]
    #[doc = " is already in use by a different thread."]
    cudaErrorDeviceAlreadyInUse = 216,
    #[doc = " This error indicates that P2P access is not supported across the given"]
    #[doc = " devices."]
    cudaErrorPeerAccessUnsupported = 217,
    #[doc = " A PTX compilation failed. The runtime may fall back to compiling PTX if"]
    #[doc = " an application does not contain a suitable binary for the current device."]
    cudaErrorInvalidPtx = 218,
    #[doc = " This indicates an error with the OpenGL or DirectX context."]
    cudaErrorInvalidGraphicsContext = 219,
    #[doc = " This indicates that an uncorrectable NVLink error was detected during the"]
    #[doc = " execution."]
    cudaErrorNvlinkUncorrectable = 220,
    #[doc = " This indicates that the PTX JIT compiler library was not found. The JIT Compiler"]
    #[doc = " library is used for PTX compilation. The runtime may fall back to compiling PTX"]
    #[doc = " if an application does not contain a suitable binary for the current device."]
    cudaErrorJitCompilerNotFound = 221,
    #[doc = " This indicates that the provided PTX was compiled with an unsupported toolchain."]
    #[doc = " The most common reason for this, is the PTX was generated by a compiler newer"]
    #[doc = " than what is supported by the CUDA driver and PTX JIT compiler."]
    cudaErrorUnsupportedPtxVersion = 222,
    #[doc = " This indicates that the JIT compilation was disabled. The JIT compilation compiles"]
    #[doc = " PTX. The runtime may fall back to compiling PTX if an application does not contain"]
    #[doc = " a suitable binary for the current device."]
    cudaErrorJitCompilationDisabled = 223,
    #[doc = " This indicates that the provided execution affinity is not supported by the device."]
    cudaErrorUnsupportedExecAffinity = 224,
    #[doc = " This indicates that the device kernel source is invalid."]
    cudaErrorInvalidSource = 300,
    #[doc = " This indicates that the file specified was not found."]
    cudaErrorFileNotFound = 301,
    #[doc = " This indicates that a link to a shared object failed to resolve."]
    cudaErrorSharedObjectSymbolNotFound = 302,
    #[doc = " This indicates that initialization of a shared object failed."]
    cudaErrorSharedObjectInitFailed = 303,
    #[doc = " This error indicates that an OS call failed."]
    cudaErrorOperatingSystem = 304,
    #[doc = " This indicates that a resource handle passed to the API call was not"]
    #[doc = " valid. Resource handles are opaque types like ::cudaStream_t and"]
    #[doc = " ::cudaEvent_t."]
    cudaErrorInvalidResourceHandle = 400,
    #[doc = " This indicates that a resource required by the API call is not in a"]
    #[doc = " valid state to perform the requested operation."]
    cudaErrorIllegalState = 401,
    #[doc = " This indicates that a named symbol was not found. Examples of symbols"]
    #[doc = " are global/constant variable names, driver function names, texture names,"]
    #[doc = " and surface names."]
    cudaErrorSymbolNotFound = 500,
    #[doc = " This indicates that asynchronous operations issued previously have not"]
    #[doc = " completed yet. This result is not actually an error, but must be indicated"]
    #[doc = " differently than ::cudaSuccess (which indicates completion). Calls that"]
    #[doc = " may return this value include ::cudaEventQuery() and ::cudaStreamQuery()."]
    cudaErrorNotReady = 600,
    #[doc = " The device encountered a load or store instruction on an invalid memory address."]
    #[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
    #[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
    #[doc = " and relaunched."]
    cudaErrorIllegalAddress = 700,
    #[doc = " This indicates that a launch did not occur because it did not have"]
    #[doc = " appropriate resources. Although this error is similar to"]
    #[doc = " ::cudaErrorInvalidConfiguration, this error usually indicates that the"]
    #[doc = " user has attempted to pass too many arguments to the device kernel, or the"]
    #[doc = " kernel launch specifies too many threads for the kernel's register count."]
    cudaErrorLaunchOutOfResources = 701,
    #[doc = " This indicates that the device kernel took too long to execute. This can"]
    #[doc = " only occur if timeouts are enabled - see the device property"]
    #[doc = " \\ref ::cudaDeviceProp::kernelExecTimeoutEnabled \"kernelExecTimeoutEnabled\""]
    #[doc = " for more information."]
    #[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
    #[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
    #[doc = " and relaunched."]
    cudaErrorLaunchTimeout = 702,
    #[doc = " This error indicates a kernel launch that uses an incompatible texturing"]
    #[doc = " mode."]
    cudaErrorLaunchIncompatibleTexturing = 703,
    #[doc = " This error indicates that a call to ::cudaDeviceEnablePeerAccess() is"]
    #[doc = " trying to re-enable peer addressing on from a context which has already"]
    #[doc = " had peer addressing enabled."]
    cudaErrorPeerAccessAlreadyEnabled = 704,
    #[doc = " This error indicates that ::cudaDeviceDisablePeerAccess() is trying to"]
    #[doc = " disable peer addressing which has not been enabled yet via"]
    #[doc = " ::cudaDeviceEnablePeerAccess()."]
    cudaErrorPeerAccessNotEnabled = 705,
    #[doc = " This indicates that the user has called ::cudaSetValidDevices(),"]
    #[doc = " ::cudaSetDeviceFlags(), ::cudaD3D9SetDirect3DDevice(),"]
    #[doc = " ::cudaD3D10SetDirect3DDevice, ::cudaD3D11SetDirect3DDevice(), or"]
    #[doc = " ::cudaVDPAUSetVDPAUDevice() after initializing the CUDA runtime by"]
    #[doc = " calling non-device management operations (allocating memory and"]
    #[doc = " launching kernels are examples of non-device management operations)."]
    #[doc = " This error can also be returned if using runtime/driver"]
    #[doc = " interoperability and there is an existing ::CUcontext active on the"]
    #[doc = " host thread."]
    cudaErrorSetOnActiveProcess = 708,
    #[doc = " This error indicates that the context current to the calling thread"]
    #[doc = " has been destroyed using ::cuCtxDestroy, or is a primary context which"]
    #[doc = " has not yet been initialized."]
    cudaErrorContextIsDestroyed = 709,
    #[doc = " An assert triggered in device code during kernel execution. The device"]
    #[doc = " cannot be used again. All existing allocations are invalid. To continue"]
    #[doc = " using CUDA, the process must be terminated and relaunched."]
    cudaErrorAssert = 710,
    #[doc = " This error indicates that the hardware resources required to enable"]
    #[doc = " peer access have been exhausted for one or more of the devices"]
    #[doc = " passed to ::cudaEnablePeerAccess()."]
    cudaErrorTooManyPeers = 711,
    #[doc = " This error indicates that the memory range passed to ::cudaHostRegister()"]
    #[doc = " has already been registered."]
    cudaErrorHostMemoryAlreadyRegistered = 712,
    #[doc = " This error indicates that the pointer passed to ::cudaHostUnregister()"]
    #[doc = " does not correspond to any currently registered memory region."]
    cudaErrorHostMemoryNotRegistered = 713,
    #[doc = " Device encountered an error in the call stack during kernel execution,"]
    #[doc = " possibly due to stack corruption or exceeding the stack size limit."]
    #[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
    #[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
    #[doc = " and relaunched."]
    cudaErrorHardwareStackError = 714,
    #[doc = " The device encountered an illegal instruction during kernel execution"]
    #[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
    #[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
    #[doc = " and relaunched."]
    cudaErrorIllegalInstruction = 715,
    #[doc = " The device encountered a load or store instruction"]
    #[doc = " on a memory address which is not aligned."]
    #[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
    #[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
    #[doc = " and relaunched."]
    cudaErrorMisalignedAddress = 716,
    #[doc = " While executing a kernel, the device encountered an instruction"]
    #[doc = " which can only operate on memory locations in certain address spaces"]
    #[doc = " (global, shared, or local), but was supplied a memory address not"]
    #[doc = " belonging to an allowed address space."]
    #[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
    #[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
    #[doc = " and relaunched."]
    cudaErrorInvalidAddressSpace = 717,
    #[doc = " The device encountered an invalid program counter."]
    #[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
    #[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
    #[doc = " and relaunched."]
    cudaErrorInvalidPc = 718,
    #[doc = " An exception occurred on the device while executing a kernel. Common"]
    #[doc = " causes include dereferencing an invalid device pointer and accessing"]
    #[doc = " out of bounds shared memory. Less common cases can be system specific - more"]
    #[doc = " information about these cases can be found in the system specific user guide."]
    #[doc = " This leaves the process in an inconsistent state and any further CUDA work"]
    #[doc = " will return the same error. To continue using CUDA, the process must be terminated"]
    #[doc = " and relaunched."]
    cudaErrorLaunchFailure = 719,
    #[doc = " This error indicates that the number of blocks launched per grid for a kernel that was"]
    #[doc = " launched via either ::cudaLaunchCooperativeKernel or ::cudaLaunchCooperativeKernelMultiDevice"]
    #[doc = " exceeds the maximum number of blocks as allowed by ::cudaOccupancyMaxActiveBlocksPerMultiprocessor"]
    #[doc = " or ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors"]
    #[doc = " as specified by the device attribute ::cudaDevAttrMultiProcessorCount."]
    cudaErrorCooperativeLaunchTooLarge = 720,
    #[doc = " This error indicates the attempted operation is not permitted."]
    cudaErrorNotPermitted = 800,
    #[doc = " This error indicates the attempted operation is not supported"]
    #[doc = " on the current system or device."]
    cudaErrorNotSupported = 801,
    #[doc = " This error indicates that the system is not yet ready to start any CUDA"]
    #[doc = " work.  To continue using CUDA, verify the system configuration is in a"]
    #[doc = " valid state and all required driver daemons are actively running."]
    #[doc = " More information about this error can be found in the system specific"]
    #[doc = " user guide."]
    cudaErrorSystemNotReady = 802,
    #[doc = " This error indicates that there is a mismatch between the versions of"]
    #[doc = " the display driver and the CUDA driver. Refer to the compatibility documentation"]
    #[doc = " for supported versions."]
    cudaErrorSystemDriverMismatch = 803,
    #[doc = " This error indicates that the system was upgraded to run with forward compatibility"]
    #[doc = " but the visible hardware detected by CUDA does not support this configuration."]
    #[doc = " Refer to the compatibility documentation for the supported hardware matrix or ensure"]
    #[doc = " that only supported hardware is visible during initialization via the CUDA_VISIBLE_DEVICES"]
    #[doc = " environment variable."]
    cudaErrorCompatNotSupportedOnDevice = 804,
    #[doc = " This error indicates that the MPS client failed to connect to the MPS control daemon or the MPS server."]
    cudaErrorMpsConnectionFailed = 805,
    #[doc = " This error indicates that the remote procedural call between the MPS server and the MPS client failed."]
    cudaErrorMpsRpcFailure = 806,
    #[doc = " This error indicates that the MPS server is not ready to accept new MPS client requests."]
    #[doc = " This error can be returned when the MPS server is in the process of recovering from a fatal failure."]
    cudaErrorMpsServerNotReady = 807,
    #[doc = " This error indicates that the hardware resources required to create MPS client have been exhausted."]
    cudaErrorMpsMaxClientsReached = 808,
    #[doc = " This error indicates the the hardware resources required to device connections have been exhausted."]
    cudaErrorMpsMaxConnectionsReached = 809,
    #[doc = " The operation is not permitted when the stream is capturing."]
    cudaErrorStreamCaptureUnsupported = 900,
    #[doc = " The current capture sequence on the stream has been invalidated due to"]
    #[doc = " a previous error."]
    cudaErrorStreamCaptureInvalidated = 901,
    #[doc = " The operation would have resulted in a merge of two independent capture"]
    #[doc = " sequences."]
    cudaErrorStreamCaptureMerge = 902,
    #[doc = " The capture was not initiated in this stream."]
    cudaErrorStreamCaptureUnmatched = 903,
    #[doc = " The capture sequence contains a fork that was not joined to the primary"]
    #[doc = " stream."]
    cudaErrorStreamCaptureUnjoined = 904,
    #[doc = " A dependency would have been created which crosses the capture sequence"]
    #[doc = " boundary. Only implicit in-stream ordering dependencies are allowed to"]
    #[doc = " cross the boundary."]
    cudaErrorStreamCaptureIsolation = 905,
    #[doc = " The operation would have resulted in a disallowed implicit dependency on"]
    #[doc = " a current capture sequence from cudaStreamLegacy."]
    cudaErrorStreamCaptureImplicit = 906,
    #[doc = " The operation is not permitted on an event which was last recorded in a"]
    #[doc = " capturing stream."]
    cudaErrorCapturedEvent = 907,
    #[doc = " A stream capture sequence not initiated with the ::cudaStreamCaptureModeRelaxed"]
    #[doc = " argument to ::cudaStreamBeginCapture was passed to ::cudaStreamEndCapture in a"]
    #[doc = " different thread."]
    cudaErrorStreamCaptureWrongThread = 908,
    #[doc = " This indicates that the wait operation has timed out."]
    cudaErrorTimeout = 909,
    #[doc = " This error indicates that the graph update was not performed because it included"]
    #[doc = " changes which violated constraints specific to instantiated graph update."]
    cudaErrorGraphExecUpdateFailure = 910,
    #[doc = " This indicates that an unknown internal error has occurred."]
    cudaErrorUnknown = 999,
    #[doc = " Any unhandled CUDA driver error is added to this value and returned via"]
    #[doc = " the runtime. Production releases of CUDA should not return such errors."]
    #[doc = " \\deprecated"]
    #[doc = " This error return is deprecated as of CUDA 4.1."]
    cudaErrorApiFailureBase = 10000,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Channel format kind"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaChannelFormatKind {
    #[doc = "< Signed channel format"]
    cudaChannelFormatKindSigned = 0,
    #[doc = "< Unsigned channel format"]
    cudaChannelFormatKindUnsigned = 1,
    #[doc = "< Float channel format"]
    cudaChannelFormatKindFloat = 2,
    #[doc = "< No channel format"]
    cudaChannelFormatKindNone = 3,
    cudaChannelFormatKindNV12 = 4,
}
#[doc = " CUDA Channel format descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaChannelFormatDesc {
    #[doc = "< x"]
    pub x: ::libc::c_int,
    #[doc = "< y"]
    pub y: ::libc::c_int,
    #[doc = "< z"]
    pub z: ::libc::c_int,
    #[doc = "< w"]
    pub w: ::libc::c_int,
    #[doc = "< Channel format kind"]
    pub f: cudaChannelFormatKind,
}
#[test]
fn bindgen_test_layout_cudaChannelFormatDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaChannelFormatDesc>())).f as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaChannelFormatDesc),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArray {
    _unused: [u8; 0],
}
#[doc = " CUDA array"]
pub type cudaArray_t = *mut cudaArray;
#[doc = " CUDA array (as source copy argument)"]
pub type cudaArray_const_t = *const cudaArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMipmappedArray {
    _unused: [u8; 0],
}
#[doc = " CUDA mipmapped array"]
pub type cudaMipmappedArray_t = *mut cudaMipmappedArray;
#[doc = " CUDA mipmapped array (as source argument)"]
pub type cudaMipmappedArray_const_t = *const cudaMipmappedArray;
#[doc = " Sparse CUDA array and CUDA mipmapped array properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties {
    pub tileExtent: cudaArraySparseProperties__bindgen_ty_1,
    #[doc = "< First mip level at which the mip tail begins"]
    pub miptailFirstLevel: ::libc::c_uint,
    #[doc = "< Total size of the mip tail."]
    pub miptailSize: ::libc::c_ulonglong,
    #[doc = "< Flags will either be zero or ::cudaArraySparsePropertiesSingleMipTail"]
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties__bindgen_ty_1 {
    #[doc = "< Tile width in elements"]
    pub width: ::libc::c_uint,
    #[doc = "< Tile height in elements"]
    pub height: ::libc::c_uint,
    #[doc = "< Tile depth in elements"]
    pub depth: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaArraySparseProperties__bindgen_ty_1>())).width as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaArraySparseProperties__bindgen_ty_1>())).height as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaArraySparseProperties__bindgen_ty_1>())).depth as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties() {
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties>(),
        48usize,
        concat!("Size of: ", stringify!(cudaArraySparseProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaArraySparseProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaArraySparseProperties>())).tileExtent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(tileExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaArraySparseProperties>())).miptailFirstLevel as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(miptailFirstLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaArraySparseProperties>())).miptailSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(miptailSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaArraySparseProperties>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaArraySparseProperties>())).reserved as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaArraySparseProperties),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA memory types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemoryType {
    #[doc = "< Unregistered memory"]
    cudaMemoryTypeUnregistered = 0,
    #[doc = "< Host memory"]
    cudaMemoryTypeHost = 1,
    #[doc = "< Device memory"]
    cudaMemoryTypeDevice = 2,
    #[doc = "< Managed memory"]
    cudaMemoryTypeManaged = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA memory copy types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemcpyKind {
    #[doc = "< Host   -> Host"]
    cudaMemcpyHostToHost = 0,
    #[doc = "< Host   -> Device"]
    cudaMemcpyHostToDevice = 1,
    #[doc = "< Device -> Host"]
    cudaMemcpyDeviceToHost = 2,
    #[doc = "< Device -> Device"]
    cudaMemcpyDeviceToDevice = 3,
    #[doc = "< Direction of the transfer is inferred from the pointer values. Requires unified virtual addressing"]
    cudaMemcpyDefault = 4,
}
#[doc = " CUDA Pitched memory pointer"]
#[doc = ""]
#[doc = " \\sa ::make_cudaPitchedPtr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPitchedPtr {
    #[doc = "< Pointer to allocated memory"]
    pub ptr: *mut ::libc::c_void,
    #[doc = "< Pitch of allocated memory in bytes"]
    pub pitch: usize,
    #[doc = "< Logical width of allocation in elements"]
    pub xsize: usize,
    #[doc = "< Logical height of allocation in elements"]
    pub ysize: usize,
}
#[test]
fn bindgen_test_layout_cudaPitchedPtr() {
    assert_eq!(
        ::std::mem::size_of::<cudaPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPitchedPtr>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPitchedPtr>())).pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPitchedPtr>())).xsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPitchedPtr>())).ysize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPitchedPtr),
            "::",
            stringify!(ysize)
        )
    );
}
#[doc = " CUDA extent"]
#[doc = ""]
#[doc = " \\sa ::make_cudaExtent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExtent {
    #[doc = "< Width in elements when referring to array memory, in bytes when referring to linear memory"]
    pub width: usize,
    #[doc = "< Height in elements"]
    pub height: usize,
    #[doc = "< Depth in elements"]
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_cudaExtent() {
    assert_eq!(
        ::std::mem::size_of::<cudaExtent>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExtent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaExtent>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaExtent>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaExtent>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExtent),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = " CUDA 3D position"]
#[doc = ""]
#[doc = " \\sa ::make_cudaPos"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPos {
    #[doc = "< x"]
    pub x: usize,
    #[doc = "< y"]
    pub y: usize,
    #[doc = "< z"]
    pub z: usize,
}
#[test]
fn bindgen_test_layout_cudaPos() {
    assert_eq!(
        ::std::mem::size_of::<cudaPos>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPos))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPos>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPos>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPos>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPos>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPos),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " CUDA 3D memory copying parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DParms {
    #[doc = "< Source memory address"]
    pub srcArray: cudaArray_t,
    #[doc = "< Source position offset"]
    pub srcPos: cudaPos,
    #[doc = "< Pitched source memory address"]
    pub srcPtr: cudaPitchedPtr,
    #[doc = "< Destination memory address"]
    pub dstArray: cudaArray_t,
    #[doc = "< Destination position offset"]
    pub dstPos: cudaPos,
    #[doc = "< Pitched destination memory address"]
    pub dstPtr: cudaPitchedPtr,
    #[doc = "< Requested memory copy size"]
    pub extent: cudaExtent,
    #[doc = "< Type of transfer"]
    pub kind: cudaMemcpyKind,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).srcArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).srcPos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).srcPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).dstArray as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).dstPos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).dstPtr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).extent as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DParms>())).kind as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DParms),
            "::",
            stringify!(kind)
        )
    );
}
#[doc = " CUDA 3D cross-device memory copying parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DPeerParms {
    #[doc = "< Source memory address"]
    pub srcArray: cudaArray_t,
    #[doc = "< Source position offset"]
    pub srcPos: cudaPos,
    #[doc = "< Pitched source memory address"]
    pub srcPtr: cudaPitchedPtr,
    #[doc = "< Source device"]
    pub srcDevice: ::libc::c_int,
    #[doc = "< Destination memory address"]
    pub dstArray: cudaArray_t,
    #[doc = "< Destination position offset"]
    pub dstPos: cudaPos,
    #[doc = "< Pitched destination memory address"]
    pub dstPtr: cudaPitchedPtr,
    #[doc = "< Destination device"]
    pub dstDevice: ::libc::c_int,
    #[doc = "< Requested memory copy size"]
    pub extent: cudaExtent,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DPeerParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DPeerParms>(),
        168usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DPeerParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).srcArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).srcPos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).srcPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).srcDevice as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).dstArray as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).dstPos as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).dstPtr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).dstDevice as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemcpy3DPeerParms>())).extent as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemcpy3DPeerParms),
            "::",
            stringify!(extent)
        )
    );
}
#[doc = " CUDA Memset node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemsetParams {
    #[doc = "< Destination device pointer"]
    pub dst: *mut ::libc::c_void,
    #[doc = "< Pitch of destination device pointer. Unused if height is 1"]
    pub pitch: usize,
    #[doc = "< Value to be set"]
    pub value: ::libc::c_uint,
    #[doc = "< Size of each element in bytes. Must be 1, 2, or 4."]
    pub elementSize: ::libc::c_uint,
    #[doc = "< Width of the row in elements"]
    pub width: usize,
    #[doc = "< Number of rows"]
    pub height: usize,
}
#[test]
fn bindgen_test_layout_cudaMemsetParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemsetParams>(),
        40usize,
        concat!("Size of: ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemsetParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).elementSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemsetParams>())).height as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemsetParams),
            "::",
            stringify!(height)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Specifies performance hint with ::cudaAccessPolicyWindow for hitProp and missProp members."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaAccessProperty {
    #[doc = "< Normal cache persistence."]
    cudaAccessPropertyNormal = 0,
    #[doc = "< Streaming access is less likely to persit from cache."]
    cudaAccessPropertyStreaming = 1,
    #[doc = "< Persisting access is more likely to persist in cache."]
    cudaAccessPropertyPersisting = 2,
}
#[doc = " Specifies an access policy for a window, a contiguous extent of memory"]
#[doc = " beginning at base_ptr and ending at base_ptr + num_bytes."]
#[doc = " Partition into many segments and assign segments such that."]
#[doc = " sum of \"hit segments\" / window == approx. ratio."]
#[doc = " sum of \"miss segments\" / window == approx 1-ratio."]
#[doc = " Segments and ratio specifications are fitted to the capabilities of"]
#[doc = " the architecture."]
#[doc = " Accesses in a hit segment apply the hitProp access policy."]
#[doc = " Accesses in a miss segment apply the missProp access policy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaAccessPolicyWindow {
    #[doc = "< Starting address of the access policy window. CUDA driver may align it."]
    pub base_ptr: *mut ::libc::c_void,
    #[doc = "< Size in bytes of the window policy. CUDA driver may restrict the maximum size and alignment."]
    pub num_bytes: usize,
    #[doc = "< hitRatio specifies percentage of lines assigned hitProp, rest are assigned missProp."]
    pub hitRatio: f32,
    #[doc = "< ::CUaccessProperty set for hit."]
    pub hitProp: cudaAccessProperty,
    #[doc = "< ::CUaccessProperty set for miss. Must be either NORMAL or STREAMING."]
    pub missProp: cudaAccessProperty,
}
#[test]
fn bindgen_test_layout_cudaAccessPolicyWindow() {
    assert_eq!(
        ::std::mem::size_of::<cudaAccessPolicyWindow>(),
        32usize,
        concat!("Size of: ", stringify!(cudaAccessPolicyWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaAccessPolicyWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaAccessPolicyWindow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaAccessPolicyWindow>())).base_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(base_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaAccessPolicyWindow>())).num_bytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(num_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaAccessPolicyWindow>())).hitRatio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(hitRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaAccessPolicyWindow>())).hitProp as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(hitProp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaAccessPolicyWindow>())).missProp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaAccessPolicyWindow),
            "::",
            stringify!(missProp)
        )
    );
}
#[doc = " CUDA host function"]
#[doc = " \\param userData Argument value passed to the function"]
pub type cudaHostFn_t = ::std::option::Option<unsafe extern "C" fn(userData: *mut ::libc::c_void)>;
#[doc = " CUDA host node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaHostNodeParams {
    #[doc = "< The function to call when the node executes"]
    pub fn_: cudaHostFn_t,
    #[doc = "< Argument to pass to the function"]
    pub userData: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaHostNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaHostNodeParams>(),
        16usize,
        concat!("Size of: ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaHostNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaHostNodeParams>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaHostNodeParams),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaHostNodeParams>())).userData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaHostNodeParams),
            "::",
            stringify!(userData)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Possible stream capture statuses returned by ::cudaStreamIsCapturing"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaStreamCaptureStatus {
    #[doc = "< Stream is not capturing"]
    cudaStreamCaptureStatusNone = 0,
    #[doc = "< Stream is actively capturing"]
    cudaStreamCaptureStatusActive = 1,
    #[doc = "< Stream is part of a capture sequence that"]
    #[doc = "has been invalidated, but not terminated"]
    cudaStreamCaptureStatusInvalidated = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Possible modes for stream capture thread interactions. For more details see"]
#[doc = " ::cudaStreamBeginCapture and ::cudaThreadExchangeStreamCaptureMode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaStreamCaptureMode {
    cudaStreamCaptureModeGlobal = 0,
    cudaStreamCaptureModeThreadLocal = 1,
    cudaStreamCaptureModeRelaxed = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaSynchronizationPolicy {
    cudaSyncPolicyAuto = 1,
    cudaSyncPolicySpin = 2,
    cudaSyncPolicyYield = 3,
    cudaSyncPolicyBlockingSync = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Stream Attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaStreamAttrID {
    #[doc = "< Identifier for ::cudaStreamAttrValue::accessPolicyWindow."]
    cudaStreamAttributeAccessPolicyWindow = 1,
    #[doc = "< ::cudaSynchronizationPolicy for work queued up in this stream"]
    cudaStreamAttributeSynchronizationPolicy = 3,
}
#[doc = " Stream attributes union used with ::cudaStreamSetAttribute/::cudaStreamGetAttribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaStreamAttrValue {
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub syncPolicy: cudaSynchronizationPolicy,
}
#[test]
fn bindgen_test_layout_cudaStreamAttrValue() {
    assert_eq!(
        ::std::mem::size_of::<cudaStreamAttrValue>(),
        32usize,
        concat!("Size of: ", stringify!(cudaStreamAttrValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaStreamAttrValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaStreamAttrValue))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaStreamAttrValue>())).accessPolicyWindow as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaStreamAttrValue),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaStreamAttrValue>())).syncPolicy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaStreamAttrValue),
            "::",
            stringify!(syncPolicy)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for ::cudaStreamUpdateCaptureDependencies"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaStreamUpdateCaptureDependenciesFlags {
    #[doc = "< Add new nodes to the dependency set"]
    cudaStreamAddCaptureDependencies = 0,
    #[doc = "< Replace the dependency set with the new nodes"]
    cudaStreamSetCaptureDependencies = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for user objects for graphs"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaUserObjectFlags {
    #[doc = "< Indicates the destructor execution is not synchronized by any CUDA handle."]
    cudaUserObjectNoDestructorSync = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for retaining user object references for graphs"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaUserObjectRetainFlags {
    #[doc = "< Transfer references from the caller rather than creating new references."]
    cudaGraphUserObjectMove = 1,
}
#[doc = " CUDA graphics interop resource"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphicsResource {
    _unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA graphics interop register flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphicsRegisterFlags {
    #[doc = "< Default"]
    cudaGraphicsRegisterFlagsNone = 0,
    #[doc = "< CUDA will not write to this resource"]
    cudaGraphicsRegisterFlagsReadOnly = 1,
    #[doc = "< CUDA will only write to and will not read from this resource"]
    cudaGraphicsRegisterFlagsWriteDiscard = 2,
    #[doc = "< CUDA will bind this resource to a surface reference"]
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,
    #[doc = "< CUDA will perform texture gather operations on this resource"]
    cudaGraphicsRegisterFlagsTextureGather = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA graphics interop map flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphicsMapFlags {
    #[doc = "< Default; Assume resource can be read/written"]
    cudaGraphicsMapFlagsNone = 0,
    #[doc = "< CUDA will not write to this resource"]
    cudaGraphicsMapFlagsReadOnly = 1,
    #[doc = "< CUDA will only write to and will not read from this resource"]
    cudaGraphicsMapFlagsWriteDiscard = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA graphics interop array indices for cube maps"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphicsCubeFace {
    #[doc = "< Positive X face of cubemap"]
    cudaGraphicsCubeFacePositiveX = 0,
    #[doc = "< Negative X face of cubemap"]
    cudaGraphicsCubeFaceNegativeX = 1,
    #[doc = "< Positive Y face of cubemap"]
    cudaGraphicsCubeFacePositiveY = 2,
    #[doc = "< Negative Y face of cubemap"]
    cudaGraphicsCubeFaceNegativeY = 3,
    #[doc = "< Positive Z face of cubemap"]
    cudaGraphicsCubeFacePositiveZ = 4,
    #[doc = "< Negative Z face of cubemap"]
    cudaGraphicsCubeFaceNegativeZ = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Graph kernel node Attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaKernelNodeAttrID {
    #[doc = "< Identifier for ::cudaKernelNodeAttrValue::accessPolicyWindow."]
    cudaKernelNodeAttributeAccessPolicyWindow = 1,
    #[doc = "< Allows a kernel node to be cooperative (see ::cudaLaunchCooperativeKernel)."]
    cudaKernelNodeAttributeCooperative = 2,
}
#[doc = " Graph kernel node attributes union, used with ::cudaGraphKernelNodeSetAttribute/::cudaGraphKernelNodeGetAttribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaKernelNodeAttrValue {
    #[doc = "< Attribute ::CUaccessPolicyWindow."]
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub cooperative: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeAttrValue() {
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeAttrValue>(),
        32usize,
        concat!("Size of: ", stringify!(cudaKernelNodeAttrValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeAttrValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeAttrValue))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaKernelNodeAttrValue>())).accessPolicyWindow as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeAttrValue),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaKernelNodeAttrValue>())).cooperative as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeAttrValue),
            "::",
            stringify!(cooperative)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA resource types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaResourceType {
    #[doc = "< Array resource"]
    cudaResourceTypeArray = 0,
    #[doc = "< Mipmapped array resource"]
    cudaResourceTypeMipmappedArray = 1,
    #[doc = "< Linear resource"]
    cudaResourceTypeLinear = 2,
    #[doc = "< Pitch 2D resource"]
    cudaResourceTypePitch2D = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA texture resource view formats"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaResourceViewFormat {
    #[doc = "< No resource view format (use underlying resource format)"]
    cudaResViewFormatNone = 0,
    #[doc = "< 1 channel unsigned 8-bit integers"]
    cudaResViewFormatUnsignedChar1 = 1,
    #[doc = "< 2 channel unsigned 8-bit integers"]
    cudaResViewFormatUnsignedChar2 = 2,
    #[doc = "< 4 channel unsigned 8-bit integers"]
    cudaResViewFormatUnsignedChar4 = 3,
    #[doc = "< 1 channel signed 8-bit integers"]
    cudaResViewFormatSignedChar1 = 4,
    #[doc = "< 2 channel signed 8-bit integers"]
    cudaResViewFormatSignedChar2 = 5,
    #[doc = "< 4 channel signed 8-bit integers"]
    cudaResViewFormatSignedChar4 = 6,
    #[doc = "< 1 channel unsigned 16-bit integers"]
    cudaResViewFormatUnsignedShort1 = 7,
    #[doc = "< 2 channel unsigned 16-bit integers"]
    cudaResViewFormatUnsignedShort2 = 8,
    #[doc = "< 4 channel unsigned 16-bit integers"]
    cudaResViewFormatUnsignedShort4 = 9,
    #[doc = "< 1 channel signed 16-bit integers"]
    cudaResViewFormatSignedShort1 = 10,
    #[doc = "< 2 channel signed 16-bit integers"]
    cudaResViewFormatSignedShort2 = 11,
    #[doc = "< 4 channel signed 16-bit integers"]
    cudaResViewFormatSignedShort4 = 12,
    #[doc = "< 1 channel unsigned 32-bit integers"]
    cudaResViewFormatUnsignedInt1 = 13,
    #[doc = "< 2 channel unsigned 32-bit integers"]
    cudaResViewFormatUnsignedInt2 = 14,
    #[doc = "< 4 channel unsigned 32-bit integers"]
    cudaResViewFormatUnsignedInt4 = 15,
    #[doc = "< 1 channel signed 32-bit integers"]
    cudaResViewFormatSignedInt1 = 16,
    #[doc = "< 2 channel signed 32-bit integers"]
    cudaResViewFormatSignedInt2 = 17,
    #[doc = "< 4 channel signed 32-bit integers"]
    cudaResViewFormatSignedInt4 = 18,
    #[doc = "< 1 channel 16-bit floating point"]
    cudaResViewFormatHalf1 = 19,
    #[doc = "< 2 channel 16-bit floating point"]
    cudaResViewFormatHalf2 = 20,
    #[doc = "< 4 channel 16-bit floating point"]
    cudaResViewFormatHalf4 = 21,
    #[doc = "< 1 channel 32-bit floating point"]
    cudaResViewFormatFloat1 = 22,
    #[doc = "< 2 channel 32-bit floating point"]
    cudaResViewFormatFloat2 = 23,
    #[doc = "< 4 channel 32-bit floating point"]
    cudaResViewFormatFloat4 = 24,
    #[doc = "< Block compressed 1"]
    cudaResViewFormatUnsignedBlockCompressed1 = 25,
    #[doc = "< Block compressed 2"]
    cudaResViewFormatUnsignedBlockCompressed2 = 26,
    #[doc = "< Block compressed 3"]
    cudaResViewFormatUnsignedBlockCompressed3 = 27,
    #[doc = "< Block compressed 4 unsigned"]
    cudaResViewFormatUnsignedBlockCompressed4 = 28,
    #[doc = "< Block compressed 4 signed"]
    cudaResViewFormatSignedBlockCompressed4 = 29,
    #[doc = "< Block compressed 5 unsigned"]
    cudaResViewFormatUnsignedBlockCompressed5 = 30,
    #[doc = "< Block compressed 5 signed"]
    cudaResViewFormatSignedBlockCompressed5 = 31,
    #[doc = "< Block compressed 6 unsigned half-float"]
    cudaResViewFormatUnsignedBlockCompressed6H = 32,
    #[doc = "< Block compressed 6 signed half-float"]
    cudaResViewFormatSignedBlockCompressed6H = 33,
    #[doc = "< Block compressed 7"]
    cudaResViewFormatUnsignedBlockCompressed7 = 34,
}
#[doc = " CUDA resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaResourceDesc {
    #[doc = "< Resource type"]
    pub resType: cudaResourceType,
    pub res: cudaResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaResourceDesc__bindgen_ty_1 {
    pub array: cudaResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: cudaResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< CUDA array"]
    pub array: cudaArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>())).array
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< CUDA mipmapped array"]
    pub mipmap: cudaMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>())).mipmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mipmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: *mut ::libc::c_void,
    #[doc = "< Channel descriptor"]
    pub desc: cudaChannelFormatDesc,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>())).desc
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>())).sizeInBytes
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: *mut ::libc::c_void,
    #[doc = "< Channel descriptor"]
    pub desc: cudaChannelFormatDesc,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).desc
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>())).pitchInBytes
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1>())).array as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1>())).mipmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1>())).linear as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceDesc__bindgen_ty_1>())).pitch2D as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaResourceDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceDesc>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceDesc>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceDesc),
            "::",
            stringify!(res)
        )
    );
}
#[doc = " CUDA resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceViewDesc {
    #[doc = "< Resource view format"]
    pub format: cudaResourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::libc::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::libc::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::libc::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaResourceViewDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceViewDesc>())).firstMipmapLevel as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaResourceViewDesc>())).lastMipmapLevel as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).firstLayer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaResourceViewDesc>())).lastLayer as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaResourceViewDesc),
            "::",
            stringify!(lastLayer)
        )
    );
}
#[doc = " CUDA pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPointerAttributes {
    #[doc = " The type of memory - ::cudaMemoryTypeUnregistered, ::cudaMemoryTypeHost,"]
    #[doc = " ::cudaMemoryTypeDevice or ::cudaMemoryTypeManaged."]
    pub type_: cudaMemoryType,
    #[doc = " The device against which the memory was allocated or registered."]
    #[doc = " If the memory type is ::cudaMemoryTypeDevice then this identifies"]
    #[doc = " the device on which the memory referred physically resides.  If"]
    #[doc = " the memory type is ::cudaMemoryTypeHost or::cudaMemoryTypeManaged then"]
    #[doc = " this identifies the device which was current when the memory was allocated"]
    #[doc = " or registered (and if that device is deinitialized then this allocation"]
    #[doc = " will vanish with that device's state)."]
    pub device: ::libc::c_int,
    #[doc = " The address which may be dereferenced on the current device to access"]
    #[doc = " the memory or NULL if no such address exists."]
    pub devicePointer: *mut ::libc::c_void,
    #[doc = " The address which may be dereferenced on the host to access the"]
    #[doc = " memory or NULL if no such address exists."]
    #[doc = ""]
    #[doc = " \\note CUDA doesn't check if unregistered memory is allocated so this field"]
    #[doc = " may contain invalid pointer if an invalid pointer has been passed to CUDA."]
    pub hostPointer: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaPointerAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaPointerAttributes>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPointerAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPointerAttributes>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaPointerAttributes>())).device as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaPointerAttributes>())).devicePointer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(devicePointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaPointerAttributes>())).hostPointer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaPointerAttributes),
            "::",
            stringify!(hostPointer)
        )
    );
}
#[doc = " CUDA function attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaFuncAttributes {
    #[doc = " The size in bytes of statically-allocated shared memory per block"]
    #[doc = " required by this function. This does not include dynamically-allocated"]
    #[doc = " shared memory requested by the user at runtime."]
    pub sharedSizeBytes: usize,
    #[doc = " The size in bytes of user-allocated constant memory required by this"]
    #[doc = " function."]
    pub constSizeBytes: usize,
    #[doc = " The size in bytes of local memory used by each thread of this function."]
    pub localSizeBytes: usize,
    #[doc = " The maximum number of threads per block, beyond which a launch of the"]
    #[doc = " function would fail. This number depends on both the function and the"]
    #[doc = " device on which the function is currently loaded."]
    pub maxThreadsPerBlock: ::libc::c_int,
    #[doc = " The number of registers used by each thread of this function."]
    pub numRegs: ::libc::c_int,
    #[doc = " The PTX virtual architecture version for which the function was"]
    #[doc = " compiled. This value is the major PTX version * 10 + the minor PTX"]
    #[doc = " version, so a PTX version 1.3 function would return the value 13."]
    pub ptxVersion: ::libc::c_int,
    #[doc = " The binary architecture version for which the function was compiled."]
    #[doc = " This value is the major binary version * 10 + the minor binary version,"]
    #[doc = " so a binary version 1.3 function would return the value 13."]
    pub binaryVersion: ::libc::c_int,
    #[doc = " The attribute to indicate whether the function has been compiled with"]
    #[doc = " user specified option \"-Xptxas --dlcm=ca\" set."]
    pub cacheModeCA: ::libc::c_int,
    #[doc = " The maximum size in bytes of dynamic shared memory per block for"]
    #[doc = " this function. Any launch must have a dynamic shared memory size"]
    #[doc = " smaller than this value."]
    pub maxDynamicSharedSizeBytes: ::libc::c_int,
    #[doc = " On devices where the L1 cache and shared memory use the same hardware resources,"]
    #[doc = " this sets the shared memory carveout preference, in percent of the maximum shared memory."]
    #[doc = " Refer to ::cudaDevAttrMaxSharedMemoryPerMultiprocessor."]
    #[doc = " This is only a hint, and the driver can choose a different ratio if required to execute the function."]
    #[doc = " See ::cudaFuncSetAttribute"]
    pub preferredShmemCarveout: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaFuncAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaFuncAttributes>(),
        56usize,
        concat!("Size of: ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).sharedSizeBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(sharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).constSizeBytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(constSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).localSizeBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(localSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).maxThreadsPerBlock as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaFuncAttributes>())).numRegs as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(numRegs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaFuncAttributes>())).ptxVersion as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(ptxVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).binaryVersion as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(binaryVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaFuncAttributes>())).cacheModeCA as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(cacheModeCA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).maxDynamicSharedSizeBytes as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(maxDynamicSharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaFuncAttributes>())).preferredShmemCarveout as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaFuncAttributes),
            "::",
            stringify!(preferredShmemCarveout)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA function attributes that can be set using ::cudaFuncSetAttribute"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFuncAttribute {
    #[doc = "< Maximum dynamic shared memory size"]
    cudaFuncAttributeMaxDynamicSharedMemorySize = 8,
    #[doc = "< Preferred shared memory-L1 cache split"]
    cudaFuncAttributePreferredSharedMemoryCarveout = 9,
    cudaFuncAttributeMax = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA function cache configurations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFuncCache {
    #[doc = "< Default function cache configuration, no preference"]
    cudaFuncCachePreferNone = 0,
    #[doc = "< Prefer larger shared memory and smaller L1 cache"]
    cudaFuncCachePreferShared = 1,
    #[doc = "< Prefer larger L1 cache and smaller shared memory"]
    cudaFuncCachePreferL1 = 2,
    #[doc = "< Prefer equal size L1 cache and shared memory"]
    cudaFuncCachePreferEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA shared memory configuration"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaSharedMemConfig {
    cudaSharedMemBankSizeDefault = 0,
    cudaSharedMemBankSizeFourByte = 1,
    cudaSharedMemBankSizeEightByte = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Shared memory carveout configurations. These may be passed to cudaFuncSetAttribute"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaSharedCarveout {
    #[doc = "< No preference for shared memory or L1 (default)"]
    cudaSharedmemCarveoutDefault = -1,
    #[doc = "< Prefer maximum available shared memory, minimum L1 cache"]
    cudaSharedmemCarveoutMaxShared = 100,
    #[doc = "< Prefer maximum available L1 cache, minimum shared memory"]
    cudaSharedmemCarveoutMaxL1 = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA device compute modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaComputeMode {
    #[doc = "< Default compute mode (Multiple threads can use ::cudaSetDevice() with this device)"]
    cudaComputeModeDefault = 0,
    #[doc = "< Compute-exclusive-thread mode (Only one thread in one process will be able to use ::cudaSetDevice() with this device)"]
    cudaComputeModeExclusive = 1,
    #[doc = "< Compute-prohibited mode (No threads can use ::cudaSetDevice() with this device)"]
    cudaComputeModeProhibited = 2,
    #[doc = "< Compute-exclusive-process mode (Many threads in one process will be able to use ::cudaSetDevice() with this device)"]
    cudaComputeModeExclusiveProcess = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA Limits"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaLimit {
    #[doc = "< GPU thread stack size"]
    cudaLimitStackSize = 0,
    #[doc = "< GPU printf FIFO size"]
    cudaLimitPrintfFifoSize = 1,
    #[doc = "< GPU malloc heap size"]
    cudaLimitMallocHeapSize = 2,
    #[doc = "< GPU device runtime synchronize depth"]
    cudaLimitDevRuntimeSyncDepth = 3,
    #[doc = "< GPU device runtime pending launch count"]
    cudaLimitDevRuntimePendingLaunchCount = 4,
    #[doc = "< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint"]
    cudaLimitMaxL2FetchGranularity = 5,
    #[doc = "< A size in bytes for L2 persisting lines cache size"]
    cudaLimitPersistingL2CacheSize = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA Memory Advise values"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemoryAdvise {
    #[doc = "< Data will mostly be read and only occassionally be written to"]
    cudaMemAdviseSetReadMostly = 1,
    #[doc = "< Undo the effect of ::cudaMemAdviseSetReadMostly"]
    cudaMemAdviseUnsetReadMostly = 2,
    #[doc = "< Set the preferred location for the data as the specified device"]
    cudaMemAdviseSetPreferredLocation = 3,
    #[doc = "< Clear the preferred location for the data"]
    cudaMemAdviseUnsetPreferredLocation = 4,
    #[doc = "< Data will be accessed by the specified device, so prevent page faults as much as possible"]
    cudaMemAdviseSetAccessedBy = 5,
    #[doc = "< Let the Unified Memory subsystem decide on the page faulting policy for the specified device"]
    cudaMemAdviseUnsetAccessedBy = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA range attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemRangeAttribute {
    #[doc = "< Whether the range will mostly be read and only occassionally be written to"]
    cudaMemRangeAttributeReadMostly = 1,
    #[doc = "< The preferred location of the range"]
    cudaMemRangeAttributePreferredLocation = 2,
    #[doc = "< Memory range has ::cudaMemAdviseSetAccessedBy set for specified device"]
    cudaMemRangeAttributeAccessedBy = 3,
    #[doc = "< The last location to which the range was prefetched"]
    cudaMemRangeAttributeLastPrefetchLocation = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA Profiler Output modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaOutputMode {
    #[doc = "< Output mode Key-Value pair format."]
    cudaKeyValuePair = 0,
    #[doc = "< Output mode Comma separated values format."]
    cudaCSV = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA GPUDirect RDMA flush writes APIs supported on the device"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesOptions {
    #[doc = "< ::cudaDeviceFlushGPUDirectRDMAWrites() and its CUDA Driver API counterpart are supported on the device."]
    cudaFlushGPUDirectRDMAWritesOptionHost = 1,
    #[doc = "< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the CUDA device."]
    cudaFlushGPUDirectRDMAWritesOptionMemOps = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA GPUDirect RDMA flush writes ordering features of the device"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGPUDirectRDMAWritesOrdering {
    #[doc = "< The device does not natively support ordering of GPUDirect RDMA writes. ::cudaFlushGPUDirectRDMAWrites() can be leveraged if supported."]
    cudaGPUDirectRDMAWritesOrderingNone = 0,
    #[doc = "< Natively, the device can consistently consume GPUDirect RDMA writes, although other CUDA devices may not."]
    cudaGPUDirectRDMAWritesOrderingOwner = 100,
    #[doc = "< Any CUDA device in the system can consistently consume GPUDirect RDMA writes to this device."]
    cudaGPUDirectRDMAWritesOrderingAllDevices = 200,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA GPUDirect RDMA flush writes scopes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesScope {
    #[doc = "< Blocks until remote writes are visible to the CUDA device context owning the data."]
    cudaFlushGPUDirectRDMAWritesToOwner = 100,
    #[doc = "< Blocks until remote writes are visible to all CUDA device contexts."]
    cudaFlushGPUDirectRDMAWritesToAllDevices = 200,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA GPUDirect RDMA flush writes targets"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesTarget {
    #[doc = "< Sets the target for ::cudaDeviceFlushGPUDirectRDMAWrites() to the currently active CUDA device context."]
    cudaFlushGPUDirectRDMAWritesTargetCurrentDevice = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA device attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaDeviceAttr {
    #[doc = "< Maximum number of threads per block"]
    cudaDevAttrMaxThreadsPerBlock = 1,
    #[doc = "< Maximum block dimension X"]
    cudaDevAttrMaxBlockDimX = 2,
    #[doc = "< Maximum block dimension Y"]
    cudaDevAttrMaxBlockDimY = 3,
    #[doc = "< Maximum block dimension Z"]
    cudaDevAttrMaxBlockDimZ = 4,
    #[doc = "< Maximum grid dimension X"]
    cudaDevAttrMaxGridDimX = 5,
    #[doc = "< Maximum grid dimension Y"]
    cudaDevAttrMaxGridDimY = 6,
    #[doc = "< Maximum grid dimension Z"]
    cudaDevAttrMaxGridDimZ = 7,
    #[doc = "< Maximum shared memory available per block in bytes"]
    cudaDevAttrMaxSharedMemoryPerBlock = 8,
    #[doc = "< Memory available on device for __constant__ variables in a CUDA C kernel in bytes"]
    cudaDevAttrTotalConstantMemory = 9,
    #[doc = "< Warp size in threads"]
    cudaDevAttrWarpSize = 10,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    cudaDevAttrMaxPitch = 11,
    #[doc = "< Maximum number of 32-bit registers available per block"]
    cudaDevAttrMaxRegistersPerBlock = 12,
    #[doc = "< Peak clock frequency in kilohertz"]
    cudaDevAttrClockRate = 13,
    #[doc = "< Alignment requirement for textures"]
    cudaDevAttrTextureAlignment = 14,
    #[doc = "< Device can possibly copy memory and execute a kernel concurrently"]
    cudaDevAttrGpuOverlap = 15,
    #[doc = "< Number of multiprocessors on device"]
    cudaDevAttrMultiProcessorCount = 16,
    #[doc = "< Specifies whether there is a run time limit on kernels"]
    cudaDevAttrKernelExecTimeout = 17,
    #[doc = "< Device is integrated with host memory"]
    cudaDevAttrIntegrated = 18,
    #[doc = "< Device can map host memory into CUDA address space"]
    cudaDevAttrCanMapHostMemory = 19,
    #[doc = "< Compute mode (See ::cudaComputeMode for details)"]
    cudaDevAttrComputeMode = 20,
    #[doc = "< Maximum 1D texture width"]
    cudaDevAttrMaxTexture1DWidth = 21,
    #[doc = "< Maximum 2D texture width"]
    cudaDevAttrMaxTexture2DWidth = 22,
    #[doc = "< Maximum 2D texture height"]
    cudaDevAttrMaxTexture2DHeight = 23,
    #[doc = "< Maximum 3D texture width"]
    cudaDevAttrMaxTexture3DWidth = 24,
    #[doc = "< Maximum 3D texture height"]
    cudaDevAttrMaxTexture3DHeight = 25,
    #[doc = "< Maximum 3D texture depth"]
    cudaDevAttrMaxTexture3DDepth = 26,
    #[doc = "< Maximum 2D layered texture width"]
    cudaDevAttrMaxTexture2DLayeredWidth = 27,
    #[doc = "< Maximum 2D layered texture height"]
    cudaDevAttrMaxTexture2DLayeredHeight = 28,
    #[doc = "< Maximum layers in a 2D layered texture"]
    cudaDevAttrMaxTexture2DLayeredLayers = 29,
    #[doc = "< Alignment requirement for surfaces"]
    cudaDevAttrSurfaceAlignment = 30,
    #[doc = "< Device can possibly execute multiple kernels concurrently"]
    cudaDevAttrConcurrentKernels = 31,
    #[doc = "< Device has ECC support enabled"]
    cudaDevAttrEccEnabled = 32,
    #[doc = "< PCI bus ID of the device"]
    cudaDevAttrPciBusId = 33,
    #[doc = "< PCI device ID of the device"]
    cudaDevAttrPciDeviceId = 34,
    #[doc = "< Device is using TCC driver model"]
    cudaDevAttrTccDriver = 35,
    #[doc = "< Peak memory clock frequency in kilohertz"]
    cudaDevAttrMemoryClockRate = 36,
    #[doc = "< Global memory bus width in bits"]
    cudaDevAttrGlobalMemoryBusWidth = 37,
    #[doc = "< Size of L2 cache in bytes"]
    cudaDevAttrL2CacheSize = 38,
    #[doc = "< Maximum resident threads per multiprocessor"]
    cudaDevAttrMaxThreadsPerMultiProcessor = 39,
    #[doc = "< Number of asynchronous engines"]
    cudaDevAttrAsyncEngineCount = 40,
    #[doc = "< Device shares a unified address space with the host"]
    cudaDevAttrUnifiedAddressing = 41,
    #[doc = "< Maximum 1D layered texture width"]
    cudaDevAttrMaxTexture1DLayeredWidth = 42,
    #[doc = "< Maximum layers in a 1D layered texture"]
    cudaDevAttrMaxTexture1DLayeredLayers = 43,
    #[doc = "< Maximum 2D texture width if cudaArrayTextureGather is set"]
    cudaDevAttrMaxTexture2DGatherWidth = 45,
    #[doc = "< Maximum 2D texture height if cudaArrayTextureGather is set"]
    cudaDevAttrMaxTexture2DGatherHeight = 46,
    #[doc = "< Alternate maximum 3D texture width"]
    cudaDevAttrMaxTexture3DWidthAlt = 47,
    #[doc = "< Alternate maximum 3D texture height"]
    cudaDevAttrMaxTexture3DHeightAlt = 48,
    #[doc = "< Alternate maximum 3D texture depth"]
    cudaDevAttrMaxTexture3DDepthAlt = 49,
    #[doc = "< PCI domain ID of the device"]
    cudaDevAttrPciDomainId = 50,
    #[doc = "< Pitch alignment requirement for textures"]
    cudaDevAttrTexturePitchAlignment = 51,
    #[doc = "< Maximum cubemap texture width/height"]
    cudaDevAttrMaxTextureCubemapWidth = 52,
    #[doc = "< Maximum cubemap layered texture width/height"]
    cudaDevAttrMaxTextureCubemapLayeredWidth = 53,
    #[doc = "< Maximum layers in a cubemap layered texture"]
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54,
    #[doc = "< Maximum 1D surface width"]
    cudaDevAttrMaxSurface1DWidth = 55,
    #[doc = "< Maximum 2D surface width"]
    cudaDevAttrMaxSurface2DWidth = 56,
    #[doc = "< Maximum 2D surface height"]
    cudaDevAttrMaxSurface2DHeight = 57,
    #[doc = "< Maximum 3D surface width"]
    cudaDevAttrMaxSurface3DWidth = 58,
    #[doc = "< Maximum 3D surface height"]
    cudaDevAttrMaxSurface3DHeight = 59,
    #[doc = "< Maximum 3D surface depth"]
    cudaDevAttrMaxSurface3DDepth = 60,
    #[doc = "< Maximum 1D layered surface width"]
    cudaDevAttrMaxSurface1DLayeredWidth = 61,
    #[doc = "< Maximum layers in a 1D layered surface"]
    cudaDevAttrMaxSurface1DLayeredLayers = 62,
    #[doc = "< Maximum 2D layered surface width"]
    cudaDevAttrMaxSurface2DLayeredWidth = 63,
    #[doc = "< Maximum 2D layered surface height"]
    cudaDevAttrMaxSurface2DLayeredHeight = 64,
    #[doc = "< Maximum layers in a 2D layered surface"]
    cudaDevAttrMaxSurface2DLayeredLayers = 65,
    #[doc = "< Maximum cubemap surface width"]
    cudaDevAttrMaxSurfaceCubemapWidth = 66,
    #[doc = "< Maximum cubemap layered surface width"]
    cudaDevAttrMaxSurfaceCubemapLayeredWidth = 67,
    #[doc = "< Maximum layers in a cubemap layered surface"]
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68,
    #[doc = "< Maximum 1D linear texture width"]
    cudaDevAttrMaxTexture1DLinearWidth = 69,
    #[doc = "< Maximum 2D linear texture width"]
    cudaDevAttrMaxTexture2DLinearWidth = 70,
    #[doc = "< Maximum 2D linear texture height"]
    cudaDevAttrMaxTexture2DLinearHeight = 71,
    #[doc = "< Maximum 2D linear texture pitch in bytes"]
    cudaDevAttrMaxTexture2DLinearPitch = 72,
    #[doc = "< Maximum mipmapped 2D texture width"]
    cudaDevAttrMaxTexture2DMipmappedWidth = 73,
    #[doc = "< Maximum mipmapped 2D texture height"]
    cudaDevAttrMaxTexture2DMipmappedHeight = 74,
    #[doc = "< Major compute capability version number"]
    cudaDevAttrComputeCapabilityMajor = 75,
    #[doc = "< Minor compute capability version number"]
    cudaDevAttrComputeCapabilityMinor = 76,
    #[doc = "< Maximum mipmapped 1D texture width"]
    cudaDevAttrMaxTexture1DMipmappedWidth = 77,
    #[doc = "< Device supports stream priorities"]
    cudaDevAttrStreamPrioritiesSupported = 78,
    #[doc = "< Device supports caching globals in L1"]
    cudaDevAttrGlobalL1CacheSupported = 79,
    #[doc = "< Device supports caching locals in L1"]
    cudaDevAttrLocalL1CacheSupported = 80,
    #[doc = "< Maximum shared memory available per multiprocessor in bytes"]
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81,
    #[doc = "< Maximum number of 32-bit registers available per multiprocessor"]
    cudaDevAttrMaxRegistersPerMultiprocessor = 82,
    #[doc = "< Device can allocate managed memory on this system"]
    cudaDevAttrManagedMemory = 83,
    #[doc = "< Device is on a multi-GPU board"]
    cudaDevAttrIsMultiGpuBoard = 84,
    #[doc = "< Unique identifier for a group of devices on the same multi-GPU board"]
    cudaDevAttrMultiGpuBoardGroupID = 85,
    #[doc = "< Link between the device and the host supports native atomic operations"]
    cudaDevAttrHostNativeAtomicSupported = 86,
    #[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
    cudaDevAttrSingleToDoublePrecisionPerfRatio = 87,
    #[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
    cudaDevAttrPageableMemoryAccess = 88,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    cudaDevAttrConcurrentManagedAccess = 89,
    #[doc = "< Device supports Compute Preemption"]
    cudaDevAttrComputePreemptionSupported = 90,
    #[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
    cudaDevAttrCanUseHostPointerForRegisteredMem = 91,
    cudaDevAttrReserved92 = 92,
    cudaDevAttrReserved93 = 93,
    cudaDevAttrReserved94 = 94,
    #[doc = "< Device supports launching cooperative kernels via ::cudaLaunchCooperativeKernel"]
    cudaDevAttrCooperativeLaunch = 95,
    #[doc = "< Deprecated, cudaLaunchCooperativeKernelMultiDevice is deprecated."]
    cudaDevAttrCooperativeMultiDeviceLaunch = 96,
    #[doc = "< The maximum optin shared memory per block. This value may vary by chip. See ::cudaFuncSetAttribute"]
    cudaDevAttrMaxSharedMemoryPerBlockOptin = 97,
    #[doc = "< Device supports flushing of outstanding remote writes."]
    cudaDevAttrCanFlushRemoteWrites = 98,
    #[doc = "< Device supports host memory registration via ::cudaHostRegister."]
    cudaDevAttrHostRegisterSupported = 99,
    #[doc = "< Device accesses pageable memory via the host's page tables."]
    cudaDevAttrPageableMemoryAccessUsesHostPageTables = 100,
    #[doc = "< Host can directly access managed memory on the device without migration."]
    cudaDevAttrDirectManagedMemAccessFromHost = 101,
    #[doc = "< Maximum number of blocks per multiprocessor"]
    cudaDevAttrMaxBlocksPerMultiprocessor = 106,
    #[doc = "< Maximum L2 persisting lines capacity setting in bytes."]
    cudaDevAttrMaxPersistingL2CacheSize = 108,
    #[doc = "< Maximum value of cudaAccessPolicyWindow::num_bytes."]
    cudaDevAttrMaxAccessPolicyWindowSize = 109,
    #[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
    cudaDevAttrReservedSharedMemoryPerBlock = 111,
    #[doc = "< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays"]
    cudaDevAttrSparseCudaArraySupported = 112,
    #[doc = "< Device supports using the ::cudaHostRegister flag cudaHostRegisterReadOnly to register memory that must be mapped as read-only to the GPU"]
    cudaDevAttrHostRegisterReadOnlySupported = 113,
    #[doc = "< External timeline semaphore interop is supported on the device"]
    cudaDevAttrMaxTimelineSemaphoreInteropSupported = 114,
    #[doc = "< Device supports using the ::cudaMallocAsync and ::cudaMemPool family of APIs"]
    cudaDevAttrMemoryPoolsSupported = 115,
    #[doc = "< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)"]
    cudaDevAttrGPUDirectRDMASupported = 116,
    #[doc = "< The returned attribute shall be interpreted as a bitmask, where the individual bits are listed in the ::cudaFlushGPUDirectRDMAWritesOptions enum"]
    cudaDevAttrGPUDirectRDMAFlushWritesOptions = 117,
    #[doc = "< GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::cudaGPUDirectRDMAWritesOrdering for the numerical values returned here."]
    cudaDevAttrGPUDirectRDMAWritesOrdering = 118,
    #[doc = "< Handle types supported with mempool based IPC"]
    cudaDevAttrMemoryPoolSupportedHandleTypes = 119,
    cudaDevAttrMax = 120,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA memory pool attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemPoolAttr {
    #[doc = " (value type = int)"]
    #[doc = " Allow cuMemAllocAsync to use memory asynchronously freed"]
    #[doc = " in another streams as long as a stream ordering dependency"]
    #[doc = " of the allocating stream on the free action exists."]
    #[doc = " Cuda events and null stream interactions can create the required"]
    #[doc = " stream ordered dependencies. (default enabled)"]
    cudaMemPoolReuseFollowEventDependencies = 1,
    #[doc = " (value type = int)"]
    #[doc = " Allow reuse of already completed frees when there is no dependency"]
    #[doc = " between the free and allocation. (default enabled)"]
    cudaMemPoolReuseAllowOpportunistic = 2,
    #[doc = " (value type = int)"]
    #[doc = " Allow cuMemAllocAsync to insert new stream dependencies"]
    #[doc = " in order to establish the stream ordering required to reuse"]
    #[doc = " a piece of memory released by cuFreeAsync (default enabled)."]
    cudaMemPoolReuseAllowInternalDependencies = 3,
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " Amount of reserved memory in bytes to hold onto before trying"]
    #[doc = " to release memory back to the OS. When more than the release"]
    #[doc = " threshold bytes of memory are held by the memory pool, the"]
    #[doc = " allocator will try to release memory back to the OS on the"]
    #[doc = " next call to stream, event or context synchronize. (default 0)"]
    cudaMemPoolAttrReleaseThreshold = 4,
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " Amount of backing memory currently allocated for the mempool."]
    cudaMemPoolAttrReservedMemCurrent = 5,
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " High watermark of backing memory allocated for the mempool since the"]
    #[doc = " last time it was reset. High watermark can only be reset to zero."]
    cudaMemPoolAttrReservedMemHigh = 6,
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " Amount of memory from the pool that is currently in use by the application."]
    cudaMemPoolAttrUsedMemCurrent = 7,
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " High watermark of the amount of memory from the pool that was in use by the application since"]
    #[doc = " the last time it was reset. High watermark can only be reset to zero."]
    cudaMemPoolAttrUsedMemHigh = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Specifies the type of location"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemLocationType {
    cudaMemLocationTypeInvalid = 0,
    #[doc = "< Location is a device location, thus id is a device ordinal"]
    cudaMemLocationTypeDevice = 1,
}
#[doc = " Specifies a memory location."]
#[doc = ""]
#[doc = " To specify a gpu, set type = ::cudaMemLocationTypeDevice and set id = the gpu's device ordinal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemLocation {
    #[doc = "< Specifies the location type, which modifies the meaning of id."]
    pub type_: cudaMemLocationType,
    #[doc = "< identifier for a given this location's ::CUmemLocationType."]
    pub id: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaMemLocation() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemLocation>(),
        8usize,
        concat!("Size of: ", stringify!(cudaMemLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemLocation>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemLocation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemLocation>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemLocation),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemLocation>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemLocation),
            "::",
            stringify!(id)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Specifies the memory protection flags for mapping."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemAccessFlags {
    #[doc = "< Default, make the address range not accessible"]
    cudaMemAccessFlagsProtNone = 0,
    #[doc = "< Make the address range read accessible"]
    cudaMemAccessFlagsProtRead = 1,
    #[doc = "< Make the address range read-write accessible"]
    cudaMemAccessFlagsProtReadWrite = 3,
}
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAccessDesc {
    #[doc = "< Location on which the request is to change it's accessibility"]
    pub location: cudaMemLocation,
    #[doc = "< ::CUmemProt accessibility flags to set on the request"]
    pub flags: cudaMemAccessFlags,
}
#[test]
fn bindgen_test_layout_cudaMemAccessDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemAccessDesc>(),
        12usize,
        concat!("Size of: ", stringify!(cudaMemAccessDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAccessDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemAccessDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemAccessDesc>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAccessDesc),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemAccessDesc>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAccessDesc),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Defines the allocation types available"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemAllocationType {
    cudaMemAllocationTypeInvalid = 0,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current"]
    #[doc = " location while the application is actively using it"]
    cudaMemAllocationTypePinned = 1,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current"]
    #[doc = " location while the application is actively using it"]
    cudaMemAllocationTypeMax = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for specifying particular handle types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaMemAllocationHandleType {
    #[doc = "< Does not allow any export mechanism. >"]
    cudaMemHandleTypeNone = 0,
    #[doc = "< Allows a file descriptor to be used for exporting. Permitted only on POSIX systems. (int)"]
    cudaMemHandleTypePosixFileDescriptor = 1,
    #[doc = "< Allows a Win32 NT handle to be used for exporting. (HANDLE)"]
    cudaMemHandleTypeWin32 = 2,
    #[doc = "< Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)"]
    cudaMemHandleTypeWin32Kmt = 4,
}
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaMemPoolProps {
    #[doc = "< Allocation type. Currently must be specified as cudaMemAllocationTypePinned"]
    pub allocType: cudaMemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool."]
    pub handleTypes: cudaMemAllocationHandleType,
    #[doc = "< Location allocations should reside."]
    pub location: cudaMemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when"]
    #[doc = " ::cudaMemHandleTypeWin32 is specified.  This security attribute defines"]
    #[doc = " the scope of which exported allocations may be tranferred to other"]
    #[doc = " processes.  In all other cases, this field is required to be zero."]
    pub win32SecurityAttributes: *mut ::libc::c_void,
    #[doc = "< reserved for future use, must be 0"]
    pub reserved: [::libc::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolProps() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolProps>(),
        88usize,
        concat!("Size of: ", stringify!(cudaMemPoolProps))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolProps>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemPoolProps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemPoolProps>())).allocType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(allocType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemPoolProps>())).handleTypes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(handleTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemPoolProps>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaMemPoolProps>())).win32SecurityAttributes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(win32SecurityAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemPoolProps>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolProps),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Opaque data for exporting a pool allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaMemPoolPtrExportData {
    pub reserved: [::libc::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolPtrExportData() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolPtrExportData>(),
        64usize,
        concat!("Size of: ", stringify!(cudaMemPoolPtrExportData))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolPtrExportData>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaMemPoolPtrExportData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaMemPoolPtrExportData>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemPoolPtrExportData),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Memory allocation node parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaMemAllocNodeParams {
    #[doc = "< in: array of memory access descriptors. Used to describe peer GPU access"]
    pub poolProps: cudaMemPoolProps,
    #[doc = "< in: number of memory access descriptors.  Must not exceed the number of GPUs."]
    pub accessDescs: *const cudaMemAccessDesc,
    #[doc = "< in: Number of `accessDescs`s"]
    pub accessDescCount: usize,
    #[doc = "< in: size in bytes of the requested allocation"]
    pub bytesize: usize,
    #[doc = "< out: address of the allocation returned by CUDA"]
    pub dptr: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaMemAllocNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemAllocNodeParams>(),
        120usize,
        concat!("Size of: ", stringify!(cudaMemAllocNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAllocNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemAllocNodeParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaMemAllocNodeParams>())).poolProps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(poolProps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaMemAllocNodeParams>())).accessDescs as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(accessDescs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaMemAllocNodeParams>())).accessDescCount as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(accessDescCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemAllocNodeParams>())).bytesize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(bytesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaMemAllocNodeParams>())).dptr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaMemAllocNodeParams),
            "::",
            stringify!(dptr)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Graph memory attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphMemAttributeType {
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " Amount of memory, in bytes, currently associated with graphs."]
    cudaGraphMemAttrUsedMemCurrent = 1,
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " High watermark of memory, in bytes, associated with graphs since the"]
    #[doc = " last time it was reset.  High watermark can only be reset to zero."]
    cudaGraphMemAttrUsedMemHigh = 2,
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " Amount of memory, in bytes, currently allocated for use by"]
    #[doc = " the CUDA graphs asynchronous allocator."]
    cudaGraphMemAttrReservedMemCurrent = 3,
    #[doc = " (value type = cuuint64_t)"]
    #[doc = " High watermark of memory, in bytes, currently allocated for use by"]
    #[doc = " the CUDA graphs asynchronous allocator."]
    cudaGraphMemAttrReservedMemHigh = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA device P2P attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaDeviceP2PAttr {
    #[doc = "< A relative value indicating the performance of the link between two devices"]
    cudaDevP2PAttrPerformanceRank = 1,
    #[doc = "< Peer access is enabled"]
    cudaDevP2PAttrAccessSupported = 2,
    #[doc = "< Native atomic operation over the link supported"]
    cudaDevP2PAttrNativeAtomicSupported = 3,
    #[doc = "< Accessing CUDA arrays over the link supported"]
    cudaDevP2PAttrCudaArrayAccessSupported = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CUuuid_st>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUuuid_st),
            "::",
            stringify!(bytes)
        )
    );
}
pub type CUuuid = CUuuid_st;
pub type cudaUUID_t = CUuuid_st;
#[doc = " CUDA device properties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaDeviceProp {
    #[doc = "< ASCII string identifying device"]
    pub name: [::libc::c_char; 256usize],
    #[doc = "< 16-byte unique identifier"]
    pub uuid: cudaUUID_t,
    #[doc = "< 8-byte locally unique identifier. Value is undefined on TCC and non-Windows platforms"]
    pub luid: [::libc::c_char; 8usize],
    #[doc = "< LUID device node mask. Value is undefined on TCC and non-Windows platforms"]
    pub luidDeviceNodeMask: ::libc::c_uint,
    #[doc = "< Global memory available on device in bytes"]
    pub totalGlobalMem: usize,
    #[doc = "< Shared memory available per block in bytes"]
    pub sharedMemPerBlock: usize,
    #[doc = "< 32-bit registers available per block"]
    pub regsPerBlock: ::libc::c_int,
    #[doc = "< Warp size in threads"]
    pub warpSize: ::libc::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: usize,
    #[doc = "< Maximum number of threads per block"]
    pub maxThreadsPerBlock: ::libc::c_int,
    #[doc = "< Maximum size of each dimension of a block"]
    pub maxThreadsDim: [::libc::c_int; 3usize],
    #[doc = "< Maximum size of each dimension of a grid"]
    pub maxGridSize: [::libc::c_int; 3usize],
    #[doc = "< Clock frequency in kilohertz"]
    pub clockRate: ::libc::c_int,
    #[doc = "< Constant memory available on device in bytes"]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability"]
    pub major: ::libc::c_int,
    #[doc = "< Minor compute capability"]
    pub minor: ::libc::c_int,
    #[doc = "< Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "< Pitch alignment requirement for texture references bound to pitched memory"]
    pub texturePitchAlignment: usize,
    #[doc = "< Device can concurrently copy memory and execute a kernel. Deprecated. Use instead asyncEngineCount."]
    pub deviceOverlap: ::libc::c_int,
    #[doc = "< Number of multiprocessors on device"]
    pub multiProcessorCount: ::libc::c_int,
    #[doc = "< Specified whether there is a run time limit on kernels"]
    pub kernelExecTimeoutEnabled: ::libc::c_int,
    #[doc = "< Device is integrated as opposed to discrete"]
    pub integrated: ::libc::c_int,
    #[doc = "< Device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer"]
    pub canMapHostMemory: ::libc::c_int,
    #[doc = "< Compute mode (See ::cudaComputeMode)"]
    pub computeMode: ::libc::c_int,
    #[doc = "< Maximum 1D texture size"]
    pub maxTexture1D: ::libc::c_int,
    #[doc = "< Maximum 1D mipmapped texture size"]
    pub maxTexture1DMipmap: ::libc::c_int,
    #[doc = "< Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth() or cuDeviceGetTexture1DLinearMaxWidth() instead."]
    pub maxTexture1DLinear: ::libc::c_int,
    #[doc = "< Maximum 2D texture dimensions"]
    pub maxTexture2D: [::libc::c_int; 2usize],
    #[doc = "< Maximum 2D mipmapped texture dimensions"]
    pub maxTexture2DMipmap: [::libc::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, pitch) for 2D textures bound to pitched memory"]
    pub maxTexture2DLinear: [::libc::c_int; 3usize],
    #[doc = "< Maximum 2D texture dimensions if texture gather operations have to be performed"]
    pub maxTexture2DGather: [::libc::c_int; 2usize],
    #[doc = "< Maximum 3D texture dimensions"]
    pub maxTexture3D: [::libc::c_int; 3usize],
    #[doc = "< Maximum alternate 3D texture dimensions"]
    pub maxTexture3DAlt: [::libc::c_int; 3usize],
    #[doc = "< Maximum Cubemap texture dimensions"]
    pub maxTextureCubemap: ::libc::c_int,
    #[doc = "< Maximum 1D layered texture dimensions"]
    pub maxTexture1DLayered: [::libc::c_int; 2usize],
    #[doc = "< Maximum 2D layered texture dimensions"]
    pub maxTexture2DLayered: [::libc::c_int; 3usize],
    #[doc = "< Maximum Cubemap layered texture dimensions"]
    pub maxTextureCubemapLayered: [::libc::c_int; 2usize],
    #[doc = "< Maximum 1D surface size"]
    pub maxSurface1D: ::libc::c_int,
    #[doc = "< Maximum 2D surface dimensions"]
    pub maxSurface2D: [::libc::c_int; 2usize],
    #[doc = "< Maximum 3D surface dimensions"]
    pub maxSurface3D: [::libc::c_int; 3usize],
    #[doc = "< Maximum 1D layered surface dimensions"]
    pub maxSurface1DLayered: [::libc::c_int; 2usize],
    #[doc = "< Maximum 2D layered surface dimensions"]
    pub maxSurface2DLayered: [::libc::c_int; 3usize],
    #[doc = "< Maximum Cubemap surface dimensions"]
    pub maxSurfaceCubemap: ::libc::c_int,
    #[doc = "< Maximum Cubemap layered surface dimensions"]
    pub maxSurfaceCubemapLayered: [::libc::c_int; 2usize],
    #[doc = "< Alignment requirements for surfaces"]
    pub surfaceAlignment: usize,
    #[doc = "< Device can possibly execute multiple kernels concurrently"]
    pub concurrentKernels: ::libc::c_int,
    #[doc = "< Device has ECC support enabled"]
    pub ECCEnabled: ::libc::c_int,
    #[doc = "< PCI bus ID of the device"]
    pub pciBusID: ::libc::c_int,
    #[doc = "< PCI device ID of the device"]
    pub pciDeviceID: ::libc::c_int,
    #[doc = "< PCI domain ID of the device"]
    pub pciDomainID: ::libc::c_int,
    #[doc = "< 1 if device is a Tesla device using TCC driver, 0 otherwise"]
    pub tccDriver: ::libc::c_int,
    #[doc = "< Number of asynchronous engines"]
    pub asyncEngineCount: ::libc::c_int,
    #[doc = "< Device shares a unified address space with the host"]
    pub unifiedAddressing: ::libc::c_int,
    #[doc = "< Peak memory clock frequency in kilohertz"]
    pub memoryClockRate: ::libc::c_int,
    #[doc = "< Global memory bus width in bits"]
    pub memoryBusWidth: ::libc::c_int,
    #[doc = "< Size of L2 cache in bytes"]
    pub l2CacheSize: ::libc::c_int,
    #[doc = "< Device's maximum l2 persisting lines capacity setting in bytes"]
    pub persistingL2CacheMaxSize: ::libc::c_int,
    #[doc = "< Maximum resident threads per multiprocessor"]
    pub maxThreadsPerMultiProcessor: ::libc::c_int,
    #[doc = "< Device supports stream priorities"]
    pub streamPrioritiesSupported: ::libc::c_int,
    #[doc = "< Device supports caching globals in L1"]
    pub globalL1CacheSupported: ::libc::c_int,
    #[doc = "< Device supports caching locals in L1"]
    pub localL1CacheSupported: ::libc::c_int,
    #[doc = "< Shared memory available per multiprocessor in bytes"]
    pub sharedMemPerMultiprocessor: usize,
    #[doc = "< 32-bit registers available per multiprocessor"]
    pub regsPerMultiprocessor: ::libc::c_int,
    #[doc = "< Device supports allocating managed memory on this system"]
    pub managedMemory: ::libc::c_int,
    #[doc = "< Device is on a multi-GPU board"]
    pub isMultiGpuBoard: ::libc::c_int,
    #[doc = "< Unique identifier for a group of devices on the same multi-GPU board"]
    pub multiGpuBoardGroupID: ::libc::c_int,
    #[doc = "< Link between the device and the host supports native atomic operations"]
    pub hostNativeAtomicSupported: ::libc::c_int,
    #[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
    pub singleToDoublePrecisionPerfRatio: ::libc::c_int,
    #[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
    pub pageableMemoryAccess: ::libc::c_int,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    pub concurrentManagedAccess: ::libc::c_int,
    #[doc = "< Device supports Compute Preemption"]
    pub computePreemptionSupported: ::libc::c_int,
    #[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
    pub canUseHostPointerForRegisteredMem: ::libc::c_int,
    #[doc = "< Device supports launching cooperative kernels via ::cudaLaunchCooperativeKernel"]
    pub cooperativeLaunch: ::libc::c_int,
    #[doc = "< Deprecated, cudaLaunchCooperativeKernelMultiDevice is deprecated."]
    pub cooperativeMultiDeviceLaunch: ::libc::c_int,
    #[doc = "< Per device maximum shared memory per block usable by special opt in"]
    pub sharedMemPerBlockOptin: usize,
    #[doc = "< Device accesses pageable memory via the host's page tables"]
    pub pageableMemoryAccessUsesHostPageTables: ::libc::c_int,
    #[doc = "< Host can directly access managed memory on the device without migration."]
    pub directManagedMemAccessFromHost: ::libc::c_int,
    #[doc = "< Maximum number of resident blocks per multiprocessor"]
    pub maxBlocksPerMultiProcessor: ::libc::c_int,
    #[doc = "< The maximum value of ::cudaAccessPolicyWindow::num_bytes."]
    pub accessPolicyMaxWindowSize: ::libc::c_int,
    #[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
    pub reservedSharedMemPerBlock: usize,
}
#[test]
fn bindgen_test_layout_cudaDeviceProp() {
    assert_eq!(
        ::std::mem::size_of::<cudaDeviceProp>(),
        728usize,
        concat!("Size of: ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaDeviceProp>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).uuid as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).luid as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(luid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).luidDeviceNodeMask as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(luidDeviceNodeMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).totalGlobalMem as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(totalGlobalMem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).sharedMemPerBlock as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).regsPerBlock as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).warpSize as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(warpSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).memPitch as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxThreadsPerBlock as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxThreadsDim as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxGridSize as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).clockRate as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).totalConstMem as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(totalConstMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).major as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).minor as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).textureAlignment as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(textureAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).texturePitchAlignment as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(texturePitchAlignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).deviceOverlap as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(deviceOverlap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).multiProcessorCount as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(multiProcessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).kernelExecTimeoutEnabled as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(kernelExecTimeoutEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).integrated as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(integrated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).canMapHostMemory as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(canMapHostMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).computeMode as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(computeMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture1D as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture1DMipmap as *const _ as usize
        },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DMipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture1DLinear as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DLinear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2D as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2DMipmap as *const _ as usize
        },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DMipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2DLinear as *const _ as usize
        },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DLinear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2DGather as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DGather)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture3D as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture3D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture3DAlt as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture3DAlt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTextureCubemap as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTextureCubemap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture1DLayered as *const _ as usize
        },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture1DLayered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTexture2DLayered as *const _ as usize
        },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTexture2DLayered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxTextureCubemapLayered as *const _ as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxTextureCubemapLayered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface1D as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface1D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface2D as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface2D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface3D as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface3D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface1DLayered as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface1DLayered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurface2DLayered as *const _ as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurface2DLayered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurfaceCubemap as *const _ as usize
        },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurfaceCubemap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxSurfaceCubemapLayered as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxSurfaceCubemapLayered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).surfaceAlignment as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(surfaceAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).concurrentKernels as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(concurrentKernels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).ECCEnabled as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(ECCEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).pciBusID as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciBusID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).pciDeviceID as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciDeviceID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).pciDomainID as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pciDomainID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).tccDriver as *const _ as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(tccDriver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).asyncEngineCount as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(asyncEngineCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).unifiedAddressing as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(unifiedAddressing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).memoryClockRate as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memoryClockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).memoryBusWidth as *const _ as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(memoryBusWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).l2CacheSize as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(l2CacheSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).persistingL2CacheMaxSize as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(persistingL2CacheMaxSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxThreadsPerMultiProcessor as *const _
                as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxThreadsPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).streamPrioritiesSupported as *const _
                as usize
        },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(streamPrioritiesSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).globalL1CacheSupported as *const _ as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(globalL1CacheSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).localL1CacheSupported as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(localL1CacheSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).sharedMemPerMultiprocessor as *const _
                as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerMultiprocessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).regsPerMultiprocessor as *const _ as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(regsPerMultiprocessor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).managedMemory as *const _ as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(managedMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaDeviceProp>())).isMultiGpuBoard as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(isMultiGpuBoard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).multiGpuBoardGroupID as *const _ as usize
        },
        660usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(multiGpuBoardGroupID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).hostNativeAtomicSupported as *const _
                as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(hostNativeAtomicSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).singleToDoublePrecisionPerfRatio as *const _
                as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(singleToDoublePrecisionPerfRatio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).pageableMemoryAccess as *const _ as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pageableMemoryAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).concurrentManagedAccess as *const _ as usize
        },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(concurrentManagedAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).computePreemptionSupported as *const _
                as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(computePreemptionSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).canUseHostPointerForRegisteredMem as *const _
                as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(canUseHostPointerForRegisteredMem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).cooperativeLaunch as *const _ as usize
        },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(cooperativeLaunch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).cooperativeMultiDeviceLaunch as *const _
                as usize
        },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(cooperativeMultiDeviceLaunch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).sharedMemPerBlockOptin as *const _ as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(sharedMemPerBlockOptin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).pageableMemoryAccessUsesHostPageTables
                as *const _ as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(pageableMemoryAccessUsesHostPageTables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).directManagedMemAccessFromHost as *const _
                as usize
        },
        708usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(directManagedMemAccessFromHost)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).maxBlocksPerMultiProcessor as *const _
                as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(maxBlocksPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).accessPolicyMaxWindowSize as *const _
                as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(accessPolicyMaxWindowSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaDeviceProp>())).reservedSharedMemPerBlock as *const _
                as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaDeviceProp),
            "::",
            stringify!(reservedSharedMemPerBlock)
        )
    );
}
#[doc = " CUDA IPC event handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaIpcEventHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaIpcEventHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaIpcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA IPC event handle"]
pub type cudaIpcEventHandle_t = cudaIpcEventHandle_st;
#[doc = " CUDA IPC memory handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaIpcMemHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaIpcMemHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaIpcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA IPC memory handle"]
pub type cudaIpcMemHandle_t = cudaIpcMemHandle_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " External memory handle types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaExternalMemoryHandleType {
    #[doc = " Handle is an opaque file descriptor"]
    cudaExternalMemoryHandleTypeOpaqueFd = 1,
    #[doc = " Handle is an opaque shared NT handle"]
    cudaExternalMemoryHandleTypeOpaqueWin32 = 2,
    #[doc = " Handle is an opaque, globally shared handle"]
    cudaExternalMemoryHandleTypeOpaqueWin32Kmt = 3,
    #[doc = " Handle is a D3D12 heap object"]
    cudaExternalMemoryHandleTypeD3D12Heap = 4,
    #[doc = " Handle is a D3D12 committed resource"]
    cudaExternalMemoryHandleTypeD3D12Resource = 5,
    #[doc = "  Handle is a shared NT handle to a D3D11 resource"]
    cudaExternalMemoryHandleTypeD3D11Resource = 6,
    #[doc = "  Handle is a globally shared handle to a D3D11 resource"]
    cudaExternalMemoryHandleTypeD3D11ResourceKmt = 7,
    #[doc = "  Handle is an NvSciBuf object"]
    cudaExternalMemoryHandleTypeNvSciBuf = 8,
}
#[doc = " External memory handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc {
    #[doc = " Type of the handle"]
    pub type_: cudaExternalMemoryHandleType,
    pub handle: cudaExternalMemoryHandleDesc__bindgen_ty_1,
    #[doc = " Size of the memory allocation"]
    pub size: ::libc::c_ulonglong,
    #[doc = " Flags must either be zero or ::cudaExternalMemoryDedicated"]
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalMemoryHandleDesc__bindgen_ty_1 {
    #[doc = " File descriptor referencing the memory object. Valid"]
    #[doc = " when type is"]
    #[doc = " ::cudaExternalMemoryHandleTypeOpaqueFd"]
    pub fd: ::libc::c_int,
    pub win32: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    #[doc = " A handle representing NvSciBuf Object. Valid when type"]
    #[doc = " is ::cudaExternalMemoryHandleTypeNvSciBuf"]
    pub nvSciBufObject: *const ::libc::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when"]
#[doc = " type is one of the following:"]
#[doc = " - ::cudaExternalMemoryHandleTypeOpaqueWin32"]
#[doc = " - ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt"]
#[doc = " - ::cudaExternalMemoryHandleTypeD3D12Heap"]
#[doc = " - ::cudaExternalMemoryHandleTypeD3D12Resource"]
#[doc = " - ::cudaExternalMemoryHandleTypeD3D11Resource"]
#[doc = " - ::cudaExternalMemoryHandleTypeD3D11ResourceKmt"]
#[doc = " Exactly one of 'handle' and 'name' must be non-NULL. If"]
#[doc = " type is one of the following:"]
#[doc = " ::cudaExternalMemoryHandleTypeOpaqueWin32Kmt"]
#[doc = " ::cudaExternalMemoryHandleTypeD3D11ResourceKmt"]
#[doc = " then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::libc::c_void,
    #[doc = " Name of a valid memory object."]
    #[doc = " Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>()))
                .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>()))
                .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1>())).fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1>())).win32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc__bindgen_ty_1>())).nvSciBufObject
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
            "::",
            stringify!(nvSciBufObject)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc>())).handle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc>())).size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryHandleDesc>())).flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryHandleDesc),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " External memory buffer descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryBufferDesc {
    #[doc = " Offset into the memory object where the buffer's base is"]
    pub offset: ::libc::c_ulonglong,
    #[doc = " Size of the buffer"]
    pub size: ::libc::c_ulonglong,
    #[doc = " Flags reserved for future use. Must be zero."]
    pub flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryBufferDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryBufferDesc>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryBufferDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryBufferDesc>())).offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryBufferDesc>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryBufferDesc>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryBufferDesc),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " External memory mipmap descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryMipmappedArrayDesc {
    #[doc = " Offset into the memory object where the base level of the"]
    #[doc = " mipmap chain is."]
    pub offset: ::libc::c_ulonglong,
    #[doc = " Format of base level of the mipmap chain"]
    pub formatDesc: cudaChannelFormatDesc,
    #[doc = " Dimensions of base level of the mipmap chain"]
    pub extent: cudaExtent,
    #[doc = " Flags associated with CUDA mipmapped arrays."]
    #[doc = " See ::cudaMallocMipmappedArray"]
    pub flags: ::libc::c_uint,
    #[doc = " Total number of levels in the mipmap chain"]
    pub numLevels: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryMipmappedArrayDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).formatDesc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(formatDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).extent as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).flags as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalMemoryMipmappedArrayDesc>())).numLevels as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc),
            "::",
            stringify!(numLevels)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " External semaphore handle types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaExternalSemaphoreHandleType {
    #[doc = " Handle is an opaque file descriptor"]
    cudaExternalSemaphoreHandleTypeOpaqueFd = 1,
    #[doc = " Handle is an opaque shared NT handle"]
    cudaExternalSemaphoreHandleTypeOpaqueWin32 = 2,
    #[doc = " Handle is an opaque, globally shared handle"]
    cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,
    #[doc = " Handle is a shared NT handle referencing a D3D12 fence object"]
    cudaExternalSemaphoreHandleTypeD3D12Fence = 4,
    #[doc = " Handle is a shared NT handle referencing a D3D11 fence object"]
    cudaExternalSemaphoreHandleTypeD3D11Fence = 5,
    #[doc = " Opaque handle to NvSciSync Object"]
    cudaExternalSemaphoreHandleTypeNvSciSync = 6,
    #[doc = " Handle is a shared NT handle referencing a D3D11 keyed mutex object"]
    cudaExternalSemaphoreHandleTypeKeyedMutex = 7,
    #[doc = " Handle is a shared KMT handle referencing a D3D11 keyed mutex object"]
    cudaExternalSemaphoreHandleTypeKeyedMutexKmt = 8,
    #[doc = " Handle is an opaque handle file descriptor referencing a timeline semaphore"]
    cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd = 9,
    #[doc = " Handle is an opaque handle file descriptor referencing a timeline semaphore"]
    cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = 10,
}
#[doc = " External semaphore handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc {
    #[doc = " Type of the handle"]
    pub type_: cudaExternalSemaphoreHandleType,
    pub handle: cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
    #[doc = " Flags reserved for the future. Must be zero."]
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
    #[doc = " File descriptor referencing the semaphore object. Valid when"]
    #[doc = " type is one of the following:"]
    #[doc = " - ::cudaExternalSemaphoreHandleTypeOpaqueFd"]
    #[doc = " - ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd"]
    pub fd: ::libc::c_int,
    pub win32: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Valid NvSciSyncObj. Must be non NULL"]
    pub nvSciSyncObj: *const ::libc::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when"]
#[doc = " type is one of the following:"]
#[doc = " - ::cudaExternalSemaphoreHandleTypeOpaqueWin32"]
#[doc = " - ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt"]
#[doc = " - ::cudaExternalSemaphoreHandleTypeD3D12Fence"]
#[doc = " - ::cudaExternalSemaphoreHandleTypeD3D11Fence"]
#[doc = " - ::cudaExternalSemaphoreHandleTypeKeyedMutex"]
#[doc = " - ::cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32"]
#[doc = " Exactly one of 'handle' and 'name' must be non-NULL. If"]
#[doc = " type is one of the following:"]
#[doc = " ::cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt"]
#[doc = " ::cudaExternalSemaphoreHandleTypeKeyedMutexKmt"]
#[doc = " then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::libc::c_void,
    #[doc = " Name of a valid synchronization primitive."]
    #[doc = " Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>()))
                .handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>()))
                .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>())).fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>())).win32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>())).nvSciSyncObj
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
            "::",
            stringify!(nvSciSyncObj)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc>(),
        32usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc>())).handle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreHandleDesc>())).flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreHandleDesc),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " External semaphore signal parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams {
    pub params: cudaExternalSemaphoreSignalParams__bindgen_ty_1,
    #[doc = " Only when ::cudaExternalSemaphoreSignalParams is used to"]
    #[doc = " signal a ::cudaExternalSemaphore_t of type"]
    #[doc = " ::cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is"]
    #[doc = " ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates"]
    #[doc = " that while signaling the ::cudaExternalSemaphore_t, no memory"]
    #[doc = " synchronization operations should be performed for any external memory"]
    #[doc = " object imported as ::cudaExternalMemoryHandleTypeNvSciBuf."]
    #[doc = " For all other types of ::cudaExternalSemaphore_t, flags must be zero."]
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::libc::c_uint; 12usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be signaled"]
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(
            )))
            .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::cudaExternalSemaphoreHandleType"]
    #[doc = " is of type ::cudaExternalSemaphoreHandleTypeNvSciSync."]
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(
            )))
            .fence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(
            )))
            .reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(
            )))
            .key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>())).nvSciSync
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>())).keyedMutex
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>())).reserved
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreSignalParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams>())).params as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams>())).flags as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalParams>())).reserved as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " External semaphore wait parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams {
    pub params: cudaExternalSemaphoreWaitParams__bindgen_ty_1,
    #[doc = " Only when ::cudaExternalSemaphoreSignalParams is used to"]
    #[doc = " signal a ::cudaExternalSemaphore_t of type"]
    #[doc = " ::cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is"]
    #[doc = " ::cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates"]
    #[doc = " that while waiting for the ::cudaExternalSemaphore_t, no memory"]
    #[doc = " synchronization operations should be performed for any external memory"]
    #[doc = " object imported as ::cudaExternalMemoryHandleTypeNvSciBuf."]
    #[doc = " For all other types of ::cudaExternalSemaphore_t, flags must be zero."]
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::libc::c_uint; 10usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be waited on"]
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>()))
                .value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::cudaExternalSemaphoreHandleType"]
    #[doc = " is of type ::cudaExternalSemaphoreHandleTypeNvSciSync."]
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>()))
                .fence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>()))
                .reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to acquire the mutex with"]
    pub key: ::libc::c_ulonglong,
    #[doc = " Timeout in milliseconds to wait to acquire the mutex"]
    pub timeoutMs: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>()))
                .key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>()))
                .timeoutMs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(timeoutMs)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>())).fence
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>())).nvSciSync
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>())).keyedMutex
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>())).reserved
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams>())).params as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams>())).flags as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitParams>())).reserved as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitParams),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA Error types"]
pub use self::cudaError as cudaError_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
#[doc = " CUDA stream"]
pub type cudaStream_t = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
#[doc = " CUDA event types"]
pub type cudaEvent_t = *mut CUevent_st;
#[doc = " CUDA graphics resource types"]
pub type cudaGraphicsResource_t = *mut cudaGraphicsResource;
#[doc = " CUDA output file modes"]
pub use self::cudaOutputMode as cudaOutputMode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalMemory_st {
    _unused: [u8; 0],
}
#[doc = " CUDA external memory"]
pub type cudaExternalMemory_t = *mut CUexternalMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalSemaphore_st {
    _unused: [u8; 0],
}
#[doc = " CUDA external semaphore"]
pub type cudaExternalSemaphore_t = *mut CUexternalSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
#[doc = " CUDA graph"]
pub type cudaGraph_t = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
#[doc = " CUDA graph node."]
pub type cudaGraphNode_t = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
#[doc = " CUDA user object for graphs"]
pub type cudaUserObject_t = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
#[doc = " CUDA function"]
pub type cudaFunction_t = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
#[doc = " CUDA memory pool"]
pub type cudaMemPool_t = *mut CUmemPoolHandle_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA cooperative group scope"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaCGScope {
    #[doc = "< Invalid cooperative group scope"]
    cudaCGScopeInvalid = 0,
    #[doc = "< Scope represented by a grid_group"]
    cudaCGScopeGrid = 1,
    #[doc = "< Scope represented by a multi_grid_group"]
    cudaCGScopeMultiGrid = 2,
}
#[doc = " CUDA launch parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchParams {
    #[doc = "< Device function symbol"]
    pub func: *mut ::libc::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::libc::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: cudaStream_t,
}
#[test]
fn bindgen_test_layout_cudaLaunchParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).gridDim as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).blockDim as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).sharedMem as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(sharedMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaLaunchParams>())).stream as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaLaunchParams),
            "::",
            stringify!(stream)
        )
    );
}
#[doc = " CUDA GPU kernel node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaKernelNodeParams {
    #[doc = "< Kernel to launch"]
    pub func: *mut ::libc::c_void,
    #[doc = "< Grid dimensions"]
    pub gridDim: dim3,
    #[doc = "< Block dimensions"]
    pub blockDim: dim3,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::libc::c_uint,
    #[doc = "< Array of pointers to individual kernel arguments"]
    pub kernelParams: *mut *mut ::libc::c_void,
    #[doc = "< Pointer to kernel arguments in the \"extra\" format"]
    pub extra: *mut *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaKernelNodeParams>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaKernelNodeParams>())).gridDim as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaKernelNodeParams>())).blockDim as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaKernelNodeParams>())).sharedMemBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaKernelNodeParams>())).kernelParams as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cudaKernelNodeParams>())).extra as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaKernelNodeParams),
            "::",
            stringify!(extra)
        )
    );
}
#[doc = " External semaphore signal node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalNodeParams {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut cudaExternalSemaphore_t,
    #[doc = "< Array of external semaphore signal parameters."]
    pub paramsArray: *const cudaExternalSemaphoreSignalParams,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalNodeParams>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalNodeParams>())).extSemArray
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalNodeParams>())).paramsArray
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreSignalNodeParams>())).numExtSems as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(numExtSems)
        )
    );
}
#[doc = " External semaphore wait node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitNodeParams {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut cudaExternalSemaphore_t,
    #[doc = "< Array of external semaphore wait parameters."]
    pub paramsArray: *const cudaExternalSemaphoreWaitParams,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitNodeParams>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitNodeParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitNodeParams>())).extSemArray as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitNodeParams>())).paramsArray as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cudaExternalSemaphoreWaitNodeParams>())).numExtSems as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cudaExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(numExtSems)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA Graph node types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphNodeType {
    #[doc = "< GPU kernel node"]
    cudaGraphNodeTypeKernel = 0,
    #[doc = "< Memcpy node"]
    cudaGraphNodeTypeMemcpy = 1,
    #[doc = "< Memset node"]
    cudaGraphNodeTypeMemset = 2,
    #[doc = "< Host (executable) node"]
    cudaGraphNodeTypeHost = 3,
    #[doc = "< Node which executes an embedded graph"]
    cudaGraphNodeTypeGraph = 4,
    #[doc = "< Empty (no-op) node"]
    cudaGraphNodeTypeEmpty = 5,
    #[doc = "< External event wait node"]
    cudaGraphNodeTypeWaitEvent = 6,
    #[doc = "< External event record node"]
    cudaGraphNodeTypeEventRecord = 7,
    #[doc = "< External semaphore signal node"]
    cudaGraphNodeTypeExtSemaphoreSignal = 8,
    #[doc = "< External semaphore wait node"]
    cudaGraphNodeTypeExtSemaphoreWait = 9,
    #[doc = "< Memory allocation node"]
    cudaGraphNodeTypeMemAlloc = 10,
    #[doc = "< Memory free node"]
    cudaGraphNodeTypeMemFree = 11,
    cudaGraphNodeTypeCount = 12,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
#[doc = " CUDA executable (launchable) graph"]
pub type cudaGraphExec_t = *mut CUgraphExec_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA Graph Update error types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphExecUpdateResult {
    #[doc = "< The update succeeded"]
    cudaGraphExecUpdateSuccess = 0,
    #[doc = "< The update failed for an unexpected reason which is described in the return value of the function"]
    cudaGraphExecUpdateError = 1,
    #[doc = "< The update failed because the topology changed"]
    cudaGraphExecUpdateErrorTopologyChanged = 2,
    #[doc = "< The update failed because a node type changed"]
    cudaGraphExecUpdateErrorNodeTypeChanged = 3,
    #[doc = "< The update failed because the function of a kernel node changed (CUDA driver < 11.2)"]
    cudaGraphExecUpdateErrorFunctionChanged = 4,
    #[doc = "< The update failed because the parameters changed in a way that is not supported"]
    cudaGraphExecUpdateErrorParametersChanged = 5,
    #[doc = "< The update failed because something about the node is not supported"]
    cudaGraphExecUpdateErrorNotSupported = 6,
    #[doc = "< The update failed because the function of a kernel node changed in an unsupported way"]
    cudaGraphExecUpdateErrorUnsupportedFunctionChange = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags to specify search options to be used with ::cudaGetDriverEntryPoint"]
#[doc = " For more details see ::cuGetProcAddress"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGetDriverEntryPointFlags {
    #[doc = "< Default search mode for driver symbols."]
    cudaEnableDefault = 0,
    #[doc = "< Search for legacy versions of driver symbols."]
    cudaEnableLegacyStream = 1,
    #[doc = "< Search for per-thread versions of driver symbols."]
    cudaEnablePerThreadDefaultStream = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " CUDA Graph debug write options"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphDebugDotFlags {
    cudaGraphDebugDotFlagsVerbose = 1,
    #[doc = " Output all debug data as if every debug flag is enabled"]
    cudaGraphDebugDotFlagsKernelNodeParams = 4,
    #[doc = " Adds cudaKernelNodeParams to output"]
    cudaGraphDebugDotFlagsMemcpyNodeParams = 8,
    #[doc = " Adds cudaMemcpy3DParms to output"]
    cudaGraphDebugDotFlagsMemsetNodeParams = 16,
    #[doc = " Adds cudaMemsetParams to output"]
    cudaGraphDebugDotFlagsHostNodeParams = 32,
    #[doc = " Adds cudaHostNodeParams to output"]
    cudaGraphDebugDotFlagsEventNodeParams = 64,
    #[doc = " Adds cudaEvent_t handle from record and wait nodes to output"]
    cudaGraphDebugDotFlagsExtSemasSignalNodeParams = 128,
    #[doc = " Adds cudaExternalSemaphoreSignalNodeParams values to output"]
    cudaGraphDebugDotFlagsExtSemasWaitNodeParams = 256,
    #[doc = " Adds cudaExternalSemaphoreWaitNodeParams to output"]
    cudaGraphDebugDotFlagsKernelNodeAttributes = 512,
    #[doc = " Adds cudaKernelNodeAttrID values to output"]
    cudaGraphDebugDotFlagsHandles = 1024,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for instantiating a graph"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaGraphInstantiateFlags {
    #[doc = "< Automatically free memory allocated in a graph before relaunching."]
    cudaGraphInstantiateFlagAutoFreeOnLaunch = 1,
}
pub type cuFloatComplex = float2;
pub type cuDoubleComplex = double2;
pub type cuComplex = cuFloatComplex;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cudaDataType_t {
    CUDA_R_16F = 2,
    CUDA_C_16F = 6,
    CUDA_R_16BF = 14,
    CUDA_C_16BF = 15,
    CUDA_R_32F = 0,
    CUDA_C_32F = 4,
    CUDA_R_64F = 1,
    CUDA_C_64F = 5,
    CUDA_R_4I = 16,
    CUDA_C_4I = 17,
    CUDA_R_4U = 18,
    CUDA_C_4U = 19,
    CUDA_R_8I = 3,
    CUDA_C_8I = 7,
    CUDA_R_8U = 8,
    CUDA_C_8U = 9,
    CUDA_R_16I = 20,
    CUDA_C_16I = 21,
    CUDA_R_16U = 22,
    CUDA_C_16U = 23,
    CUDA_R_32I = 10,
    CUDA_C_32I = 11,
    CUDA_R_32U = 12,
    CUDA_C_32U = 13,
    CUDA_R_64I = 24,
    CUDA_C_64I = 25,
    CUDA_R_64U = 26,
    CUDA_C_64U = 27,
}
pub use self::cudaDataType_t as cudaDataType;
pub const libraryPropertyType_t_MAJOR_VERSION: libraryPropertyType_t = 0;
pub const libraryPropertyType_t_MINOR_VERSION: libraryPropertyType_t = 1;
pub const libraryPropertyType_t_PATCH_LEVEL: libraryPropertyType_t = 2;
pub type libraryPropertyType_t = ::libc::c_uint;
pub use self::libraryPropertyType_t as libraryPropertyType;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasStatus_t {
    CUBLAS_STATUS_SUCCESS = 0,
    CUBLAS_STATUS_NOT_INITIALIZED = 1,
    CUBLAS_STATUS_ALLOC_FAILED = 3,
    CUBLAS_STATUS_INVALID_VALUE = 7,
    CUBLAS_STATUS_ARCH_MISMATCH = 8,
    CUBLAS_STATUS_MAPPING_ERROR = 11,
    CUBLAS_STATUS_EXECUTION_FAILED = 13,
    CUBLAS_STATUS_INTERNAL_ERROR = 14,
    CUBLAS_STATUS_NOT_SUPPORTED = 15,
    CUBLAS_STATUS_LICENSE_ERROR = 16,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasFillMode_t {
    CUBLAS_FILL_MODE_LOWER = 0,
    CUBLAS_FILL_MODE_UPPER = 1,
    CUBLAS_FILL_MODE_FULL = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasDiagType_t {
    CUBLAS_DIAG_NON_UNIT = 0,
    CUBLAS_DIAG_UNIT = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasSideMode_t {
    CUBLAS_SIDE_LEFT = 0,
    CUBLAS_SIDE_RIGHT = 1,
}
impl cublasOperation_t {
    pub const CUBLAS_OP_HERMITAN: cublasOperation_t = cublasOperation_t::CUBLAS_OP_C;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasOperation_t {
    CUBLAS_OP_N = 0,
    CUBLAS_OP_T = 1,
    CUBLAS_OP_C = 2,
    CUBLAS_OP_CONJG = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasPointerMode_t {
    CUBLAS_POINTER_MODE_HOST = 0,
    CUBLAS_POINTER_MODE_DEVICE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasAtomicsMode_t {
    CUBLAS_ATOMICS_NOT_ALLOWED = 0,
    CUBLAS_ATOMICS_ALLOWED = 1,
}
impl cublasGemmAlgo_t {
    pub const CUBLAS_GEMM_DEFAULT: cublasGemmAlgo_t = cublasGemmAlgo_t::CUBLAS_GEMM_DFALT;
}
impl cublasGemmAlgo_t {
    pub const CUBLAS_GEMM_DFALT_TENSOR_OP: cublasGemmAlgo_t =
        cublasGemmAlgo_t::CUBLAS_GEMM_DEFAULT_TENSOR_OP;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasGemmAlgo_t {
    CUBLAS_GEMM_DFALT = -1,
    CUBLAS_GEMM_ALGO0 = 0,
    CUBLAS_GEMM_ALGO1 = 1,
    CUBLAS_GEMM_ALGO2 = 2,
    CUBLAS_GEMM_ALGO3 = 3,
    CUBLAS_GEMM_ALGO4 = 4,
    CUBLAS_GEMM_ALGO5 = 5,
    CUBLAS_GEMM_ALGO6 = 6,
    CUBLAS_GEMM_ALGO7 = 7,
    CUBLAS_GEMM_ALGO8 = 8,
    CUBLAS_GEMM_ALGO9 = 9,
    CUBLAS_GEMM_ALGO10 = 10,
    CUBLAS_GEMM_ALGO11 = 11,
    CUBLAS_GEMM_ALGO12 = 12,
    CUBLAS_GEMM_ALGO13 = 13,
    CUBLAS_GEMM_ALGO14 = 14,
    CUBLAS_GEMM_ALGO15 = 15,
    CUBLAS_GEMM_ALGO16 = 16,
    CUBLAS_GEMM_ALGO17 = 17,
    CUBLAS_GEMM_ALGO18 = 18,
    CUBLAS_GEMM_ALGO19 = 19,
    CUBLAS_GEMM_ALGO20 = 20,
    CUBLAS_GEMM_ALGO21 = 21,
    CUBLAS_GEMM_ALGO22 = 22,
    CUBLAS_GEMM_ALGO23 = 23,
    CUBLAS_GEMM_DEFAULT_TENSOR_OP = 99,
    CUBLAS_GEMM_ALGO0_TENSOR_OP = 100,
    CUBLAS_GEMM_ALGO1_TENSOR_OP = 101,
    CUBLAS_GEMM_ALGO2_TENSOR_OP = 102,
    CUBLAS_GEMM_ALGO3_TENSOR_OP = 103,
    CUBLAS_GEMM_ALGO4_TENSOR_OP = 104,
    CUBLAS_GEMM_ALGO5_TENSOR_OP = 105,
    CUBLAS_GEMM_ALGO6_TENSOR_OP = 106,
    CUBLAS_GEMM_ALGO7_TENSOR_OP = 107,
    CUBLAS_GEMM_ALGO8_TENSOR_OP = 108,
    CUBLAS_GEMM_ALGO9_TENSOR_OP = 109,
    CUBLAS_GEMM_ALGO10_TENSOR_OP = 110,
    CUBLAS_GEMM_ALGO11_TENSOR_OP = 111,
    CUBLAS_GEMM_ALGO12_TENSOR_OP = 112,
    CUBLAS_GEMM_ALGO13_TENSOR_OP = 113,
    CUBLAS_GEMM_ALGO14_TENSOR_OP = 114,
    CUBLAS_GEMM_ALGO15_TENSOR_OP = 115,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasMath_t {
    CUBLAS_DEFAULT_MATH = 0,
    CUBLAS_TENSOR_OP_MATH = 1,
    CUBLAS_PEDANTIC_MATH = 2,
    CUBLAS_TF32_TENSOR_OP_MATH = 3,
    CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION = 16,
}
pub use self::cudaDataType as cublasDataType_t;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cublasComputeType_t {
    CUBLAS_COMPUTE_16F = 64,
    CUBLAS_COMPUTE_16F_PEDANTIC = 65,
    CUBLAS_COMPUTE_32F = 68,
    CUBLAS_COMPUTE_32F_PEDANTIC = 69,
    CUBLAS_COMPUTE_32F_FAST_16F = 74,
    CUBLAS_COMPUTE_32F_FAST_16BF = 75,
    CUBLAS_COMPUTE_32F_FAST_TF32 = 77,
    CUBLAS_COMPUTE_64F = 70,
    CUBLAS_COMPUTE_64F_PEDANTIC = 71,
    CUBLAS_COMPUTE_32I = 72,
    CUBLAS_COMPUTE_32I_PEDANTIC = 73,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cublasContext {
    _unused: [u8; 0],
}
pub type cublasHandle_t = *mut cublasContext;
extern "C" {
    pub fn cublasCreate_v2(handle: *mut cublasHandle_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDestroy_v2(handle: cublasHandle_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVersion_v2(
        handle: cublasHandle_t,
        version: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetProperty(
        type_: libraryPropertyType,
        value: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetCudartVersion() -> usize;
}
extern "C" {
    pub fn cublasSetWorkspace_v2(
        handle: cublasHandle_t,
        workspace: *mut ::libc::c_void,
        workspaceSizeInBytes: usize,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetStream_v2(handle: cublasHandle_t, streamId: cudaStream_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetStream_v2(
        handle: cublasHandle_t,
        streamId: *mut cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetPointerMode_v2(
        handle: cublasHandle_t,
        mode: *mut cublasPointerMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetPointerMode_v2(
        handle: cublasHandle_t,
        mode: cublasPointerMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetAtomicsMode(
        handle: cublasHandle_t,
        mode: *mut cublasAtomicsMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetAtomicsMode(
        handle: cublasHandle_t,
        mode: cublasAtomicsMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMathMode(handle: cublasHandle_t, mode: *mut cublasMath_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMathMode(handle: cublasHandle_t, mode: cublasMath_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetSmCountTarget(
        handle: cublasHandle_t,
        smCountTarget: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetSmCountTarget(
        handle: cublasHandle_t,
        smCountTarget: ::libc::c_int,
    ) -> cublasStatus_t;
}
pub type cublasLogCallback =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::libc::c_char)>;
extern "C" {
    pub fn cublasLoggerConfigure(
        logIsOn: ::libc::c_int,
        logToStdOut: ::libc::c_int,
        logToStdErr: ::libc::c_int,
        logFileName: *const ::libc::c_char,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetLoggerCallback(userCallback: cublasLogCallback) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetLoggerCallback(userCallback: *mut cublasLogCallback) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetVector(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        x: *const ::libc::c_void,
        incx: ::libc::c_int,
        devicePtr: *mut ::libc::c_void,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVector(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        x: *const ::libc::c_void,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMatrix(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMatrix(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetVectorAsync(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        hostPtr: *const ::libc::c_void,
        incx: ::libc::c_int,
        devicePtr: *mut ::libc::c_void,
        incy: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVectorAsync(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        devicePtr: *const ::libc::c_void,
        incx: ::libc::c_int,
        hostPtr: *mut ::libc::c_void,
        incy: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMatrixAsync(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMatrixAsync(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasXerbla(srName: *const ::libc::c_char, info: ::libc::c_int);
}
extern "C" {
    pub fn cublasNrm2Ex(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        result: *mut ::libc::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSnrm2_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDnrm2_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScnrm2_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDznrm2_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDotEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *const ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        result: *mut ::libc::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDotcEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *const ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        result: *mut ::libc::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSdot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDdot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdotu_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        result: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdotc_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        result: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdotu_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        result: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdotc_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        result: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScalEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const ::libc::c_void,
        alphaType: cudaDataType,
        x: *mut ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasAxpyEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const ::libc::c_void,
        alphaType: cudaDataType,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSaxpy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDaxpy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCaxpy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZaxpy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCopyEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScopy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDcopy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCcopy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZcopy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSswap_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDswap_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCswap_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZswap_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSwapEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIsamax_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIdamax_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIcamax_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIzamax_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIamaxEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIsamin_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIdamin_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIcamin_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIzamin_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIaminEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasAsumEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        result: *mut ::libc::c_void,
        resultType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSasum_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDasum_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScasum_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDzasum_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        c: *const ::libc::c_void,
        s: *const ::libc::c_void,
        csType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotg_v2(
        handle: cublasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotg_v2(
        handle: cublasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCrotg_v2(
        handle: cublasHandle_t,
        a: *mut cuComplex,
        b: *mut cuComplex,
        c: *mut f32,
        s: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZrotg_v2(
        handle: cublasHandle_t,
        a: *mut cuDoubleComplex,
        b: *mut cuDoubleComplex,
        c: *mut f64,
        s: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotgEx(
        handle: cublasHandle_t,
        a: *mut ::libc::c_void,
        b: *mut ::libc::c_void,
        abType: cudaDataType,
        c: *mut ::libc::c_void,
        s: *mut ::libc::c_void,
        csType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotm_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        param: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotm_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        param: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotmEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        param: *const ::libc::c_void,
        paramType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotmg_v2(
        handle: cublasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotmg_v2(
        handle: cublasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotmgEx(
        handle: cublasHandle_t,
        d1: *mut ::libc::c_void,
        d1Type: cudaDataType,
        d2: *mut ::libc::c_void,
        d2Type: cudaDataType,
        x1: *mut ::libc::c_void,
        x1Type: cudaDataType,
        y1: *const ::libc::c_void,
        y1Type: cudaDataType,
        param: *mut ::libc::c_void,
        paramType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const cuComplex,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const cuComplex,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChemv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhemv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        AP: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        AP: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSger_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDger_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeru_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgerc_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeru_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgerc_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const cuComplex,
        incx: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const cuComplex,
        incx: ::libc::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3m(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemm3m(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const ::libc::c_void,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const ::libc::c_void,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasUint8gemmBias(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        transc: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const ::libc::c_uchar,
        A_bias: ::libc::c_int,
        lda: ::libc::c_int,
        B: *const ::libc::c_uchar,
        B_bias: ::libc::c_int,
        ldb: ::libc::c_int,
        C: *mut ::libc::c_uchar,
        C_bias: ::libc::c_int,
        ldc: ::libc::c_int,
        C_mult: ::libc::c_int,
        C_shift: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrkEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrk3mEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const cuComplex,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZherk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherkEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherk3mEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZherkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChemm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhemm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *mut cuComplex,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        Aarray: *const *const f32,
        lda: ::libc::c_int,
        Barray: *const *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        Carray: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        Aarray: *const *const f64,
        lda: ::libc::c_int,
        Barray: *const *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        Carray: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::libc::c_int,
        Barray: *const *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        Carray: *const *mut cuComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::libc::c_int,
        Barray: *const *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        Carray: *const *mut cuComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        Aarray: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        Barray: *const *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        Carray: *const *mut cuDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmBatchedEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const ::libc::c_void,
        Aarray: *const *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        Barray: *const *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const ::libc::c_void,
        Carray: *const *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmStridedBatchedEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const ::libc::c_void,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const ::libc::c_void,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        B: *const f32,
        ldb: ::libc::c_int,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        B: *const f64,
        ldb: ::libc::c_int,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        beta: *const cuComplex,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        beta: *const cuDoubleComplex,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetrfBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        P: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetrfBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        P: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetrfBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *mut cuComplex,
        lda: ::libc::c_int,
        P: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetrfBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *mut cuDoubleComplex,
        lda: ::libc::c_int,
        P: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetriBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        P: *const ::libc::c_int,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetriBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        P: *const ::libc::c_int,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetriBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const cuComplex,
        lda: ::libc::c_int,
        P: *const ::libc::c_int,
        C: *const *mut cuComplex,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetriBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        P: *const ::libc::c_int,
        C: *const *mut cuDoubleComplex,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *const f32,
        lda: ::libc::c_int,
        devIpiv: *const ::libc::c_int,
        Barray: *const *mut f32,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *const f64,
        lda: ::libc::c_int,
        devIpiv: *const ::libc::c_int,
        Barray: *const *mut f64,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *const cuComplex,
        lda: ::libc::c_int,
        devIpiv: *const ::libc::c_int,
        Barray: *const *mut cuComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        devIpiv: *const ::libc::c_int,
        Barray: *const *mut cuDoubleComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *mut f32,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *mut f64,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const *const cuComplex,
        lda: ::libc::c_int,
        B: *const *mut cuComplex,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const *mut cuDoubleComplex,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSmatinvBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        Ainv: *const *mut f32,
        lda_inv: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDmatinvBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        Ainv: *const *mut f64,
        lda_inv: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCmatinvBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const cuComplex,
        lda: ::libc::c_int,
        Ainv: *const *mut cuComplex,
        lda_inv: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZmatinvBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        Ainv: *const *mut cuDoubleComplex,
        lda_inv: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgeqrfBatched(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        Aarray: *const *mut f32,
        lda: ::libc::c_int,
        TauArray: *const *mut f32,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgeqrfBatched(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        Aarray: *const *mut f64,
        lda: ::libc::c_int,
        TauArray: *const *mut f64,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeqrfBatched(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        Aarray: *const *mut cuComplex,
        lda: ::libc::c_int,
        TauArray: *const *mut cuComplex,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeqrfBatched(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        Aarray: *const *mut cuDoubleComplex,
        lda: ::libc::c_int,
        TauArray: *const *mut cuDoubleComplex,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *mut f32,
        lda: ::libc::c_int,
        Carray: *const *mut f32,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        devInfoArray: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *mut f64,
        lda: ::libc::c_int,
        Carray: *const *mut f64,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        devInfoArray: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *mut cuComplex,
        lda: ::libc::c_int,
        Carray: *const *mut cuComplex,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        devInfoArray: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *mut cuDoubleComplex,
        lda: ::libc::c_int,
        Carray: *const *mut cuDoubleComplex,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        devInfoArray: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        AP: *const f32,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        AP: *const f64,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        AP: *const cuComplex,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        AP: *const cuDoubleComplex,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
