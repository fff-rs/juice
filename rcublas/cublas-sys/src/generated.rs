/* automatically generated by rust-bindgen 0.60.1 */

//! Defines the FFI for CUDA cuBLAS.
//!
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

pub const CUBLAS_VER_MAJOR: u32 = 11;
pub const CUBLAS_VER_MINOR: u32 = 10;
pub const CUBLAS_VER_PATCH: u32 = 3;
pub const CUBLAS_VER_BUILD: u32 = 66;
pub const CUBLAS_VERSION: u32 = 111003;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_float2() {
    assert_eq!(
        ::std::mem::size_of::<float2>(),
        8usize,
        concat!("Size of: ", stringify!(float2))
    );
    assert_eq!(
        ::std::mem::align_of::<float2>(),
        8usize,
        concat!("Alignment of ", stringify!(float2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(float2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(float2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_double2() {
    assert_eq!(
        ::std::mem::size_of::<double2>(),
        16usize,
        concat!("Size of: ", stringify!(double2))
    );
    assert_eq!(
        ::std::mem::align_of::<double2>(),
        16usize,
        concat!("Alignment of ", stringify!(double2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(double2),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(double2),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_dim3() {
    assert_eq!(
        ::std::mem::size_of::<dim3>(),
        12usize,
        concat!("Size of: ", stringify!(dim3))
    );
    assert_eq!(
        ::std::mem::align_of::<dim3>(),
        4usize,
        concat!("Alignment of ", stringify!(dim3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaError {
    cudaSuccess = 0,
    cudaErrorInvalidValue = 1,
    cudaErrorMemoryAllocation = 2,
    cudaErrorInitializationError = 3,
    cudaErrorCudartUnloading = 4,
    cudaErrorProfilerDisabled = 5,
    cudaErrorProfilerNotInitialized = 6,
    cudaErrorProfilerAlreadyStarted = 7,
    cudaErrorProfilerAlreadyStopped = 8,
    cudaErrorInvalidConfiguration = 9,
    cudaErrorInvalidPitchValue = 12,
    cudaErrorInvalidSymbol = 13,
    cudaErrorInvalidHostPointer = 16,
    cudaErrorInvalidDevicePointer = 17,
    cudaErrorInvalidTexture = 18,
    cudaErrorInvalidTextureBinding = 19,
    cudaErrorInvalidChannelDescriptor = 20,
    cudaErrorInvalidMemcpyDirection = 21,
    cudaErrorAddressOfConstant = 22,
    cudaErrorTextureFetchFailed = 23,
    cudaErrorTextureNotBound = 24,
    cudaErrorSynchronizationError = 25,
    cudaErrorInvalidFilterSetting = 26,
    cudaErrorInvalidNormSetting = 27,
    cudaErrorMixedDeviceExecution = 28,
    cudaErrorNotYetImplemented = 31,
    cudaErrorMemoryValueTooLarge = 32,
    cudaErrorStubLibrary = 34,
    cudaErrorInsufficientDriver = 35,
    cudaErrorCallRequiresNewerDriver = 36,
    cudaErrorInvalidSurface = 37,
    cudaErrorDuplicateVariableName = 43,
    cudaErrorDuplicateTextureName = 44,
    cudaErrorDuplicateSurfaceName = 45,
    cudaErrorDevicesUnavailable = 46,
    cudaErrorIncompatibleDriverContext = 49,
    cudaErrorMissingConfiguration = 52,
    cudaErrorPriorLaunchFailure = 53,
    cudaErrorLaunchMaxDepthExceeded = 65,
    cudaErrorLaunchFileScopedTex = 66,
    cudaErrorLaunchFileScopedSurf = 67,
    cudaErrorSyncDepthExceeded = 68,
    cudaErrorLaunchPendingCountExceeded = 69,
    cudaErrorInvalidDeviceFunction = 98,
    cudaErrorNoDevice = 100,
    cudaErrorInvalidDevice = 101,
    cudaErrorDeviceNotLicensed = 102,
    cudaErrorSoftwareValidityNotEstablished = 103,
    cudaErrorStartupFailure = 127,
    cudaErrorInvalidKernelImage = 200,
    cudaErrorDeviceUninitialized = 201,
    cudaErrorMapBufferObjectFailed = 205,
    cudaErrorUnmapBufferObjectFailed = 206,
    cudaErrorArrayIsMapped = 207,
    cudaErrorAlreadyMapped = 208,
    cudaErrorNoKernelImageForDevice = 209,
    cudaErrorAlreadyAcquired = 210,
    cudaErrorNotMapped = 211,
    cudaErrorNotMappedAsArray = 212,
    cudaErrorNotMappedAsPointer = 213,
    cudaErrorECCUncorrectable = 214,
    cudaErrorUnsupportedLimit = 215,
    cudaErrorDeviceAlreadyInUse = 216,
    cudaErrorPeerAccessUnsupported = 217,
    cudaErrorInvalidPtx = 218,
    cudaErrorInvalidGraphicsContext = 219,
    cudaErrorNvlinkUncorrectable = 220,
    cudaErrorJitCompilerNotFound = 221,
    cudaErrorUnsupportedPtxVersion = 222,
    cudaErrorJitCompilationDisabled = 223,
    cudaErrorUnsupportedExecAffinity = 224,
    cudaErrorInvalidSource = 300,
    cudaErrorFileNotFound = 301,
    cudaErrorSharedObjectSymbolNotFound = 302,
    cudaErrorSharedObjectInitFailed = 303,
    cudaErrorOperatingSystem = 304,
    cudaErrorInvalidResourceHandle = 400,
    cudaErrorIllegalState = 401,
    cudaErrorSymbolNotFound = 500,
    cudaErrorNotReady = 600,
    cudaErrorIllegalAddress = 700,
    cudaErrorLaunchOutOfResources = 701,
    cudaErrorLaunchTimeout = 702,
    cudaErrorLaunchIncompatibleTexturing = 703,
    cudaErrorPeerAccessAlreadyEnabled = 704,
    cudaErrorPeerAccessNotEnabled = 705,
    cudaErrorSetOnActiveProcess = 708,
    cudaErrorContextIsDestroyed = 709,
    cudaErrorAssert = 710,
    cudaErrorTooManyPeers = 711,
    cudaErrorHostMemoryAlreadyRegistered = 712,
    cudaErrorHostMemoryNotRegistered = 713,
    cudaErrorHardwareStackError = 714,
    cudaErrorIllegalInstruction = 715,
    cudaErrorMisalignedAddress = 716,
    cudaErrorInvalidAddressSpace = 717,
    cudaErrorInvalidPc = 718,
    cudaErrorLaunchFailure = 719,
    cudaErrorCooperativeLaunchTooLarge = 720,
    cudaErrorNotPermitted = 800,
    cudaErrorNotSupported = 801,
    cudaErrorSystemNotReady = 802,
    cudaErrorSystemDriverMismatch = 803,
    cudaErrorCompatNotSupportedOnDevice = 804,
    cudaErrorMpsConnectionFailed = 805,
    cudaErrorMpsRpcFailure = 806,
    cudaErrorMpsServerNotReady = 807,
    cudaErrorMpsMaxClientsReached = 808,
    cudaErrorMpsMaxConnectionsReached = 809,
    cudaErrorStreamCaptureUnsupported = 900,
    cudaErrorStreamCaptureInvalidated = 901,
    cudaErrorStreamCaptureMerge = 902,
    cudaErrorStreamCaptureUnmatched = 903,
    cudaErrorStreamCaptureUnjoined = 904,
    cudaErrorStreamCaptureIsolation = 905,
    cudaErrorStreamCaptureImplicit = 906,
    cudaErrorCapturedEvent = 907,
    cudaErrorStreamCaptureWrongThread = 908,
    cudaErrorTimeout = 909,
    cudaErrorGraphExecUpdateFailure = 910,
    cudaErrorExternalDevice = 911,
    cudaErrorUnknown = 999,
    cudaErrorApiFailureBase = 10000,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaChannelFormatKind {
    cudaChannelFormatKindSigned = 0,
    cudaChannelFormatKindUnsigned = 1,
    cudaChannelFormatKindFloat = 2,
    cudaChannelFormatKindNone = 3,
    cudaChannelFormatKindNV12 = 4,
    cudaChannelFormatKindUnsignedNormalized8X1 = 5,
    cudaChannelFormatKindUnsignedNormalized8X2 = 6,
    cudaChannelFormatKindUnsignedNormalized8X4 = 7,
    cudaChannelFormatKindUnsignedNormalized16X1 = 8,
    cudaChannelFormatKindUnsignedNormalized16X2 = 9,
    cudaChannelFormatKindUnsignedNormalized16X4 = 10,
    cudaChannelFormatKindSignedNormalized8X1 = 11,
    cudaChannelFormatKindSignedNormalized8X2 = 12,
    cudaChannelFormatKindSignedNormalized8X4 = 13,
    cudaChannelFormatKindSignedNormalized16X1 = 14,
    cudaChannelFormatKindSignedNormalized16X2 = 15,
    cudaChannelFormatKindSignedNormalized16X4 = 16,
    cudaChannelFormatKindUnsignedBlockCompressed1 = 17,
    cudaChannelFormatKindUnsignedBlockCompressed1SRGB = 18,
    cudaChannelFormatKindUnsignedBlockCompressed2 = 19,
    cudaChannelFormatKindUnsignedBlockCompressed2SRGB = 20,
    cudaChannelFormatKindUnsignedBlockCompressed3 = 21,
    cudaChannelFormatKindUnsignedBlockCompressed3SRGB = 22,
    cudaChannelFormatKindUnsignedBlockCompressed4 = 23,
    cudaChannelFormatKindSignedBlockCompressed4 = 24,
    cudaChannelFormatKindUnsignedBlockCompressed5 = 25,
    cudaChannelFormatKindSignedBlockCompressed5 = 26,
    cudaChannelFormatKindUnsignedBlockCompressed6H = 27,
    cudaChannelFormatKindSignedBlockCompressed6H = 28,
    cudaChannelFormatKindUnsignedBlockCompressed7 = 29,
    cudaChannelFormatKindUnsignedBlockCompressed7SRGB = 30,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaChannelFormatDesc {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
    pub f: cudaChannelFormatKind,
}
#[test]
fn bindgen_test_layout_cudaChannelFormatDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaChannelFormatDesc))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArray {
    _unused: [u8; 0],
}
pub type cudaArray_t = *mut cudaArray;
pub type cudaArray_const_t = *const cudaArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMipmappedArray {
    _unused: [u8; 0],
}
pub type cudaMipmappedArray_t = *mut cudaMipmappedArray;
pub type cudaMipmappedArray_const_t = *const cudaMipmappedArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties {
    pub tileExtent: cudaArraySparseProperties__bindgen_ty_1,
    pub miptailFirstLevel: ::libc::c_uint,
    pub miptailSize: ::libc::c_ulonglong,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties__bindgen_ty_1 {
    pub width: ::libc::c_uint,
    pub height: ::libc::c_uint,
    pub depth: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties() {
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties>(),
        48usize,
        concat!("Size of: ", stringify!(cudaArraySparseProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaArraySparseProperties))
    );
    fn test_field_tileExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tileExtent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(tileExtent)
            )
        );
    }
    test_field_tileExtent();
    fn test_field_miptailFirstLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptailFirstLevel) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(miptailFirstLevel)
            )
        );
    }
    test_field_miptailFirstLevel();
    fn test_field_miptailSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptailSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(miptailSize)
            )
        );
    }
    test_field_miptailSize();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArrayMemoryRequirements {
    pub size: usize,
    pub alignment: usize,
    pub reserved: [::libc::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_cudaArrayMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<cudaArrayMemoryRequirements>(),
        32usize,
        concat!("Size of: ", stringify!(cudaArrayMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArrayMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaArrayMemoryRequirements))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(alignment)
            )
        );
    }
    test_field_alignment();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemoryType {
    cudaMemoryTypeUnregistered = 0,
    cudaMemoryTypeHost = 1,
    cudaMemoryTypeDevice = 2,
    cudaMemoryTypeManaged = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemcpyKind {
    cudaMemcpyHostToHost = 0,
    cudaMemcpyHostToDevice = 1,
    cudaMemcpyDeviceToHost = 2,
    cudaMemcpyDeviceToDevice = 3,
    cudaMemcpyDefault = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPitchedPtr {
    pub ptr: *mut ::libc::c_void,
    pub pitch: usize,
    pub xsize: usize,
    pub ysize: usize,
}
#[test]
fn bindgen_test_layout_cudaPitchedPtr() {
    assert_eq!(
        ::std::mem::size_of::<cudaPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPitchedPtr))
    );
    fn test_field_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(ptr)
            )
        );
    }
    test_field_ptr();
    fn test_field_pitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(pitch)
            )
        );
    }
    test_field_pitch();
    fn test_field_xsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(xsize)
            )
        );
    }
    test_field_xsize();
    fn test_field_ysize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(ysize)
            )
        );
    }
    test_field_ysize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_cudaExtent() {
    assert_eq!(
        ::std::mem::size_of::<cudaExtent>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExtent))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPos {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[test]
fn bindgen_test_layout_cudaPos() {
    assert_eq!(
        ::std::mem::size_of::<cudaPos>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPos))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPos>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPos))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DParms {
    pub srcArray: cudaArray_t,
    pub srcPos: cudaPos,
    pub srcPtr: cudaPitchedPtr,
    pub dstArray: cudaArray_t,
    pub dstPos: cudaPos,
    pub dstPtr: cudaPitchedPtr,
    pub extent: cudaExtent,
    pub kind: cudaMemcpyKind,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DParms))
    );
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_srcPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcPos)
            )
        );
    }
    test_field_srcPos();
    fn test_field_srcPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcPtr)
            )
        );
    }
    test_field_srcPtr();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_dstPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstPos)
            )
        );
    }
    test_field_dstPos();
    fn test_field_dstPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstPtr)
            )
        );
    }
    test_field_dstPtr();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(kind)
            )
        );
    }
    test_field_kind();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DPeerParms {
    pub srcArray: cudaArray_t,
    pub srcPos: cudaPos,
    pub srcPtr: cudaPitchedPtr,
    pub srcDevice: ::libc::c_int,
    pub dstArray: cudaArray_t,
    pub dstPos: cudaPos,
    pub dstPtr: cudaPitchedPtr,
    pub dstDevice: ::libc::c_int,
    pub extent: cudaExtent,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DPeerParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DPeerParms>(),
        168usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DPeerParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DPeerParms))
    );
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_srcPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcPos)
            )
        );
    }
    test_field_srcPos();
    fn test_field_srcPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcPtr)
            )
        );
    }
    test_field_srcPtr();
    fn test_field_srcDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcDevice)
            )
        );
    }
    test_field_srcDevice();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_dstPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstPos)
            )
        );
    }
    test_field_dstPos();
    fn test_field_dstPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstPtr)
            )
        );
    }
    test_field_dstPtr();
    fn test_field_dstDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstDevice)
            )
        );
    }
    test_field_dstDevice();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemsetParams {
    pub dst: *mut ::libc::c_void,
    pub pitch: usize,
    pub value: ::libc::c_uint,
    pub elementSize: ::libc::c_uint,
    pub width: usize,
    pub height: usize,
}
#[test]
fn bindgen_test_layout_cudaMemsetParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemsetParams>(),
        40usize,
        concat!("Size of: ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemsetParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemsetParams))
    );
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_pitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(pitch)
            )
        );
    }
    test_field_pitch();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_elementSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(elementSize)
            )
        );
    }
    test_field_elementSize();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaAccessProperty {
    cudaAccessPropertyNormal = 0,
    cudaAccessPropertyStreaming = 1,
    cudaAccessPropertyPersisting = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaAccessPolicyWindow {
    pub base_ptr: *mut ::libc::c_void,
    pub num_bytes: usize,
    pub hitRatio: f32,
    pub hitProp: cudaAccessProperty,
    pub missProp: cudaAccessProperty,
}
#[test]
fn bindgen_test_layout_cudaAccessPolicyWindow() {
    assert_eq!(
        ::std::mem::size_of::<cudaAccessPolicyWindow>(),
        32usize,
        concat!("Size of: ", stringify!(cudaAccessPolicyWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaAccessPolicyWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaAccessPolicyWindow))
    );
    fn test_field_base_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(base_ptr)
            )
        );
    }
    test_field_base_ptr();
    fn test_field_num_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(num_bytes)
            )
        );
    }
    test_field_num_bytes();
    fn test_field_hitRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitRatio) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(hitRatio)
            )
        );
    }
    test_field_hitRatio();
    fn test_field_hitProp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitProp) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(hitProp)
            )
        );
    }
    test_field_hitProp();
    fn test_field_missProp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missProp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(missProp)
            )
        );
    }
    test_field_missProp();
}
pub type cudaHostFn_t = ::std::option::Option<unsafe extern "C" fn(userData: *mut ::libc::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaHostNodeParams {
    pub fn_: cudaHostFn_t,
    pub userData: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaHostNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaHostNodeParams>(),
        16usize,
        concat!("Size of: ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaHostNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaHostNodeParams))
    );
    fn test_field_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaHostNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaHostNodeParams),
                "::",
                stringify!(fn_)
            )
        );
    }
    test_field_fn();
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaHostNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaHostNodeParams),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaStreamCaptureStatus {
    cudaStreamCaptureStatusNone = 0,
    cudaStreamCaptureStatusActive = 1,
    cudaStreamCaptureStatusInvalidated = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaStreamCaptureMode {
    cudaStreamCaptureModeGlobal = 0,
    cudaStreamCaptureModeThreadLocal = 1,
    cudaStreamCaptureModeRelaxed = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaSynchronizationPolicy {
    cudaSyncPolicyAuto = 1,
    cudaSyncPolicySpin = 2,
    cudaSyncPolicyYield = 3,
    cudaSyncPolicyBlockingSync = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaStreamUpdateCaptureDependenciesFlags {
    cudaStreamAddCaptureDependencies = 0,
    cudaStreamSetCaptureDependencies = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaUserObjectFlags {
    cudaUserObjectNoDestructorSync = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaUserObjectRetainFlags {
    cudaGraphUserObjectMove = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphicsResource {
    _unused: [u8; 0],
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGraphicsRegisterFlags {
    cudaGraphicsRegisterFlagsNone = 0,
    cudaGraphicsRegisterFlagsReadOnly = 1,
    cudaGraphicsRegisterFlagsWriteDiscard = 2,
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,
    cudaGraphicsRegisterFlagsTextureGather = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGraphicsMapFlags {
    cudaGraphicsMapFlagsNone = 0,
    cudaGraphicsMapFlagsReadOnly = 1,
    cudaGraphicsMapFlagsWriteDiscard = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGraphicsCubeFace {
    cudaGraphicsCubeFacePositiveX = 0,
    cudaGraphicsCubeFaceNegativeX = 1,
    cudaGraphicsCubeFacePositiveY = 2,
    cudaGraphicsCubeFaceNegativeY = 3,
    cudaGraphicsCubeFacePositiveZ = 4,
    cudaGraphicsCubeFaceNegativeZ = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaResourceType {
    cudaResourceTypeArray = 0,
    cudaResourceTypeMipmappedArray = 1,
    cudaResourceTypeLinear = 2,
    cudaResourceTypePitch2D = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaResourceViewFormat {
    cudaResViewFormatNone = 0,
    cudaResViewFormatUnsignedChar1 = 1,
    cudaResViewFormatUnsignedChar2 = 2,
    cudaResViewFormatUnsignedChar4 = 3,
    cudaResViewFormatSignedChar1 = 4,
    cudaResViewFormatSignedChar2 = 5,
    cudaResViewFormatSignedChar4 = 6,
    cudaResViewFormatUnsignedShort1 = 7,
    cudaResViewFormatUnsignedShort2 = 8,
    cudaResViewFormatUnsignedShort4 = 9,
    cudaResViewFormatSignedShort1 = 10,
    cudaResViewFormatSignedShort2 = 11,
    cudaResViewFormatSignedShort4 = 12,
    cudaResViewFormatUnsignedInt1 = 13,
    cudaResViewFormatUnsignedInt2 = 14,
    cudaResViewFormatUnsignedInt4 = 15,
    cudaResViewFormatSignedInt1 = 16,
    cudaResViewFormatSignedInt2 = 17,
    cudaResViewFormatSignedInt4 = 18,
    cudaResViewFormatHalf1 = 19,
    cudaResViewFormatHalf2 = 20,
    cudaResViewFormatHalf4 = 21,
    cudaResViewFormatFloat1 = 22,
    cudaResViewFormatFloat2 = 23,
    cudaResViewFormatFloat4 = 24,
    cudaResViewFormatUnsignedBlockCompressed1 = 25,
    cudaResViewFormatUnsignedBlockCompressed2 = 26,
    cudaResViewFormatUnsignedBlockCompressed3 = 27,
    cudaResViewFormatUnsignedBlockCompressed4 = 28,
    cudaResViewFormatSignedBlockCompressed4 = 29,
    cudaResViewFormatUnsignedBlockCompressed5 = 30,
    cudaResViewFormatSignedBlockCompressed5 = 31,
    cudaResViewFormatUnsignedBlockCompressed6H = 32,
    cudaResViewFormatSignedBlockCompressed6H = 33,
    cudaResViewFormatUnsignedBlockCompressed7 = 34,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaResourceDesc {
    pub resType: cudaResourceType,
    pub res: cudaResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaResourceDesc__bindgen_ty_1 {
    pub array: cudaResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: cudaResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: cudaArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: cudaMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: cudaChannelFormatDesc,
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_devPtr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(devPtr)
            )
        );
    }
    test_field_devPtr();
    fn test_field_desc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(desc)
            )
        );
    }
    test_field_desc();
    fn test_field_sizeInBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(sizeInBytes)
            )
        );
    }
    test_field_sizeInBytes();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: cudaChannelFormatDesc,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    fn test_field_devPtr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(devPtr)
            )
        );
    }
    test_field_devPtr();
    fn test_field_desc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(desc)
            )
        );
    }
    test_field_desc();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_pitchInBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(pitchInBytes)
            )
        );
    }
    test_field_pitchInBytes();
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
    fn test_field_linear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linear) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(linear)
            )
        );
    }
    test_field_linear();
    fn test_field_pitch2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(pitch2D)
            )
        );
    }
    test_field_pitch2D();
}
#[test]
fn bindgen_test_layout_cudaResourceDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc))
    );
    fn test_field_resType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc),
                "::",
                stringify!(resType)
            )
        );
    }
    test_field_resType();
    fn test_field_res() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc),
                "::",
                stringify!(res)
            )
        );
    }
    test_field_res();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceViewDesc {
    pub format: cudaResourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::libc::c_uint,
    pub lastMipmapLevel: ::libc::c_uint,
    pub firstLayer: ::libc::c_uint,
    pub lastLayer: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaResourceViewDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceViewDesc))
    );
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_firstMipmapLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(firstMipmapLevel)
            )
        );
    }
    test_field_firstMipmapLevel();
    fn test_field_lastMipmapLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(lastMipmapLevel)
            )
        );
    }
    test_field_lastMipmapLevel();
    fn test_field_firstLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(firstLayer)
            )
        );
    }
    test_field_firstLayer();
    fn test_field_lastLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(lastLayer)
            )
        );
    }
    test_field_lastLayer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPointerAttributes {
    pub type_: cudaMemoryType,
    pub device: ::libc::c_int,
    pub devicePointer: *mut ::libc::c_void,
    pub hostPointer: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaPointerAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaPointerAttributes>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPointerAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPointerAttributes))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_device() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(device)
            )
        );
    }
    test_field_device();
    fn test_field_devicePointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devicePointer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(devicePointer)
            )
        );
    }
    test_field_devicePointer();
    fn test_field_hostPointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostPointer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(hostPointer)
            )
        );
    }
    test_field_hostPointer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaFuncAttributes {
    pub sharedSizeBytes: usize,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub numRegs: ::libc::c_int,
    pub ptxVersion: ::libc::c_int,
    pub binaryVersion: ::libc::c_int,
    pub cacheModeCA: ::libc::c_int,
    pub maxDynamicSharedSizeBytes: ::libc::c_int,
    pub preferredShmemCarveout: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaFuncAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaFuncAttributes>(),
        56usize,
        concat!("Size of: ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaFuncAttributes))
    );
    fn test_field_sharedSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedSizeBytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(sharedSizeBytes)
            )
        );
    }
    test_field_sharedSizeBytes();
    fn test_field_constSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).constSizeBytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(constSizeBytes)
            )
        );
    }
    test_field_constSizeBytes();
    fn test_field_localSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localSizeBytes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(localSizeBytes)
            )
        );
    }
    test_field_localSizeBytes();
    fn test_field_maxThreadsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(maxThreadsPerBlock)
            )
        );
    }
    test_field_maxThreadsPerBlock();
    fn test_field_numRegs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numRegs) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(numRegs)
            )
        );
    }
    test_field_numRegs();
    fn test_field_ptxVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptxVersion) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(ptxVersion)
            )
        );
    }
    test_field_ptxVersion();
    fn test_field_binaryVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binaryVersion) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(binaryVersion)
            )
        );
    }
    test_field_binaryVersion();
    fn test_field_cacheModeCA() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cacheModeCA) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(cacheModeCA)
            )
        );
    }
    test_field_cacheModeCA();
    fn test_field_maxDynamicSharedSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDynamicSharedSizeBytes) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(maxDynamicSharedSizeBytes)
            )
        );
    }
    test_field_maxDynamicSharedSizeBytes();
    fn test_field_preferredShmemCarveout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preferredShmemCarveout) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(preferredShmemCarveout)
            )
        );
    }
    test_field_preferredShmemCarveout();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaFuncAttribute {
    cudaFuncAttributeMaxDynamicSharedMemorySize = 8,
    cudaFuncAttributePreferredSharedMemoryCarveout = 9,
    cudaFuncAttributeMax = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaFuncCache {
    cudaFuncCachePreferNone = 0,
    cudaFuncCachePreferShared = 1,
    cudaFuncCachePreferL1 = 2,
    cudaFuncCachePreferEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaSharedMemConfig {
    cudaSharedMemBankSizeDefault = 0,
    cudaSharedMemBankSizeFourByte = 1,
    cudaSharedMemBankSizeEightByte = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaSharedCarveout {
    cudaSharedmemCarveoutDefault = -1,
    cudaSharedmemCarveoutMaxShared = 100,
    cudaSharedmemCarveoutMaxL1 = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaComputeMode {
    cudaComputeModeDefault = 0,
    cudaComputeModeExclusive = 1,
    cudaComputeModeProhibited = 2,
    cudaComputeModeExclusiveProcess = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaLimit {
    cudaLimitStackSize = 0,
    cudaLimitPrintfFifoSize = 1,
    cudaLimitMallocHeapSize = 2,
    cudaLimitDevRuntimeSyncDepth = 3,
    cudaLimitDevRuntimePendingLaunchCount = 4,
    cudaLimitMaxL2FetchGranularity = 5,
    cudaLimitPersistingL2CacheSize = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemoryAdvise {
    cudaMemAdviseSetReadMostly = 1,
    cudaMemAdviseUnsetReadMostly = 2,
    cudaMemAdviseSetPreferredLocation = 3,
    cudaMemAdviseUnsetPreferredLocation = 4,
    cudaMemAdviseSetAccessedBy = 5,
    cudaMemAdviseUnsetAccessedBy = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemRangeAttribute {
    cudaMemRangeAttributeReadMostly = 1,
    cudaMemRangeAttributePreferredLocation = 2,
    cudaMemRangeAttributeAccessedBy = 3,
    cudaMemRangeAttributeLastPrefetchLocation = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaOutputMode {
    cudaKeyValuePair = 0,
    cudaCSV = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesOptions {
    cudaFlushGPUDirectRDMAWritesOptionHost = 1,
    cudaFlushGPUDirectRDMAWritesOptionMemOps = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGPUDirectRDMAWritesOrdering {
    cudaGPUDirectRDMAWritesOrderingNone = 0,
    cudaGPUDirectRDMAWritesOrderingOwner = 100,
    cudaGPUDirectRDMAWritesOrderingAllDevices = 200,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesScope {
    cudaFlushGPUDirectRDMAWritesToOwner = 100,
    cudaFlushGPUDirectRDMAWritesToAllDevices = 200,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaFlushGPUDirectRDMAWritesTarget {
    cudaFlushGPUDirectRDMAWritesTargetCurrentDevice = 0,
}
impl cudaDeviceAttr {
    pub const cudaDevAttrMaxTimelineSemaphoreInteropSupported: cudaDeviceAttr =
        cudaDeviceAttr::cudaDevAttrTimelineSemaphoreInteropSupported;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaDeviceAttr {
    cudaDevAttrMaxThreadsPerBlock = 1,
    cudaDevAttrMaxBlockDimX = 2,
    cudaDevAttrMaxBlockDimY = 3,
    cudaDevAttrMaxBlockDimZ = 4,
    cudaDevAttrMaxGridDimX = 5,
    cudaDevAttrMaxGridDimY = 6,
    cudaDevAttrMaxGridDimZ = 7,
    cudaDevAttrMaxSharedMemoryPerBlock = 8,
    cudaDevAttrTotalConstantMemory = 9,
    cudaDevAttrWarpSize = 10,
    cudaDevAttrMaxPitch = 11,
    cudaDevAttrMaxRegistersPerBlock = 12,
    cudaDevAttrClockRate = 13,
    cudaDevAttrTextureAlignment = 14,
    cudaDevAttrGpuOverlap = 15,
    cudaDevAttrMultiProcessorCount = 16,
    cudaDevAttrKernelExecTimeout = 17,
    cudaDevAttrIntegrated = 18,
    cudaDevAttrCanMapHostMemory = 19,
    cudaDevAttrComputeMode = 20,
    cudaDevAttrMaxTexture1DWidth = 21,
    cudaDevAttrMaxTexture2DWidth = 22,
    cudaDevAttrMaxTexture2DHeight = 23,
    cudaDevAttrMaxTexture3DWidth = 24,
    cudaDevAttrMaxTexture3DHeight = 25,
    cudaDevAttrMaxTexture3DDepth = 26,
    cudaDevAttrMaxTexture2DLayeredWidth = 27,
    cudaDevAttrMaxTexture2DLayeredHeight = 28,
    cudaDevAttrMaxTexture2DLayeredLayers = 29,
    cudaDevAttrSurfaceAlignment = 30,
    cudaDevAttrConcurrentKernels = 31,
    cudaDevAttrEccEnabled = 32,
    cudaDevAttrPciBusId = 33,
    cudaDevAttrPciDeviceId = 34,
    cudaDevAttrTccDriver = 35,
    cudaDevAttrMemoryClockRate = 36,
    cudaDevAttrGlobalMemoryBusWidth = 37,
    cudaDevAttrL2CacheSize = 38,
    cudaDevAttrMaxThreadsPerMultiProcessor = 39,
    cudaDevAttrAsyncEngineCount = 40,
    cudaDevAttrUnifiedAddressing = 41,
    cudaDevAttrMaxTexture1DLayeredWidth = 42,
    cudaDevAttrMaxTexture1DLayeredLayers = 43,
    cudaDevAttrMaxTexture2DGatherWidth = 45,
    cudaDevAttrMaxTexture2DGatherHeight = 46,
    cudaDevAttrMaxTexture3DWidthAlt = 47,
    cudaDevAttrMaxTexture3DHeightAlt = 48,
    cudaDevAttrMaxTexture3DDepthAlt = 49,
    cudaDevAttrPciDomainId = 50,
    cudaDevAttrTexturePitchAlignment = 51,
    cudaDevAttrMaxTextureCubemapWidth = 52,
    cudaDevAttrMaxTextureCubemapLayeredWidth = 53,
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54,
    cudaDevAttrMaxSurface1DWidth = 55,
    cudaDevAttrMaxSurface2DWidth = 56,
    cudaDevAttrMaxSurface2DHeight = 57,
    cudaDevAttrMaxSurface3DWidth = 58,
    cudaDevAttrMaxSurface3DHeight = 59,
    cudaDevAttrMaxSurface3DDepth = 60,
    cudaDevAttrMaxSurface1DLayeredWidth = 61,
    cudaDevAttrMaxSurface1DLayeredLayers = 62,
    cudaDevAttrMaxSurface2DLayeredWidth = 63,
    cudaDevAttrMaxSurface2DLayeredHeight = 64,
    cudaDevAttrMaxSurface2DLayeredLayers = 65,
    cudaDevAttrMaxSurfaceCubemapWidth = 66,
    cudaDevAttrMaxSurfaceCubemapLayeredWidth = 67,
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68,
    cudaDevAttrMaxTexture1DLinearWidth = 69,
    cudaDevAttrMaxTexture2DLinearWidth = 70,
    cudaDevAttrMaxTexture2DLinearHeight = 71,
    cudaDevAttrMaxTexture2DLinearPitch = 72,
    cudaDevAttrMaxTexture2DMipmappedWidth = 73,
    cudaDevAttrMaxTexture2DMipmappedHeight = 74,
    cudaDevAttrComputeCapabilityMajor = 75,
    cudaDevAttrComputeCapabilityMinor = 76,
    cudaDevAttrMaxTexture1DMipmappedWidth = 77,
    cudaDevAttrStreamPrioritiesSupported = 78,
    cudaDevAttrGlobalL1CacheSupported = 79,
    cudaDevAttrLocalL1CacheSupported = 80,
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81,
    cudaDevAttrMaxRegistersPerMultiprocessor = 82,
    cudaDevAttrManagedMemory = 83,
    cudaDevAttrIsMultiGpuBoard = 84,
    cudaDevAttrMultiGpuBoardGroupID = 85,
    cudaDevAttrHostNativeAtomicSupported = 86,
    cudaDevAttrSingleToDoublePrecisionPerfRatio = 87,
    cudaDevAttrPageableMemoryAccess = 88,
    cudaDevAttrConcurrentManagedAccess = 89,
    cudaDevAttrComputePreemptionSupported = 90,
    cudaDevAttrCanUseHostPointerForRegisteredMem = 91,
    cudaDevAttrReserved92 = 92,
    cudaDevAttrReserved93 = 93,
    cudaDevAttrReserved94 = 94,
    cudaDevAttrCooperativeLaunch = 95,
    cudaDevAttrCooperativeMultiDeviceLaunch = 96,
    cudaDevAttrMaxSharedMemoryPerBlockOptin = 97,
    cudaDevAttrCanFlushRemoteWrites = 98,
    cudaDevAttrHostRegisterSupported = 99,
    cudaDevAttrPageableMemoryAccessUsesHostPageTables = 100,
    cudaDevAttrDirectManagedMemAccessFromHost = 101,
    cudaDevAttrMaxBlocksPerMultiprocessor = 106,
    cudaDevAttrMaxPersistingL2CacheSize = 108,
    cudaDevAttrMaxAccessPolicyWindowSize = 109,
    cudaDevAttrReservedSharedMemoryPerBlock = 111,
    cudaDevAttrSparseCudaArraySupported = 112,
    cudaDevAttrHostRegisterReadOnlySupported = 113,
    cudaDevAttrTimelineSemaphoreInteropSupported = 114,
    cudaDevAttrMemoryPoolsSupported = 115,
    cudaDevAttrGPUDirectRDMASupported = 116,
    cudaDevAttrGPUDirectRDMAFlushWritesOptions = 117,
    cudaDevAttrGPUDirectRDMAWritesOrdering = 118,
    cudaDevAttrMemoryPoolSupportedHandleTypes = 119,
    cudaDevAttrDeferredMappingCudaArraySupported = 121,
    cudaDevAttrMax = 122,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemPoolAttr {
    cudaMemPoolReuseFollowEventDependencies = 1,
    cudaMemPoolReuseAllowOpportunistic = 2,
    cudaMemPoolReuseAllowInternalDependencies = 3,
    cudaMemPoolAttrReleaseThreshold = 4,
    cudaMemPoolAttrReservedMemCurrent = 5,
    cudaMemPoolAttrReservedMemHigh = 6,
    cudaMemPoolAttrUsedMemCurrent = 7,
    cudaMemPoolAttrUsedMemHigh = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemLocationType {
    cudaMemLocationTypeInvalid = 0,
    cudaMemLocationTypeDevice = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemLocation {
    pub type_: cudaMemLocationType,
    pub id: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaMemLocation() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemLocation>(),
        8usize,
        concat!("Size of: ", stringify!(cudaMemLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemLocation>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemLocation))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemLocation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemLocation),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemLocation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemLocation),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemAccessFlags {
    cudaMemAccessFlagsProtNone = 0,
    cudaMemAccessFlagsProtRead = 1,
    cudaMemAccessFlagsProtReadWrite = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAccessDesc {
    pub location: cudaMemLocation,
    pub flags: cudaMemAccessFlags,
}
#[test]
fn bindgen_test_layout_cudaMemAccessDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemAccessDesc>(),
        12usize,
        concat!("Size of: ", stringify!(cudaMemAccessDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAccessDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemAccessDesc))
    );
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAccessDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAccessDesc),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAccessDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAccessDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemAllocationType {
    cudaMemAllocationTypeInvalid = 0,
    cudaMemAllocationTypePinned = 1,
    cudaMemAllocationTypeMax = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaMemAllocationHandleType {
    cudaMemHandleTypeNone = 0,
    cudaMemHandleTypePosixFileDescriptor = 1,
    cudaMemHandleTypeWin32 = 2,
    cudaMemHandleTypeWin32Kmt = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaMemPoolProps {
    pub allocType: cudaMemAllocationType,
    pub handleTypes: cudaMemAllocationHandleType,
    pub location: cudaMemLocation,
    pub win32SecurityAttributes: *mut ::libc::c_void,
    pub reserved: [::libc::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolProps() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolProps>(),
        88usize,
        concat!("Size of: ", stringify!(cudaMemPoolProps))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolProps>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemPoolProps))
    );
    fn test_field_allocType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(allocType)
            )
        );
    }
    test_field_allocType();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_win32SecurityAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32SecurityAttributes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(win32SecurityAttributes)
            )
        );
    }
    test_field_win32SecurityAttributes();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaMemPoolPtrExportData {
    pub reserved: [::libc::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolPtrExportData() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolPtrExportData>(),
        64usize,
        concat!("Size of: ", stringify!(cudaMemPoolPtrExportData))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolPtrExportData>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaMemPoolPtrExportData))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolPtrExportData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolPtrExportData),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaMemAllocNodeParams {
    pub poolProps: cudaMemPoolProps,
    pub accessDescs: *const cudaMemAccessDesc,
    pub accessDescCount: usize,
    pub bytesize: usize,
    pub dptr: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaMemAllocNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemAllocNodeParams>(),
        120usize,
        concat!("Size of: ", stringify!(cudaMemAllocNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAllocNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemAllocNodeParams))
    );
    fn test_field_poolProps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(poolProps)
            )
        );
    }
    test_field_poolProps();
    fn test_field_accessDescs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(accessDescs)
            )
        );
    }
    test_field_accessDescs();
    fn test_field_accessDescCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(accessDescCount)
            )
        );
    }
    test_field_accessDescCount();
    fn test_field_bytesize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(bytesize)
            )
        );
    }
    test_field_bytesize();
    fn test_field_dptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(dptr)
            )
        );
    }
    test_field_dptr();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGraphMemAttributeType {
    cudaGraphMemAttrUsedMemCurrent = 0,
    cudaGraphMemAttrUsedMemHigh = 1,
    cudaGraphMemAttrReservedMemCurrent = 2,
    cudaGraphMemAttrReservedMemHigh = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaDeviceP2PAttr {
    cudaDevP2PAttrPerformanceRank = 1,
    cudaDevP2PAttrAccessSupported = 2,
    cudaDevP2PAttrNativeAtomicSupported = 3,
    cudaDevP2PAttrCudaArrayAccessSupported = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    fn test_field_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUuuid_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUuuid_st),
                "::",
                stringify!(bytes)
            )
        );
    }
    test_field_bytes();
}
pub type CUuuid = CUuuid_st;
pub type cudaUUID_t = CUuuid_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaDeviceProp {
    pub name: [::libc::c_char; 256usize],
    pub uuid: cudaUUID_t,
    pub luid: [::libc::c_char; 8usize],
    pub luidDeviceNodeMask: ::libc::c_uint,
    pub totalGlobalMem: usize,
    pub sharedMemPerBlock: usize,
    pub regsPerBlock: ::libc::c_int,
    pub warpSize: ::libc::c_int,
    pub memPitch: usize,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub maxThreadsDim: [::libc::c_int; 3usize],
    pub maxGridSize: [::libc::c_int; 3usize],
    pub clockRate: ::libc::c_int,
    pub totalConstMem: usize,
    pub major: ::libc::c_int,
    pub minor: ::libc::c_int,
    pub textureAlignment: usize,
    pub texturePitchAlignment: usize,
    pub deviceOverlap: ::libc::c_int,
    pub multiProcessorCount: ::libc::c_int,
    pub kernelExecTimeoutEnabled: ::libc::c_int,
    pub integrated: ::libc::c_int,
    pub canMapHostMemory: ::libc::c_int,
    pub computeMode: ::libc::c_int,
    pub maxTexture1D: ::libc::c_int,
    pub maxTexture1DMipmap: ::libc::c_int,
    pub maxTexture1DLinear: ::libc::c_int,
    pub maxTexture2D: [::libc::c_int; 2usize],
    pub maxTexture2DMipmap: [::libc::c_int; 2usize],
    pub maxTexture2DLinear: [::libc::c_int; 3usize],
    pub maxTexture2DGather: [::libc::c_int; 2usize],
    pub maxTexture3D: [::libc::c_int; 3usize],
    pub maxTexture3DAlt: [::libc::c_int; 3usize],
    pub maxTextureCubemap: ::libc::c_int,
    pub maxTexture1DLayered: [::libc::c_int; 2usize],
    pub maxTexture2DLayered: [::libc::c_int; 3usize],
    pub maxTextureCubemapLayered: [::libc::c_int; 2usize],
    pub maxSurface1D: ::libc::c_int,
    pub maxSurface2D: [::libc::c_int; 2usize],
    pub maxSurface3D: [::libc::c_int; 3usize],
    pub maxSurface1DLayered: [::libc::c_int; 2usize],
    pub maxSurface2DLayered: [::libc::c_int; 3usize],
    pub maxSurfaceCubemap: ::libc::c_int,
    pub maxSurfaceCubemapLayered: [::libc::c_int; 2usize],
    pub surfaceAlignment: usize,
    pub concurrentKernels: ::libc::c_int,
    pub ECCEnabled: ::libc::c_int,
    pub pciBusID: ::libc::c_int,
    pub pciDeviceID: ::libc::c_int,
    pub pciDomainID: ::libc::c_int,
    pub tccDriver: ::libc::c_int,
    pub asyncEngineCount: ::libc::c_int,
    pub unifiedAddressing: ::libc::c_int,
    pub memoryClockRate: ::libc::c_int,
    pub memoryBusWidth: ::libc::c_int,
    pub l2CacheSize: ::libc::c_int,
    pub persistingL2CacheMaxSize: ::libc::c_int,
    pub maxThreadsPerMultiProcessor: ::libc::c_int,
    pub streamPrioritiesSupported: ::libc::c_int,
    pub globalL1CacheSupported: ::libc::c_int,
    pub localL1CacheSupported: ::libc::c_int,
    pub sharedMemPerMultiprocessor: usize,
    pub regsPerMultiprocessor: ::libc::c_int,
    pub managedMemory: ::libc::c_int,
    pub isMultiGpuBoard: ::libc::c_int,
    pub multiGpuBoardGroupID: ::libc::c_int,
    pub hostNativeAtomicSupported: ::libc::c_int,
    pub singleToDoublePrecisionPerfRatio: ::libc::c_int,
    pub pageableMemoryAccess: ::libc::c_int,
    pub concurrentManagedAccess: ::libc::c_int,
    pub computePreemptionSupported: ::libc::c_int,
    pub canUseHostPointerForRegisteredMem: ::libc::c_int,
    pub cooperativeLaunch: ::libc::c_int,
    pub cooperativeMultiDeviceLaunch: ::libc::c_int,
    pub sharedMemPerBlockOptin: usize,
    pub pageableMemoryAccessUsesHostPageTables: ::libc::c_int,
    pub directManagedMemAccessFromHost: ::libc::c_int,
    pub maxBlocksPerMultiProcessor: ::libc::c_int,
    pub accessPolicyMaxWindowSize: ::libc::c_int,
    pub reservedSharedMemPerBlock: usize,
}
#[test]
fn bindgen_test_layout_cudaDeviceProp() {
    assert_eq!(
        ::std::mem::size_of::<cudaDeviceProp>(),
        728usize,
        concat!("Size of: ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaDeviceProp>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaDeviceProp))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(uuid)
            )
        );
    }
    test_field_uuid();
    fn test_field_luid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).luid) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(luid)
            )
        );
    }
    test_field_luid();
    fn test_field_luidDeviceNodeMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).luidDeviceNodeMask) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(luidDeviceNodeMask)
            )
        );
    }
    test_field_luidDeviceNodeMask();
    fn test_field_totalGlobalMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalGlobalMem) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(totalGlobalMem)
            )
        );
    }
    test_field_totalGlobalMem();
    fn test_field_sharedMemPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerBlock) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerBlock)
            )
        );
    }
    test_field_sharedMemPerBlock();
    fn test_field_regsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regsPerBlock) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(regsPerBlock)
            )
        );
    }
    test_field_regsPerBlock();
    fn test_field_warpSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).warpSize) as usize - ptr as usize
            },
            308usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(warpSize)
            )
        );
    }
    test_field_warpSize();
    fn test_field_memPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memPitch) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memPitch)
            )
        );
    }
    test_field_memPitch();
    fn test_field_maxThreadsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsPerBlock)
            )
        );
    }
    test_field_maxThreadsPerBlock();
    fn test_field_maxThreadsDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsDim) as usize - ptr as usize
            },
            324usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsDim)
            )
        );
    }
    test_field_maxThreadsDim();
    fn test_field_maxGridSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGridSize) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxGridSize)
            )
        );
    }
    test_field_maxGridSize();
    fn test_field_clockRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clockRate) as usize - ptr as usize
            },
            348usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(clockRate)
            )
        );
    }
    test_field_clockRate();
    fn test_field_totalConstMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalConstMem) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(totalConstMem)
            )
        );
    }
    test_field_totalConstMem();
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            364usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_textureAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureAlignment) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(textureAlignment)
            )
        );
    }
    test_field_textureAlignment();
    fn test_field_texturePitchAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).texturePitchAlignment) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(texturePitchAlignment)
            )
        );
    }
    test_field_texturePitchAlignment();
    fn test_field_deviceOverlap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceOverlap) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(deviceOverlap)
            )
        );
    }
    test_field_deviceOverlap();
    fn test_field_multiProcessorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiProcessorCount) as usize - ptr as usize
            },
            388usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(multiProcessorCount)
            )
        );
    }
    test_field_multiProcessorCount();
    fn test_field_kernelExecTimeoutEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernelExecTimeoutEnabled) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(kernelExecTimeoutEnabled)
            )
        );
    }
    test_field_kernelExecTimeoutEnabled();
    fn test_field_integrated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integrated) as usize - ptr as usize
            },
            396usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(integrated)
            )
        );
    }
    test_field_integrated();
    fn test_field_canMapHostMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canMapHostMemory) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(canMapHostMemory)
            )
        );
    }
    test_field_canMapHostMemory();
    fn test_field_computeMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeMode) as usize - ptr as usize
            },
            404usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(computeMode)
            )
        );
    }
    test_field_computeMode();
    fn test_field_maxTexture1D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1D) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1D)
            )
        );
    }
    test_field_maxTexture1D();
    fn test_field_maxTexture1DMipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DMipmap) as usize - ptr as usize
            },
            412usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DMipmap)
            )
        );
    }
    test_field_maxTexture1DMipmap();
    fn test_field_maxTexture1DLinear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DLinear) as usize - ptr as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DLinear)
            )
        );
    }
    test_field_maxTexture1DLinear();
    fn test_field_maxTexture2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2D) as usize - ptr as usize
            },
            420usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2D)
            )
        );
    }
    test_field_maxTexture2D();
    fn test_field_maxTexture2DMipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DMipmap) as usize - ptr as usize
            },
            428usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DMipmap)
            )
        );
    }
    test_field_maxTexture2DMipmap();
    fn test_field_maxTexture2DLinear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DLinear) as usize - ptr as usize
            },
            436usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DLinear)
            )
        );
    }
    test_field_maxTexture2DLinear();
    fn test_field_maxTexture2DGather() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DGather) as usize - ptr as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DGather)
            )
        );
    }
    test_field_maxTexture2DGather();
    fn test_field_maxTexture3D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture3D) as usize - ptr as usize
            },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture3D)
            )
        );
    }
    test_field_maxTexture3D();
    fn test_field_maxTexture3DAlt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture3DAlt) as usize - ptr as usize
            },
            468usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture3DAlt)
            )
        );
    }
    test_field_maxTexture3DAlt();
    fn test_field_maxTextureCubemap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTextureCubemap) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTextureCubemap)
            )
        );
    }
    test_field_maxTextureCubemap();
    fn test_field_maxTexture1DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DLayered) as usize - ptr as usize
            },
            484usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DLayered)
            )
        );
    }
    test_field_maxTexture1DLayered();
    fn test_field_maxTexture2DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DLayered) as usize - ptr as usize
            },
            492usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DLayered)
            )
        );
    }
    test_field_maxTexture2DLayered();
    fn test_field_maxTextureCubemapLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTextureCubemapLayered) as usize - ptr as usize
            },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTextureCubemapLayered)
            )
        );
    }
    test_field_maxTextureCubemapLayered();
    fn test_field_maxSurface1D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface1D) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface1D)
            )
        );
    }
    test_field_maxSurface1D();
    fn test_field_maxSurface2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface2D) as usize - ptr as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface2D)
            )
        );
    }
    test_field_maxSurface2D();
    fn test_field_maxSurface3D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface3D) as usize - ptr as usize
            },
            524usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface3D)
            )
        );
    }
    test_field_maxSurface3D();
    fn test_field_maxSurface1DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface1DLayered) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface1DLayered)
            )
        );
    }
    test_field_maxSurface1DLayered();
    fn test_field_maxSurface2DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface2DLayered) as usize - ptr as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface2DLayered)
            )
        );
    }
    test_field_maxSurface2DLayered();
    fn test_field_maxSurfaceCubemap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurfaceCubemap) as usize - ptr as usize
            },
            556usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurfaceCubemap)
            )
        );
    }
    test_field_maxSurfaceCubemap();
    fn test_field_maxSurfaceCubemapLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurfaceCubemapLayered) as usize - ptr as usize
            },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurfaceCubemapLayered)
            )
        );
    }
    test_field_maxSurfaceCubemapLayered();
    fn test_field_surfaceAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surfaceAlignment) as usize - ptr as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(surfaceAlignment)
            )
        );
    }
    test_field_surfaceAlignment();
    fn test_field_concurrentKernels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).concurrentKernels) as usize - ptr as usize
            },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(concurrentKernels)
            )
        );
    }
    test_field_concurrentKernels();
    fn test_field_ECCEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ECCEnabled) as usize - ptr as usize
            },
            580usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(ECCEnabled)
            )
        );
    }
    test_field_ECCEnabled();
    fn test_field_pciBusID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciBusID) as usize - ptr as usize
            },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciBusID)
            )
        );
    }
    test_field_pciBusID();
    fn test_field_pciDeviceID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDeviceID) as usize - ptr as usize
            },
            588usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciDeviceID)
            )
        );
    }
    test_field_pciDeviceID();
    fn test_field_pciDomainID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDomainID) as usize - ptr as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciDomainID)
            )
        );
    }
    test_field_pciDomainID();
    fn test_field_tccDriver() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tccDriver) as usize - ptr as usize
            },
            596usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(tccDriver)
            )
        );
    }
    test_field_tccDriver();
    fn test_field_asyncEngineCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).asyncEngineCount) as usize - ptr as usize
            },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(asyncEngineCount)
            )
        );
    }
    test_field_asyncEngineCount();
    fn test_field_unifiedAddressing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unifiedAddressing) as usize - ptr as usize
            },
            604usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(unifiedAddressing)
            )
        );
    }
    test_field_unifiedAddressing();
    fn test_field_memoryClockRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryClockRate) as usize - ptr as usize
            },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memoryClockRate)
            )
        );
    }
    test_field_memoryClockRate();
    fn test_field_memoryBusWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryBusWidth) as usize - ptr as usize
            },
            612usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memoryBusWidth)
            )
        );
    }
    test_field_memoryBusWidth();
    fn test_field_l2CacheSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2CacheSize) as usize - ptr as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(l2CacheSize)
            )
        );
    }
    test_field_l2CacheSize();
    fn test_field_persistingL2CacheMaxSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persistingL2CacheMaxSize) as usize - ptr as usize
            },
            620usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(persistingL2CacheMaxSize)
            )
        );
    }
    test_field_persistingL2CacheMaxSize();
    fn test_field_maxThreadsPerMultiProcessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerMultiProcessor) as usize - ptr as usize
            },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsPerMultiProcessor)
            )
        );
    }
    test_field_maxThreadsPerMultiProcessor();
    fn test_field_streamPrioritiesSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).streamPrioritiesSupported) as usize - ptr as usize
            },
            628usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(streamPrioritiesSupported)
            )
        );
    }
    test_field_streamPrioritiesSupported();
    fn test_field_globalL1CacheSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globalL1CacheSupported) as usize - ptr as usize
            },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(globalL1CacheSupported)
            )
        );
    }
    test_field_globalL1CacheSupported();
    fn test_field_localL1CacheSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localL1CacheSupported) as usize - ptr as usize
            },
            636usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(localL1CacheSupported)
            )
        );
    }
    test_field_localL1CacheSupported();
    fn test_field_sharedMemPerMultiprocessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerMultiprocessor) as usize - ptr as usize
            },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerMultiprocessor)
            )
        );
    }
    test_field_sharedMemPerMultiprocessor();
    fn test_field_regsPerMultiprocessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regsPerMultiprocessor) as usize - ptr as usize
            },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(regsPerMultiprocessor)
            )
        );
    }
    test_field_regsPerMultiprocessor();
    fn test_field_managedMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).managedMemory) as usize - ptr as usize
            },
            652usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(managedMemory)
            )
        );
    }
    test_field_managedMemory();
    fn test_field_isMultiGpuBoard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isMultiGpuBoard) as usize - ptr as usize
            },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(isMultiGpuBoard)
            )
        );
    }
    test_field_isMultiGpuBoard();
    fn test_field_multiGpuBoardGroupID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiGpuBoardGroupID) as usize - ptr as usize
            },
            660usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(multiGpuBoardGroupID)
            )
        );
    }
    test_field_multiGpuBoardGroupID();
    fn test_field_hostNativeAtomicSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostNativeAtomicSupported) as usize - ptr as usize
            },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(hostNativeAtomicSupported)
            )
        );
    }
    test_field_hostNativeAtomicSupported();
    fn test_field_singleToDoublePrecisionPerfRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleToDoublePrecisionPerfRatio) as usize
                    - ptr as usize
            },
            668usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(singleToDoublePrecisionPerfRatio)
            )
        );
    }
    test_field_singleToDoublePrecisionPerfRatio();
    fn test_field_pageableMemoryAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pageableMemoryAccess) as usize - ptr as usize
            },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pageableMemoryAccess)
            )
        );
    }
    test_field_pageableMemoryAccess();
    fn test_field_concurrentManagedAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).concurrentManagedAccess) as usize - ptr as usize
            },
            676usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(concurrentManagedAccess)
            )
        );
    }
    test_field_concurrentManagedAccess();
    fn test_field_computePreemptionSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computePreemptionSupported) as usize - ptr as usize
            },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(computePreemptionSupported)
            )
        );
    }
    test_field_computePreemptionSupported();
    fn test_field_canUseHostPointerForRegisteredMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canUseHostPointerForRegisteredMem) as usize
                    - ptr as usize
            },
            684usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(canUseHostPointerForRegisteredMem)
            )
        );
    }
    test_field_canUseHostPointerForRegisteredMem();
    fn test_field_cooperativeLaunch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeLaunch) as usize - ptr as usize
            },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(cooperativeLaunch)
            )
        );
    }
    test_field_cooperativeLaunch();
    fn test_field_cooperativeMultiDeviceLaunch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceLaunch) as usize - ptr as usize
            },
            692usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(cooperativeMultiDeviceLaunch)
            )
        );
    }
    test_field_cooperativeMultiDeviceLaunch();
    fn test_field_sharedMemPerBlockOptin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerBlockOptin) as usize - ptr as usize
            },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerBlockOptin)
            )
        );
    }
    test_field_sharedMemPerBlockOptin();
    fn test_field_pageableMemoryAccessUsesHostPageTables() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pageableMemoryAccessUsesHostPageTables) as usize
                    - ptr as usize
            },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pageableMemoryAccessUsesHostPageTables)
            )
        );
    }
    test_field_pageableMemoryAccessUsesHostPageTables();
    fn test_field_directManagedMemAccessFromHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directManagedMemAccessFromHost) as usize - ptr as usize
            },
            708usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(directManagedMemAccessFromHost)
            )
        );
    }
    test_field_directManagedMemAccessFromHost();
    fn test_field_maxBlocksPerMultiProcessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxBlocksPerMultiProcessor) as usize - ptr as usize
            },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxBlocksPerMultiProcessor)
            )
        );
    }
    test_field_maxBlocksPerMultiProcessor();
    fn test_field_accessPolicyMaxWindowSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyMaxWindowSize) as usize - ptr as usize
            },
            716usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(accessPolicyMaxWindowSize)
            )
        );
    }
    test_field_accessPolicyMaxWindowSize();
    fn test_field_reservedSharedMemPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedSharedMemPerBlock) as usize - ptr as usize
            },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(reservedSharedMemPerBlock)
            )
        );
    }
    test_field_reservedSharedMemPerBlock();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaIpcEventHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcEventHandle_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaIpcEventHandle_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaIpcEventHandle_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudaIpcEventHandle_t = cudaIpcEventHandle_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaIpcMemHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcMemHandle_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaIpcMemHandle_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaIpcMemHandle_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudaIpcMemHandle_t = cudaIpcMemHandle_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaExternalMemoryHandleType {
    cudaExternalMemoryHandleTypeOpaqueFd = 1,
    cudaExternalMemoryHandleTypeOpaqueWin32 = 2,
    cudaExternalMemoryHandleTypeOpaqueWin32Kmt = 3,
    cudaExternalMemoryHandleTypeD3D12Heap = 4,
    cudaExternalMemoryHandleTypeD3D12Resource = 5,
    cudaExternalMemoryHandleTypeD3D11Resource = 6,
    cudaExternalMemoryHandleTypeD3D11ResourceKmt = 7,
    cudaExternalMemoryHandleTypeNvSciBuf = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc {
    pub type_: cudaExternalMemoryHandleType,
    pub handle: cudaExternalMemoryHandleDesc__bindgen_ty_1,
    pub size: ::libc::c_ulonglong,
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalMemoryHandleDesc__bindgen_ty_1 {
    pub fd: ::libc::c_int,
    pub win32: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::libc::c_void,
    pub name: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_win32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(win32)
            )
        );
    }
    test_field_win32();
    fn test_field_nvSciBufObject() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciBufObject) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(nvSciBufObject)
            )
        );
    }
    test_field_nvSciBufObject();
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryHandleDesc))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryBufferDesc {
    pub offset: ::libc::c_ulonglong,
    pub size: ::libc::c_ulonglong,
    pub flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryBufferDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryBufferDesc>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryBufferDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryBufferDesc))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryMipmappedArrayDesc {
    pub offset: ::libc::c_ulonglong,
    pub formatDesc: cudaChannelFormatDesc,
    pub extent: cudaExtent,
    pub flags: ::libc::c_uint,
    pub numLevels: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryMipmappedArrayDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_formatDesc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).formatDesc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(formatDesc)
            )
        );
    }
    test_field_formatDesc();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_numLevels() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numLevels) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(numLevels)
            )
        );
    }
    test_field_numLevels();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaExternalSemaphoreHandleType {
    cudaExternalSemaphoreHandleTypeOpaqueFd = 1,
    cudaExternalSemaphoreHandleTypeOpaqueWin32 = 2,
    cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,
    cudaExternalSemaphoreHandleTypeD3D12Fence = 4,
    cudaExternalSemaphoreHandleTypeD3D11Fence = 5,
    cudaExternalSemaphoreHandleTypeNvSciSync = 6,
    cudaExternalSemaphoreHandleTypeKeyedMutex = 7,
    cudaExternalSemaphoreHandleTypeKeyedMutexKmt = 8,
    cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd = 9,
    cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = 10,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc {
    pub type_: cudaExternalSemaphoreHandleType,
    pub handle: cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
    pub fd: ::libc::c_int,
    pub win32: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSyncObj: *const ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::libc::c_void,
    pub name: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_win32() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(win32)
            )
        );
    }
    test_field_win32();
    fn test_field_nvSciSyncObj() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSyncObj) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(nvSciSyncObj)
            )
        );
    }
    test_field_nvSciSyncObj();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc>(),
        32usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1 {
    pub params: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1 {
    pub params: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
    pub timeoutMs: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_timeoutMs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(timeoutMs)
            )
        );
    }
    test_field_timeoutMs();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams {
    pub params: cudaExternalSemaphoreSignalParams__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::libc::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreSignalParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams {
    pub params: cudaExternalSemaphoreWaitParams__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::libc::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
    pub timeoutMs: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_timeoutMs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(timeoutMs)
            )
        );
    }
    test_field_timeoutMs();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub use self::cudaError as cudaError_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type cudaStream_t = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type cudaEvent_t = *mut CUevent_st;
pub type cudaGraphicsResource_t = *mut cudaGraphicsResource;
pub use self::cudaOutputMode as cudaOutputMode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalMemory_st {
    _unused: [u8; 0],
}
pub type cudaExternalMemory_t = *mut CUexternalMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalSemaphore_st {
    _unused: [u8; 0],
}
pub type cudaExternalSemaphore_t = *mut CUexternalSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type cudaGraph_t = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type cudaGraphNode_t = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
pub type cudaUserObject_t = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type cudaFunction_t = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
pub type cudaMemPool_t = *mut CUmemPoolHandle_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaCGScope {
    cudaCGScopeInvalid = 0,
    cudaCGScopeGrid = 1,
    cudaCGScopeMultiGrid = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchParams {
    pub func: *mut ::libc::c_void,
    pub gridDim: dim3,
    pub blockDim: dim3,
    pub args: *mut *mut ::libc::c_void,
    pub sharedMem: usize,
    pub stream: cudaStream_t,
}
#[test]
fn bindgen_test_layout_cudaLaunchParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchParams))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_gridDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(gridDim)
            )
        );
    }
    test_field_gridDim();
    fn test_field_blockDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(blockDim)
            )
        );
    }
    test_field_blockDim();
    fn test_field_args() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(args)
            )
        );
    }
    test_field_args();
    fn test_field_sharedMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMem) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(sharedMem)
            )
        );
    }
    test_field_sharedMem();
    fn test_field_stream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(stream)
            )
        );
    }
    test_field_stream();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaKernelNodeParams {
    pub func: *mut ::libc::c_void,
    pub gridDim: dim3,
    pub blockDim: dim3,
    pub sharedMemBytes: ::libc::c_uint,
    pub kernelParams: *mut *mut ::libc::c_void,
    pub extra: *mut *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeParams))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_gridDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(gridDim)
            )
        );
    }
    test_field_gridDim();
    fn test_field_blockDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(blockDim)
            )
        );
    }
    test_field_blockDim();
    fn test_field_sharedMemBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(sharedMemBytes)
            )
        );
    }
    test_field_sharedMemBytes();
    fn test_field_kernelParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(kernelParams)
            )
        );
    }
    test_field_kernelParams();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalNodeParams {
    pub extSemArray: *mut cudaExternalSemaphore_t,
    pub paramsArray: *const cudaExternalSemaphoreSignalParams,
    pub numExtSems: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalNodeParams>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    fn test_field_extSemArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(extSemArray)
            )
        );
    }
    test_field_extSemArray();
    fn test_field_paramsArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(paramsArray)
            )
        );
    }
    test_field_paramsArray();
    fn test_field_numExtSems() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(numExtSems)
            )
        );
    }
    test_field_numExtSems();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitNodeParams {
    pub extSemArray: *mut cudaExternalSemaphore_t,
    pub paramsArray: *const cudaExternalSemaphoreWaitParams,
    pub numExtSems: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitNodeParams>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitNodeParams)
        )
    );
    fn test_field_extSemArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(extSemArray)
            )
        );
    }
    test_field_extSemArray();
    fn test_field_paramsArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(paramsArray)
            )
        );
    }
    test_field_paramsArray();
    fn test_field_numExtSems() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(numExtSems)
            )
        );
    }
    test_field_numExtSems();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGraphNodeType {
    cudaGraphNodeTypeKernel = 0,
    cudaGraphNodeTypeMemcpy = 1,
    cudaGraphNodeTypeMemset = 2,
    cudaGraphNodeTypeHost = 3,
    cudaGraphNodeTypeGraph = 4,
    cudaGraphNodeTypeEmpty = 5,
    cudaGraphNodeTypeWaitEvent = 6,
    cudaGraphNodeTypeEventRecord = 7,
    cudaGraphNodeTypeExtSemaphoreSignal = 8,
    cudaGraphNodeTypeExtSemaphoreWait = 9,
    cudaGraphNodeTypeMemAlloc = 10,
    cudaGraphNodeTypeMemFree = 11,
    cudaGraphNodeTypeCount = 12,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type cudaGraphExec_t = *mut CUgraphExec_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGraphExecUpdateResult {
    cudaGraphExecUpdateSuccess = 0,
    cudaGraphExecUpdateError = 1,
    cudaGraphExecUpdateErrorTopologyChanged = 2,
    cudaGraphExecUpdateErrorNodeTypeChanged = 3,
    cudaGraphExecUpdateErrorFunctionChanged = 4,
    cudaGraphExecUpdateErrorParametersChanged = 5,
    cudaGraphExecUpdateErrorNotSupported = 6,
    cudaGraphExecUpdateErrorUnsupportedFunctionChange = 7,
    cudaGraphExecUpdateErrorAttributesChanged = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGetDriverEntryPointFlags {
    cudaEnableDefault = 0,
    cudaEnableLegacyStream = 1,
    cudaEnablePerThreadDefaultStream = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGraphDebugDotFlags {
    cudaGraphDebugDotFlagsVerbose = 1,
    cudaGraphDebugDotFlagsKernelNodeParams = 4,
    cudaGraphDebugDotFlagsMemcpyNodeParams = 8,
    cudaGraphDebugDotFlagsMemsetNodeParams = 16,
    cudaGraphDebugDotFlagsHostNodeParams = 32,
    cudaGraphDebugDotFlagsEventNodeParams = 64,
    cudaGraphDebugDotFlagsExtSemasSignalNodeParams = 128,
    cudaGraphDebugDotFlagsExtSemasWaitNodeParams = 256,
    cudaGraphDebugDotFlagsKernelNodeAttributes = 512,
    cudaGraphDebugDotFlagsHandles = 1024,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaGraphInstantiateFlags {
    cudaGraphInstantiateFlagAutoFreeOnLaunch = 1,
    cudaGraphInstantiateFlagUseNodePriority = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaStreamAttrID {
    cudaStreamAttributeAccessPolicyWindow = 1,
    cudaStreamAttributeSynchronizationPolicy = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaStreamAttrValue {
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub syncPolicy: cudaSynchronizationPolicy,
}
#[test]
fn bindgen_test_layout_cudaStreamAttrValue() {
    assert_eq!(
        ::std::mem::size_of::<cudaStreamAttrValue>(),
        32usize,
        concat!("Size of: ", stringify!(cudaStreamAttrValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaStreamAttrValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaStreamAttrValue))
    );
    fn test_field_accessPolicyWindow() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaStreamAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaStreamAttrValue),
                "::",
                stringify!(accessPolicyWindow)
            )
        );
    }
    test_field_accessPolicyWindow();
    fn test_field_syncPolicy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaStreamAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncPolicy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaStreamAttrValue),
                "::",
                stringify!(syncPolicy)
            )
        );
    }
    test_field_syncPolicy();
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaKernelNodeAttrID {
    cudaKernelNodeAttributeAccessPolicyWindow = 1,
    cudaKernelNodeAttributeCooperative = 2,
    cudaKernelNodeAttributePriority = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaKernelNodeAttrValue {
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub cooperative: ::libc::c_int,
    pub priority: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeAttrValue() {
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeAttrValue>(),
        32usize,
        concat!("Size of: ", stringify!(cudaKernelNodeAttrValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeAttrValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeAttrValue))
    );
    fn test_field_accessPolicyWindow() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeAttrValue),
                "::",
                stringify!(accessPolicyWindow)
            )
        );
    }
    test_field_accessPolicyWindow();
    fn test_field_cooperative() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperative) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeAttrValue),
                "::",
                stringify!(cooperative)
            )
        );
    }
    test_field_cooperative();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeAttrValue),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
}
pub type cuFloatComplex = float2;
pub type cuDoubleComplex = double2;
pub type cuComplex = cuFloatComplex;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cudaDataType_t {
    CUDA_R_16F = 2,
    CUDA_C_16F = 6,
    CUDA_R_16BF = 14,
    CUDA_C_16BF = 15,
    CUDA_R_32F = 0,
    CUDA_C_32F = 4,
    CUDA_R_64F = 1,
    CUDA_C_64F = 5,
    CUDA_R_4I = 16,
    CUDA_C_4I = 17,
    CUDA_R_4U = 18,
    CUDA_C_4U = 19,
    CUDA_R_8I = 3,
    CUDA_C_8I = 7,
    CUDA_R_8U = 8,
    CUDA_C_8U = 9,
    CUDA_R_16I = 20,
    CUDA_C_16I = 21,
    CUDA_R_16U = 22,
    CUDA_C_16U = 23,
    CUDA_R_32I = 10,
    CUDA_C_32I = 11,
    CUDA_R_32U = 12,
    CUDA_C_32U = 13,
    CUDA_R_64I = 24,
    CUDA_C_64I = 25,
    CUDA_R_64U = 26,
    CUDA_C_64U = 27,
}
pub use self::cudaDataType_t as cudaDataType;
pub const libraryPropertyType_t_MAJOR_VERSION: libraryPropertyType_t = 0;
pub const libraryPropertyType_t_MINOR_VERSION: libraryPropertyType_t = 1;
pub const libraryPropertyType_t_PATCH_LEVEL: libraryPropertyType_t = 2;
pub type libraryPropertyType_t = ::libc::c_uint;
pub use self::libraryPropertyType_t as libraryPropertyType;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasStatus_t {
    CUBLAS_STATUS_SUCCESS = 0,
    CUBLAS_STATUS_NOT_INITIALIZED = 1,
    CUBLAS_STATUS_ALLOC_FAILED = 3,
    CUBLAS_STATUS_INVALID_VALUE = 7,
    CUBLAS_STATUS_ARCH_MISMATCH = 8,
    CUBLAS_STATUS_MAPPING_ERROR = 11,
    CUBLAS_STATUS_EXECUTION_FAILED = 13,
    CUBLAS_STATUS_INTERNAL_ERROR = 14,
    CUBLAS_STATUS_NOT_SUPPORTED = 15,
    CUBLAS_STATUS_LICENSE_ERROR = 16,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasFillMode_t {
    CUBLAS_FILL_MODE_LOWER = 0,
    CUBLAS_FILL_MODE_UPPER = 1,
    CUBLAS_FILL_MODE_FULL = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasDiagType_t {
    CUBLAS_DIAG_NON_UNIT = 0,
    CUBLAS_DIAG_UNIT = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasSideMode_t {
    CUBLAS_SIDE_LEFT = 0,
    CUBLAS_SIDE_RIGHT = 1,
}
impl cublasOperation_t {
    pub const CUBLAS_OP_HERMITAN: cublasOperation_t = cublasOperation_t::CUBLAS_OP_C;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasOperation_t {
    CUBLAS_OP_N = 0,
    CUBLAS_OP_T = 1,
    CUBLAS_OP_C = 2,
    CUBLAS_OP_CONJG = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasPointerMode_t {
    CUBLAS_POINTER_MODE_HOST = 0,
    CUBLAS_POINTER_MODE_DEVICE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasAtomicsMode_t {
    CUBLAS_ATOMICS_NOT_ALLOWED = 0,
    CUBLAS_ATOMICS_ALLOWED = 1,
}
impl cublasGemmAlgo_t {
    pub const CUBLAS_GEMM_DEFAULT: cublasGemmAlgo_t = cublasGemmAlgo_t::CUBLAS_GEMM_DFALT;
}
impl cublasGemmAlgo_t {
    pub const CUBLAS_GEMM_DFALT_TENSOR_OP: cublasGemmAlgo_t =
        cublasGemmAlgo_t::CUBLAS_GEMM_DEFAULT_TENSOR_OP;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasGemmAlgo_t {
    CUBLAS_GEMM_DFALT = -1,
    CUBLAS_GEMM_ALGO0 = 0,
    CUBLAS_GEMM_ALGO1 = 1,
    CUBLAS_GEMM_ALGO2 = 2,
    CUBLAS_GEMM_ALGO3 = 3,
    CUBLAS_GEMM_ALGO4 = 4,
    CUBLAS_GEMM_ALGO5 = 5,
    CUBLAS_GEMM_ALGO6 = 6,
    CUBLAS_GEMM_ALGO7 = 7,
    CUBLAS_GEMM_ALGO8 = 8,
    CUBLAS_GEMM_ALGO9 = 9,
    CUBLAS_GEMM_ALGO10 = 10,
    CUBLAS_GEMM_ALGO11 = 11,
    CUBLAS_GEMM_ALGO12 = 12,
    CUBLAS_GEMM_ALGO13 = 13,
    CUBLAS_GEMM_ALGO14 = 14,
    CUBLAS_GEMM_ALGO15 = 15,
    CUBLAS_GEMM_ALGO16 = 16,
    CUBLAS_GEMM_ALGO17 = 17,
    CUBLAS_GEMM_ALGO18 = 18,
    CUBLAS_GEMM_ALGO19 = 19,
    CUBLAS_GEMM_ALGO20 = 20,
    CUBLAS_GEMM_ALGO21 = 21,
    CUBLAS_GEMM_ALGO22 = 22,
    CUBLAS_GEMM_ALGO23 = 23,
    CUBLAS_GEMM_DEFAULT_TENSOR_OP = 99,
    CUBLAS_GEMM_ALGO0_TENSOR_OP = 100,
    CUBLAS_GEMM_ALGO1_TENSOR_OP = 101,
    CUBLAS_GEMM_ALGO2_TENSOR_OP = 102,
    CUBLAS_GEMM_ALGO3_TENSOR_OP = 103,
    CUBLAS_GEMM_ALGO4_TENSOR_OP = 104,
    CUBLAS_GEMM_ALGO5_TENSOR_OP = 105,
    CUBLAS_GEMM_ALGO6_TENSOR_OP = 106,
    CUBLAS_GEMM_ALGO7_TENSOR_OP = 107,
    CUBLAS_GEMM_ALGO8_TENSOR_OP = 108,
    CUBLAS_GEMM_ALGO9_TENSOR_OP = 109,
    CUBLAS_GEMM_ALGO10_TENSOR_OP = 110,
    CUBLAS_GEMM_ALGO11_TENSOR_OP = 111,
    CUBLAS_GEMM_ALGO12_TENSOR_OP = 112,
    CUBLAS_GEMM_ALGO13_TENSOR_OP = 113,
    CUBLAS_GEMM_ALGO14_TENSOR_OP = 114,
    CUBLAS_GEMM_ALGO15_TENSOR_OP = 115,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasMath_t {
    CUBLAS_DEFAULT_MATH = 0,
    CUBLAS_TENSOR_OP_MATH = 1,
    CUBLAS_PEDANTIC_MATH = 2,
    CUBLAS_TF32_TENSOR_OP_MATH = 3,
    CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION = 16,
}
pub use self::cudaDataType as cublasDataType_t;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum cublasComputeType_t {
    CUBLAS_COMPUTE_16F = 64,
    CUBLAS_COMPUTE_16F_PEDANTIC = 65,
    CUBLAS_COMPUTE_32F = 68,
    CUBLAS_COMPUTE_32F_PEDANTIC = 69,
    CUBLAS_COMPUTE_32F_FAST_16F = 74,
    CUBLAS_COMPUTE_32F_FAST_16BF = 75,
    CUBLAS_COMPUTE_32F_FAST_TF32 = 77,
    CUBLAS_COMPUTE_64F = 70,
    CUBLAS_COMPUTE_64F_PEDANTIC = 71,
    CUBLAS_COMPUTE_32I = 72,
    CUBLAS_COMPUTE_32I_PEDANTIC = 73,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cublasContext {
    _unused: [u8; 0],
}
pub type cublasHandle_t = *mut cublasContext;
extern "C" {
    pub fn cublasCreate_v2(handle: *mut cublasHandle_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDestroy_v2(handle: cublasHandle_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVersion_v2(
        handle: cublasHandle_t,
        version: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetProperty(
        type_: libraryPropertyType,
        value: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetCudartVersion() -> usize;
}
extern "C" {
    pub fn cublasSetWorkspace_v2(
        handle: cublasHandle_t,
        workspace: *mut ::libc::c_void,
        workspaceSizeInBytes: usize,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetStream_v2(handle: cublasHandle_t, streamId: cudaStream_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetStream_v2(
        handle: cublasHandle_t,
        streamId: *mut cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetPointerMode_v2(
        handle: cublasHandle_t,
        mode: *mut cublasPointerMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetPointerMode_v2(
        handle: cublasHandle_t,
        mode: cublasPointerMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetAtomicsMode(
        handle: cublasHandle_t,
        mode: *mut cublasAtomicsMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetAtomicsMode(
        handle: cublasHandle_t,
        mode: cublasAtomicsMode_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMathMode(handle: cublasHandle_t, mode: *mut cublasMath_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMathMode(handle: cublasHandle_t, mode: cublasMath_t) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetSmCountTarget(
        handle: cublasHandle_t,
        smCountTarget: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetSmCountTarget(
        handle: cublasHandle_t,
        smCountTarget: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetStatusName(status: cublasStatus_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn cublasGetStatusString(status: cublasStatus_t) -> *const ::libc::c_char;
}
pub type cublasLogCallback =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::libc::c_char)>;
extern "C" {
    pub fn cublasLoggerConfigure(
        logIsOn: ::libc::c_int,
        logToStdOut: ::libc::c_int,
        logToStdErr: ::libc::c_int,
        logFileName: *const ::libc::c_char,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetLoggerCallback(userCallback: cublasLogCallback) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetLoggerCallback(userCallback: *mut cublasLogCallback) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetVector(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        x: *const ::libc::c_void,
        incx: ::libc::c_int,
        devicePtr: *mut ::libc::c_void,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVector(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        x: *const ::libc::c_void,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMatrix(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMatrix(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetVectorAsync(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        hostPtr: *const ::libc::c_void,
        incx: ::libc::c_int,
        devicePtr: *mut ::libc::c_void,
        incy: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetVectorAsync(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        devicePtr: *const ::libc::c_void,
        incx: ::libc::c_int,
        hostPtr: *mut ::libc::c_void,
        incy: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSetMatrixAsync(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGetMatrixAsync(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
        stream: cudaStream_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasXerbla(srName: *const ::libc::c_char, info: ::libc::c_int);
}
extern "C" {
    pub fn cublasNrm2Ex(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        result: *mut ::libc::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSnrm2_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDnrm2_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScnrm2_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDznrm2_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDotEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *const ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        result: *mut ::libc::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDotcEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *const ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        result: *mut ::libc::c_void,
        resultType: cudaDataType,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSdot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDdot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdotu_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        result: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdotc_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        result: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdotu_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        result: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdotc_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        result: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScalEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const ::libc::c_void,
        alphaType: cudaDataType,
        x: *mut ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        executionType: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdscal_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasAxpyEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const ::libc::c_void,
        alphaType: cudaDataType,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSaxpy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDaxpy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCaxpy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZaxpy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCopyEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScopy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDcopy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCcopy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZcopy_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSswap_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDswap_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCswap_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZswap_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSwapEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIsamax_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIdamax_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIcamax_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIzamax_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIamaxEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIsamin_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIdamin_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIcamin_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIzamin_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasIaminEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasAsumEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        result: *mut ::libc::c_void,
        resultType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSasum_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDasum_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasScasum_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDzasum_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
        y: *mut cuComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdrot_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        c: *const ::libc::c_void,
        s: *const ::libc::c_void,
        csType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotg_v2(
        handle: cublasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotg_v2(
        handle: cublasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCrotg_v2(
        handle: cublasHandle_t,
        a: *mut cuComplex,
        b: *mut cuComplex,
        c: *mut f32,
        s: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZrotg_v2(
        handle: cublasHandle_t,
        a: *mut cuDoubleComplex,
        b: *mut cuDoubleComplex,
        c: *mut f64,
        s: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotgEx(
        handle: cublasHandle_t,
        a: *mut ::libc::c_void,
        b: *mut ::libc::c_void,
        abType: cudaDataType,
        c: *mut ::libc::c_void,
        s: *mut ::libc::c_void,
        csType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotm_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        param: *const f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotm_v2(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        param: *const f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotmEx(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        x: *mut ::libc::c_void,
        xType: cudaDataType,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        yType: cudaDataType,
        incy: ::libc::c_int,
        param: *const ::libc::c_void,
        paramType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSrotmg_v2(
        handle: cublasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDrotmg_v2(
        handle: cublasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasRotmgEx(
        handle: cublasHandle_t,
        d1: *mut ::libc::c_void,
        d1Type: cudaDataType,
        d2: *mut ::libc::c_void,
        d2Type: cudaDataType,
        x1: *mut ::libc::c_void,
        x1Type: cudaDataType,
        y1: *const ::libc::c_void,
        y1Type: cudaDataType,
        param: *mut ::libc::c_void,
        paramType: cudaDataType,
        executiontype: cudaDataType,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgbmv_v2(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const cuComplex,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const cuComplex,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        AP: *const cuDoubleComplex,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *mut cuComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtbsv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *mut cuDoubleComplex,
        incx: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsymv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChemv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhemv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhbmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        AP: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpmv_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        AP: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSger_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDger_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeru_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgerc_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeru_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgerc_v2(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const cuComplex,
        incx: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const cuComplex,
        incx: ::libc::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpr_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSspr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDspr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChpr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        x: *const cuComplex,
        incx: ::libc::c_int,
        y: *const cuComplex,
        incy: ::libc::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhpr2_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        y: *const cuDoubleComplex,
        incy: ::libc::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemvBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        Aarray: *const *const f32,
        lda: ::libc::c_int,
        xarray: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        yarray: *const *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemvBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        Aarray: *const *const f64,
        lda: ::libc::c_int,
        xarray: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        yarray: *const *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemvBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::libc::c_int,
        xarray: *const *const cuComplex,
        incx: ::libc::c_int,
        beta: *const cuComplex,
        yarray: *const *mut cuComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemvBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        Aarray: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        xarray: *const *const cuDoubleComplex,
        incx: ::libc::c_int,
        beta: *const cuDoubleComplex,
        yarray: *const *mut cuDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemvStridedBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_longlong,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemvStridedBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_longlong,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemvStridedBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        x: *const cuComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_longlong,
        beta: *const cuComplex,
        y: *mut cuComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemvStridedBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_longlong,
        beta: *const cuDoubleComplex,
        y: *mut cuDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3m(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemm_v2(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemm3m(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const ::libc::c_void,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const ::libc::c_void,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasUint8gemmBias(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        transc: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        A: *const ::libc::c_uchar,
        A_bias: ::libc::c_int,
        lda: ::libc::c_int,
        B: *const ::libc::c_uchar,
        B_bias: ::libc::c_int,
        ldb: ::libc::c_int,
        C: *mut ::libc::c_uchar,
        C_bias: ::libc::c_int,
        ldc: ::libc::c_int,
        C_mult: ::libc::c_int,
        C_shift: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyrk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrkEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrk3mEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const cuComplex,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZherk_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherkEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherk3mEx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyr2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCher2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZher2k_v2(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsyrkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCherkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZherkx(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZsymm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasChemm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZhemm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *mut cuComplex,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *mut cuDoubleComplex,
        ldb: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrmm_v2(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        Aarray: *const *const f32,
        lda: ::libc::c_int,
        Barray: *const *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        Carray: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        Aarray: *const *const f64,
        lda: ::libc::c_int,
        Barray: *const *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        Carray: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::libc::c_int,
        Barray: *const *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        Carray: *const *mut cuComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        Aarray: *const *const cuComplex,
        lda: ::libc::c_int,
        Barray: *const *const cuComplex,
        ldb: ::libc::c_int,
        beta: *const cuComplex,
        Carray: *const *mut cuComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemmBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        Aarray: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        Barray: *const *const cuDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const cuDoubleComplex,
        Carray: *const *mut cuDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmBatchedEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const ::libc::c_void,
        Aarray: *const *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        Barray: *const *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        beta: *const ::libc::c_void,
        Carray: *const *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasGemmStridedBatchedEx(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const ::libc::c_void,
        A: *const ::libc::c_void,
        Atype: cudaDataType,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const ::libc::c_void,
        Btype: cudaDataType,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const ::libc::c_void,
        C: *mut ::libc::c_void,
        Ctype: cudaDataType,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
        computeType: cublasComputeType_t,
        algo: cublasGemmAlgo_t,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgemm3mStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const cuComplex,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgemmStridedBatched(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_longlong,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_longlong,
        beta: *const cuDoubleComplex,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        B: *const f32,
        ldb: ::libc::c_int,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        B: *const f64,
        ldb: ::libc::c_int,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const cuComplex,
        lda: ::libc::c_int,
        beta: *const cuComplex,
        B: *const cuComplex,
        ldb: ::libc::c_int,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeam(
        handle: cublasHandle_t,
        transa: cublasOperation_t,
        transb: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        beta: *const cuDoubleComplex,
        B: *const cuDoubleComplex,
        ldb: ::libc::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetrfBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        P: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetrfBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        P: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetrfBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *mut cuComplex,
        lda: ::libc::c_int,
        P: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetrfBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *mut cuDoubleComplex,
        lda: ::libc::c_int,
        P: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetriBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        P: *const ::libc::c_int,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetriBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        P: *const ::libc::c_int,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetriBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const cuComplex,
        lda: ::libc::c_int,
        P: *const ::libc::c_int,
        C: *const *mut cuComplex,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetriBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        P: *const ::libc::c_int,
        C: *const *mut cuDoubleComplex,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *const f32,
        lda: ::libc::c_int,
        devIpiv: *const ::libc::c_int,
        Barray: *const *mut f32,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *const f64,
        lda: ::libc::c_int,
        devIpiv: *const ::libc::c_int,
        Barray: *const *mut f64,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *const cuComplex,
        lda: ::libc::c_int,
        devIpiv: *const ::libc::c_int,
        Barray: *const *mut cuComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgetrsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        devIpiv: *const ::libc::c_int,
        Barray: *const *mut cuDoubleComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *mut f32,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *mut f64,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuComplex,
        A: *const *const cuComplex,
        lda: ::libc::c_int,
        B: *const *mut cuComplex,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrsmBatched(
        handle: cublasHandle_t,
        side: cublasSideMode_t,
        uplo: cublasFillMode_t,
        trans: cublasOperation_t,
        diag: cublasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const cuDoubleComplex,
        A: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        B: *const *mut cuDoubleComplex,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSmatinvBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        Ainv: *const *mut f32,
        lda_inv: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDmatinvBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        Ainv: *const *mut f64,
        lda_inv: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCmatinvBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const cuComplex,
        lda: ::libc::c_int,
        Ainv: *const *mut cuComplex,
        lda_inv: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZmatinvBatched(
        handle: cublasHandle_t,
        n: ::libc::c_int,
        A: *const *const cuDoubleComplex,
        lda: ::libc::c_int,
        Ainv: *const *mut cuDoubleComplex,
        lda_inv: ::libc::c_int,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgeqrfBatched(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        Aarray: *const *mut f32,
        lda: ::libc::c_int,
        TauArray: *const *mut f32,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgeqrfBatched(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        Aarray: *const *mut f64,
        lda: ::libc::c_int,
        TauArray: *const *mut f64,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgeqrfBatched(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        Aarray: *const *mut cuComplex,
        lda: ::libc::c_int,
        TauArray: *const *mut cuComplex,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgeqrfBatched(
        handle: cublasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        Aarray: *const *mut cuDoubleComplex,
        lda: ::libc::c_int,
        TauArray: *const *mut cuDoubleComplex,
        info: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *mut f32,
        lda: ::libc::c_int,
        Carray: *const *mut f32,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        devInfoArray: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *mut f64,
        lda: ::libc::c_int,
        Carray: *const *mut f64,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        devInfoArray: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *mut cuComplex,
        lda: ::libc::c_int,
        Carray: *const *mut cuComplex,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        devInfoArray: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZgelsBatched(
        handle: cublasHandle_t,
        trans: cublasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        Aarray: *const *mut cuDoubleComplex,
        lda: ::libc::c_int,
        Carray: *const *mut cuDoubleComplex,
        ldc: ::libc::c_int,
        info: *mut ::libc::c_int,
        devInfoArray: *mut ::libc::c_int,
        batchSize: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasSdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        x: *const cuComplex,
        incx: ::libc::c_int,
        C: *mut cuComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZdgmm(
        handle: cublasHandle_t,
        mode: cublasSideMode_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        x: *const cuDoubleComplex,
        incx: ::libc::c_int,
        C: *mut cuDoubleComplex,
        ldc: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        AP: *const f32,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        AP: *const f64,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        AP: *const cuComplex,
        A: *mut cuComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtpttr(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        AP: *const cuDoubleComplex,
        A: *mut cuDoubleComplex,
        lda: ::libc::c_int,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasStrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        AP: *mut f32,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasDtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        AP: *mut f64,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasCtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        A: *const cuComplex,
        lda: ::libc::c_int,
        AP: *mut cuComplex,
    ) -> cublasStatus_t;
}
extern "C" {
    pub fn cublasZtrttp(
        handle: cublasHandle_t,
        uplo: cublasFillMode_t,
        n: ::libc::c_int,
        A: *const cuDoubleComplex,
        lda: ::libc::c_int,
        AP: *mut cuDoubleComplex,
    ) -> cublasStatus_t;
}
